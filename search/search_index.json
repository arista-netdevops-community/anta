{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ANTA Documentation \u00b6 This website provides generic documentation related to the Arista Network Test Automation framework (ANTA) Arista Network Test Automation (ANTA) Framework \u00b6 This repository is a Python package to automate tests on Arista devices. The package name is ANTA , which stands for Arista Network Test Automation . This package provides a set of tests to validate the state of your network. This package can be imported in Python scripts: To automate NRFU (Network Ready For Use) test on a preproduction network To automate tests on a live network (periodically or on demand) This repository comes with a set of scripts to run Arista Network Test Automation (ANTA) framework check-devices.py is an easy to use script to test your network with ANTA. collect-eos-commands.py to collect commands output from devices collect-sheduled-show-tech.py to collect the scheduled show tech-support files from devices In addition you have also some useful scripts to help around testing: clear-counters.py to clear counters on devices evpn-blacklist-recovery.py to clear the list of MAC addresses which are blacklisted in EVPN create-devices-inventory-from-cvp.py : Build inventory for scripts from Arista Cloudvision (CVP) Most of these scripts use eAPI (EOS API). You can find examples of EOS automation with eAPI in this repository .","title":"Home"},{"location":"#anta-documentation","text":"This website provides generic documentation related to the Arista Network Test Automation framework (ANTA)","title":"ANTA Documentation"},{"location":"#arista-network-test-automation-anta-framework","text":"This repository is a Python package to automate tests on Arista devices. The package name is ANTA , which stands for Arista Network Test Automation . This package provides a set of tests to validate the state of your network. This package can be imported in Python scripts: To automate NRFU (Network Ready For Use) test on a preproduction network To automate tests on a live network (periodically or on demand) This repository comes with a set of scripts to run Arista Network Test Automation (ANTA) framework check-devices.py is an easy to use script to test your network with ANTA. collect-eos-commands.py to collect commands output from devices collect-sheduled-show-tech.py to collect the scheduled show tech-support files from devices In addition you have also some useful scripts to help around testing: clear-counters.py to clear counters on devices evpn-blacklist-recovery.py to clear the list of MAC addresses which are blacklisted in EVPN create-devices-inventory-from-cvp.py : Build inventory for scripts from Arista Cloudvision (CVP) Most of these scripts use eAPI (EOS API). You can find examples of EOS automation with eAPI in this repository .","title":"Arista Network Test Automation (ANTA) Framework"},{"location":"contribution/","text":"How to contribute to ANTA \u00b6 Warning Still a work in progress, feel free to reach out to the team. Install repository \u00b6 python setup.py install is used to install packages that you\u2019re not going to modify yourself. If you want to install the package and then be able to edit the code without having to re-install the package every time for the changes take effect, you can use python setup.py develop you can also use pip install -e . The . refers to the current working directory (the directory where is the setup.py file). The -e flag specifies that we want to install in editable mode, which means that when we edit the files in our package we do not need to re-install the package before the changes come into effect. You will need to reload the package though! Run these commands to install: The package ANTA and its dependencies These scripts and the packages they required git clone https://github.com/arista-netdevops-community/network-test-automation.git cd network-test-automation python setup.py develop or pip install -e . Run these commands to verify: pip list check-devices-reachability.py --help which check-devices-reachability.py Clone & Install package requirements \u00b6 Run these commands to install the packages indicated in the requirements.txt file. # Clone repository git clone https://github.com/arista-netdevops-community/network-test-automation.git # Enter into the repository cd network-test-automation # Install requirements pip install -r requirements.txt These packages are required by: These scripts The package ANTA But this will not install: The ANTA package These scripts Run this command to verify: # Check ANTA has been installed in your python path pip list | grep anta # Check scripts are in your $PATH check-devices-reachability.py --help # Find where the script is located which check-devices-reachability.py Install dev requirements \u00b6 Run the following command to install all required packages for the development process. # Install dev requirements pip install -r requirements-dev.txt # Install pre-commit hook pre-commit install","title":"Contributions"},{"location":"contribution/#how-to-contribute-to-anta","text":"Warning Still a work in progress, feel free to reach out to the team.","title":"How to contribute to ANTA"},{"location":"contribution/#install-repository","text":"python setup.py install is used to install packages that you\u2019re not going to modify yourself. If you want to install the package and then be able to edit the code without having to re-install the package every time for the changes take effect, you can use python setup.py develop you can also use pip install -e . The . refers to the current working directory (the directory where is the setup.py file). The -e flag specifies that we want to install in editable mode, which means that when we edit the files in our package we do not need to re-install the package before the changes come into effect. You will need to reload the package though! Run these commands to install: The package ANTA and its dependencies These scripts and the packages they required git clone https://github.com/arista-netdevops-community/network-test-automation.git cd network-test-automation python setup.py develop or pip install -e . Run these commands to verify: pip list check-devices-reachability.py --help which check-devices-reachability.py","title":"Install repository"},{"location":"contribution/#clone-install-package-requirements","text":"Run these commands to install the packages indicated in the requirements.txt file. # Clone repository git clone https://github.com/arista-netdevops-community/network-test-automation.git # Enter into the repository cd network-test-automation # Install requirements pip install -r requirements.txt These packages are required by: These scripts The package ANTA But this will not install: The ANTA package These scripts Run this command to verify: # Check ANTA has been installed in your python path pip list | grep anta # Check scripts are in your $PATH check-devices-reachability.py --help # Find where the script is located which check-devices-reachability.py","title":"Clone &amp; Install package requirements"},{"location":"contribution/#install-dev-requirements","text":"Run the following command to install all required packages for the development process. # Install dev requirements pip install -r requirements-dev.txt # Install pre-commit hook pre-commit install","title":"Install dev requirements"},{"location":"getting-started/","text":"Getting Started \u00b6 This section shows how to use ANTA with basic configuration. Installation \u00b6 The easiest way to intall ANTA package is to run Python ( >=3.7 ) and its pip package to install: pip install \\ git+https://github.com/arista-netdevops-community/network-test-automation.git For more details about how to install package, please see the requirements and intallation section. Configure Arista EOS devices \u00b6 First, you need to configure your management interface vrf instance MGMT ! interface Management1 description oob_management vrf MGMT ip address 10.73.1.105/24 ! Then, configure access to eAPI: ! management api http-commands protocol https port 443 no shutdown vrf MGMT no shutdown ! ! Create your inventory \u00b6 First, we need to list devices we want to test. You can create a file manually with this format: anta_inventory : hosts : - host : 10.73.1.105 Test Catalog \u00b6 To test your network, it is important to define a test catalog to list all the tests to run against your inventory. Test catalog references python functions into a yaml file. This file can be loaded by anta.loader.py The structure to follow is like: <anta_tests_submodule> : - <anta_tests_submodule function name> : <test function option> : <test function option value> Here is an example for basic things: # Load anta.tests.software software : - verify_eos_version : # Verifies the device is running one of the allowed EOS version. versions : # List of allowed EOS versions. - 4.25.4M - 4.26.1F # Load anta.tests.system system : - verify_uptime : # Verifies the device uptime is higher than a value. minimum : 1 # Load anta.tests.configuration configuration : - verify_zerotouch : # Verifies ZeroTouch is disabled. - verify_running_config_diffs : Test your network \u00b6 To test EOS devices, this package comes with a generic script to run tests in your network. It requires an inventory file as well as a test catalog. This script has multiple options to manage test coverage and reporting. python scripts/check-devices.py -h optional arguments: -h, --help show this help message and exit --inventory INVENTORY, -i INVENTORY ANTA Inventory file --catalog CATALOG, -c CATALOG ANTA Tests catalog --username USERNAME, -u USERNAME EOS Username --password PASSWORD, -p PASSWORD EOS Password --enable_password ENABLE_PASSWORD, -e ENABLE_PASSWORD EOS Enable Password --timeout TIMEOUT, -t TIMEOUT eAPI connection timeout --hostip HOSTIP search result for host --test TEST search result for test --tags TAGS List of device tags to limit scope of testing --list Display internal data --json Display data in json format --table Result represented in tables --save SAVE Save output to file. Only valid for --list and --json --all-results Display all test cases results. Default table view ( Only valid with --table ) --by-host Provides summary of test results per device ( Only valid with --table ) --by-test Provides summary of test results per test case ( Only valid with --table ) Default output is a table format listing all test results, and it can be changed to a report per test case or per host Default report \u00b6 $ check-devices.py -i .personal/avd-lab.yml -c .personal/ceos-catalog.yml --table All tests results \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Device IP \u2503 Test Name \u2503 Test Status \u2503 Message ( s ) \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 10 .73.252.11 \u2502 verify_mlag_interfaces \u2502 success \u2502 \u2502 \u2502 10 .73.252.12 \u2502 verify_mlag_interfaces \u2502 success \u2502 \u2502 \u2502 10 .73.252.102 \u2502 verify_mlag_interfaces \u2502 skipped \u2502 MLAG is disabled \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Report per test case \u00b6 $ check-devices.py -i .personal/avd-lab.yml -c .personal/ceos-catalog.yml --table --by-test --test verify_mlag_status Summary per test case \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Test Case \u2503 # of success \u2503 # of skipped \u2503 # of failure \u2503 # of errors \u2503 List of failed or error nodes \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 verify_mlag_status \u2502 8 \u2502 13 \u2502 0 \u2502 0 \u2502 [] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Report per host \u00b6 $ check-devices.py -i .personal/avd-lab.yml -c .personal/ceos-catalog.yml --table --by-host --test verify_mlag_status --hostip 10 .73.252.21 Summary per host \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Host IP \u2503 # of success \u2503 # of skipped \u2503 # of failure \u2503 # of errors \u2503 List of failed ortest case \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 10 .73.252.21 \u2502 0 \u2502 1 \u2502 0 \u2502 0 \u2502 [] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 You can find more information under the usage section of the website","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"This section shows how to use ANTA with basic configuration.","title":"Getting Started"},{"location":"getting-started/#installation","text":"The easiest way to intall ANTA package is to run Python ( >=3.7 ) and its pip package to install: pip install \\ git+https://github.com/arista-netdevops-community/network-test-automation.git For more details about how to install package, please see the requirements and intallation section.","title":"Installation"},{"location":"getting-started/#configure-arista-eos-devices","text":"First, you need to configure your management interface vrf instance MGMT ! interface Management1 description oob_management vrf MGMT ip address 10.73.1.105/24 ! Then, configure access to eAPI: ! management api http-commands protocol https port 443 no shutdown vrf MGMT no shutdown ! !","title":"Configure Arista EOS devices"},{"location":"getting-started/#create-your-inventory","text":"First, we need to list devices we want to test. You can create a file manually with this format: anta_inventory : hosts : - host : 10.73.1.105","title":"Create your inventory"},{"location":"getting-started/#test-catalog","text":"To test your network, it is important to define a test catalog to list all the tests to run against your inventory. Test catalog references python functions into a yaml file. This file can be loaded by anta.loader.py The structure to follow is like: <anta_tests_submodule> : - <anta_tests_submodule function name> : <test function option> : <test function option value> Here is an example for basic things: # Load anta.tests.software software : - verify_eos_version : # Verifies the device is running one of the allowed EOS version. versions : # List of allowed EOS versions. - 4.25.4M - 4.26.1F # Load anta.tests.system system : - verify_uptime : # Verifies the device uptime is higher than a value. minimum : 1 # Load anta.tests.configuration configuration : - verify_zerotouch : # Verifies ZeroTouch is disabled. - verify_running_config_diffs :","title":"Test Catalog"},{"location":"getting-started/#test-your-network","text":"To test EOS devices, this package comes with a generic script to run tests in your network. It requires an inventory file as well as a test catalog. This script has multiple options to manage test coverage and reporting. python scripts/check-devices.py -h optional arguments: -h, --help show this help message and exit --inventory INVENTORY, -i INVENTORY ANTA Inventory file --catalog CATALOG, -c CATALOG ANTA Tests catalog --username USERNAME, -u USERNAME EOS Username --password PASSWORD, -p PASSWORD EOS Password --enable_password ENABLE_PASSWORD, -e ENABLE_PASSWORD EOS Enable Password --timeout TIMEOUT, -t TIMEOUT eAPI connection timeout --hostip HOSTIP search result for host --test TEST search result for test --tags TAGS List of device tags to limit scope of testing --list Display internal data --json Display data in json format --table Result represented in tables --save SAVE Save output to file. Only valid for --list and --json --all-results Display all test cases results. Default table view ( Only valid with --table ) --by-host Provides summary of test results per device ( Only valid with --table ) --by-test Provides summary of test results per test case ( Only valid with --table ) Default output is a table format listing all test results, and it can be changed to a report per test case or per host","title":"Test your network"},{"location":"getting-started/#default-report","text":"$ check-devices.py -i .personal/avd-lab.yml -c .personal/ceos-catalog.yml --table All tests results \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Device IP \u2503 Test Name \u2503 Test Status \u2503 Message ( s ) \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 10 .73.252.11 \u2502 verify_mlag_interfaces \u2502 success \u2502 \u2502 \u2502 10 .73.252.12 \u2502 verify_mlag_interfaces \u2502 success \u2502 \u2502 \u2502 10 .73.252.102 \u2502 verify_mlag_interfaces \u2502 skipped \u2502 MLAG is disabled \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Default report"},{"location":"getting-started/#report-per-test-case","text":"$ check-devices.py -i .personal/avd-lab.yml -c .personal/ceos-catalog.yml --table --by-test --test verify_mlag_status Summary per test case \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Test Case \u2503 # of success \u2503 # of skipped \u2503 # of failure \u2503 # of errors \u2503 List of failed or error nodes \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 verify_mlag_status \u2502 8 \u2502 13 \u2502 0 \u2502 0 \u2502 [] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Report per test case"},{"location":"getting-started/#report-per-host","text":"$ check-devices.py -i .personal/avd-lab.yml -c .personal/ceos-catalog.yml --table --by-host --test verify_mlag_status --hostip 10 .73.252.21 Summary per host \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Host IP \u2503 # of success \u2503 # of skipped \u2503 # of failure \u2503 # of errors \u2503 List of failed ortest case \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 10 .73.252.21 \u2502 0 \u2502 1 \u2502 0 \u2502 0 \u2502 [] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 You can find more information under the usage section of the website","title":"Report per host"},{"location":"requirements-and-installation/","text":"ANTA Requirements \u00b6 Python version \u00b6 Python 3 ( >=3.7 and =<3.10 ) is required: python --version Python 3 .9.9 Install ANTA package \u00b6 This installation will deploy tests collection, scripts and all their Python requirements. The ANTA package and the scripts require some packages that are not part of the Python standard library. They are indicated in the requirements.txt file There are several ways to installt the ANTA and the scripts and the requirements . This is described below. Run this command to install: The package ANTA and its dependencies These scripts and packages they required pip install git+https://github.com/arista-netdevops-community/network-test-automation.git You can even specify the commit you would like to install. Run these commands to verify: # Check ANTA has been installed in your python path pip list | grep anta # Check scripts are in your $PATH check-devices-reachability.py --help # Find where the script is located which check-devices-reachability.py To update, simply run pip with -U option: pip install -U git+https://github.com/arista-netdevops-community/network-test-automation.git EOS Requirements \u00b6 configure ! vrf instance MGMT ! interface Management1 description oob_management vrf MGMT ip address 10.73.1.105/24 ! end Enable eAPI on the MGMT vrf: configure ! management api http-commands protocol https port 443 no shutdown vrf MGMT no shutdown ! end Now the swicth accepts on port 443 in the MGMT VRF HTTPS requests containing a list of CLI commands. Run these EOS commands to verify: switch1#show management http-server switch1#show management api http-commands Check eAPI and ANTA \u00b6 Execute this python script to validate: You can import the jsonrpclib library The device reachability using eAPI Use your device credentials and IP address. import ssl from jsonrpclib import Server from anta.tests.system import verify_ntp ssl . _create_default_https_context = ssl . _create_unverified_context # Update credentials accordingly USERNAME = \"arista\" PASSWORD = \"aristatwfn\" ENABLE_PASSWORD = \"aristatwfn\" # Change IP address with an Arista EOS device IP = \"192.168.0.12\" url = f 'https:// { USERNAME } : { PASSWORD } @ { IP } /command-api' switch = Server ( url ) result = switch . runCmds ( 1 ,[ 'show version' ], 'json' ) # Check eAPI is reachable print ( result [ 0 ][ 'uptime' ]) # Check ANTA package is correctly installed print ( verify_ntp . __doc__ )","title":"Installation"},{"location":"requirements-and-installation/#anta-requirements","text":"","title":"ANTA Requirements"},{"location":"requirements-and-installation/#python-version","text":"Python 3 ( >=3.7 and =<3.10 ) is required: python --version Python 3 .9.9","title":"Python version"},{"location":"requirements-and-installation/#install-anta-package","text":"This installation will deploy tests collection, scripts and all their Python requirements. The ANTA package and the scripts require some packages that are not part of the Python standard library. They are indicated in the requirements.txt file There are several ways to installt the ANTA and the scripts and the requirements . This is described below. Run this command to install: The package ANTA and its dependencies These scripts and packages they required pip install git+https://github.com/arista-netdevops-community/network-test-automation.git You can even specify the commit you would like to install. Run these commands to verify: # Check ANTA has been installed in your python path pip list | grep anta # Check scripts are in your $PATH check-devices-reachability.py --help # Find where the script is located which check-devices-reachability.py To update, simply run pip with -U option: pip install -U git+https://github.com/arista-netdevops-community/network-test-automation.git","title":"Install ANTA package"},{"location":"requirements-and-installation/#eos-requirements","text":"configure ! vrf instance MGMT ! interface Management1 description oob_management vrf MGMT ip address 10.73.1.105/24 ! end Enable eAPI on the MGMT vrf: configure ! management api http-commands protocol https port 443 no shutdown vrf MGMT no shutdown ! end Now the swicth accepts on port 443 in the MGMT VRF HTTPS requests containing a list of CLI commands. Run these EOS commands to verify: switch1#show management http-server switch1#show management api http-commands","title":"EOS Requirements"},{"location":"requirements-and-installation/#check-eapi-and-anta","text":"Execute this python script to validate: You can import the jsonrpclib library The device reachability using eAPI Use your device credentials and IP address. import ssl from jsonrpclib import Server from anta.tests.system import verify_ntp ssl . _create_default_https_context = ssl . _create_unverified_context # Update credentials accordingly USERNAME = \"arista\" PASSWORD = \"aristatwfn\" ENABLE_PASSWORD = \"aristatwfn\" # Change IP address with an Arista EOS device IP = \"192.168.0.12\" url = f 'https:// { USERNAME } : { PASSWORD } @ { IP } /command-api' switch = Server ( url ) result = switch . runCmds ( 1 ,[ 'show version' ], 'json' ) # Check eAPI is reachable print ( result [ 0 ][ 'uptime' ]) # Check ANTA package is correctly installed print ( verify_ntp . __doc__ )","title":"Check eAPI and ANTA"},{"location":"usage-as-python-lib/","text":"How to use ANTA as a Python Library \u00b6 ANTA has been built to allow user to embeded its tools in your own application. This section describes how you can leverage ANTA modules to help you create your own NRFU solution. Inventory Manager \u00b6 Inventory class is in charge of creating a list of hosts with their information and an eAPI session ready to be consummed. To do that, it connects to all devices to check reachability and ensure eAPI is running. from anta.inventory import AntaInventory inventory = AntaInventory ( inventory_file = \"inventory.yml\" , username = \"username\" , password = \"password\" , enable_password = \"enable\" , auto_connect = True , timeout = 1 , ) Then it is easy to get all devices or only active devices with the following method: # print the non reachable devices for device in inventory . get_inventory ( established_only = False ): if device . established is False : print ( f \"Could not connect to device { device . host } \" ) # run an EOS commands list on the reachable devices from the inventory for device in inventory . get_inventory ( established_only = True ): device . session . runCmds ( 1 , [ \"show version\" , \"show ip bgp summary\" ] ) You can find data model for anta.inventory.AntaInventory in the auto-generated documentation . How to create your inventory file Please visit this dedicated section for how to use inventory and catalog files. Use tests from ANTA \u00b6 All the test functions are based on the exact same input and returns a generic structure with different information. Test input \u00b6 Any test input is based on an InventoryDevice object and a list of options. Here is an example to check uptime and check it is higher than minimum option. def verify_uptime ( device : InventoryDevice , minimum : int = None ) -> TestResult : In general, InventoryDevice is an object created by AntaInventory . But it can be manually generated by following required data model. Here is an example of a list of InventoryDevice [ { \"InventoryDevice(host=IPv4Address('192.168.0.17')\" , \"username='ansible'\" , \"password='ansible'\" , \"session=<ServerProxy for ansible:ansible@192.168.0.17/command-api>\" , \"url='https://ansible:ansible@192.168.0.17/command-api'\" , \"established=True\" , \"is_online=True\" , \"hw_model=cEOS-LAB\" , }, { \"InventoryDevice(host=IPv4Address('192.168.0.2')\" , \"username='ansible'\" , \"password='ansible'\" , \"session=None\" , \"url='https://ansible:ansible@192.168.0.2/command-api'\" , \"established=False\" \"is_online=False\" , \"tags\" : [ 'dc1' , 'spine' , 'pod01' ], \"hw_model=unset\" , } ] Test output \u00b6 All tests return a TestResult structure with the following elements: result : Can be success , skipped , failure , error and report result of the test host : IP address of the tested device test : Test name runs on host message : Optional message returned by the test. Test structure \u00b6 All tests are based on this structure: def < test name > ( device : InventoryDevice , < list of args > ) -> TestResult : \"\"\" dosctring desccription Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the `minimum` parameter is missing * result = \"success\" if uptime is greater than minimun * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] # Test if options are valid (optional) if not minimum : result . is_skipped ( \"verify_uptime was not run as no minimum were given\" ) return result # Try to connect and execute command on device try : response = device . session . runCmds ( 1 , [ \"show uptime\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) response_data = response [ 0 ][ \"upTime\" ] # Check conditions # ... # Capture any exception to return failure reason except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for \\ { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) # Return data to caller return result Get test function documentation \u00b6 Open an interactive python shell and run following commands: >>> from anta.tests.system import * >>> help ( verify_ntp ) Help on function verify_ntp in module anta . tests . system : verify_ntp ( device : anta . inventory . models . InventoryDevice ) -> anta . result_manager . models . TestResult Verifies NTP is synchronised . Args : device ( InventoryDevice ): InventoryDevice instance containing all devices information . Returns : TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if synchronized with NTP server * result = \"failure\" otherwise . * result = \"error\" if any exception is caught >>> exit () If you need to expose test description, you can use this workaround: from anta.tests.system import * print ( f ' { verify_ntp . __doc__ . split ( \" \\n \" )[ 0 ] } ' )","title":"ANTA as python lib"},{"location":"usage-as-python-lib/#how-to-use-anta-as-a-python-library","text":"ANTA has been built to allow user to embeded its tools in your own application. This section describes how you can leverage ANTA modules to help you create your own NRFU solution.","title":"How to use ANTA as a Python Library"},{"location":"usage-as-python-lib/#inventory-manager","text":"Inventory class is in charge of creating a list of hosts with their information and an eAPI session ready to be consummed. To do that, it connects to all devices to check reachability and ensure eAPI is running. from anta.inventory import AntaInventory inventory = AntaInventory ( inventory_file = \"inventory.yml\" , username = \"username\" , password = \"password\" , enable_password = \"enable\" , auto_connect = True , timeout = 1 , ) Then it is easy to get all devices or only active devices with the following method: # print the non reachable devices for device in inventory . get_inventory ( established_only = False ): if device . established is False : print ( f \"Could not connect to device { device . host } \" ) # run an EOS commands list on the reachable devices from the inventory for device in inventory . get_inventory ( established_only = True ): device . session . runCmds ( 1 , [ \"show version\" , \"show ip bgp summary\" ] ) You can find data model for anta.inventory.AntaInventory in the auto-generated documentation . How to create your inventory file Please visit this dedicated section for how to use inventory and catalog files.","title":"Inventory Manager"},{"location":"usage-as-python-lib/#use-tests-from-anta","text":"All the test functions are based on the exact same input and returns a generic structure with different information.","title":"Use tests from ANTA"},{"location":"usage-as-python-lib/#test-input","text":"Any test input is based on an InventoryDevice object and a list of options. Here is an example to check uptime and check it is higher than minimum option. def verify_uptime ( device : InventoryDevice , minimum : int = None ) -> TestResult : In general, InventoryDevice is an object created by AntaInventory . But it can be manually generated by following required data model. Here is an example of a list of InventoryDevice [ { \"InventoryDevice(host=IPv4Address('192.168.0.17')\" , \"username='ansible'\" , \"password='ansible'\" , \"session=<ServerProxy for ansible:ansible@192.168.0.17/command-api>\" , \"url='https://ansible:ansible@192.168.0.17/command-api'\" , \"established=True\" , \"is_online=True\" , \"hw_model=cEOS-LAB\" , }, { \"InventoryDevice(host=IPv4Address('192.168.0.2')\" , \"username='ansible'\" , \"password='ansible'\" , \"session=None\" , \"url='https://ansible:ansible@192.168.0.2/command-api'\" , \"established=False\" \"is_online=False\" , \"tags\" : [ 'dc1' , 'spine' , 'pod01' ], \"hw_model=unset\" , } ]","title":"Test input"},{"location":"usage-as-python-lib/#test-output","text":"All tests return a TestResult structure with the following elements: result : Can be success , skipped , failure , error and report result of the test host : IP address of the tested device test : Test name runs on host message : Optional message returned by the test.","title":"Test output"},{"location":"usage-as-python-lib/#test-structure","text":"All tests are based on this structure: def < test name > ( device : InventoryDevice , < list of args > ) -> TestResult : \"\"\" dosctring desccription Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the `minimum` parameter is missing * result = \"success\" if uptime is greater than minimun * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] # Test if options are valid (optional) if not minimum : result . is_skipped ( \"verify_uptime was not run as no minimum were given\" ) return result # Try to connect and execute command on device try : response = device . session . runCmds ( 1 , [ \"show uptime\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) response_data = response [ 0 ][ \"upTime\" ] # Check conditions # ... # Capture any exception to return failure reason except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for \\ { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) # Return data to caller return result","title":"Test structure"},{"location":"usage-as-python-lib/#get-test-function-documentation","text":"Open an interactive python shell and run following commands: >>> from anta.tests.system import * >>> help ( verify_ntp ) Help on function verify_ntp in module anta . tests . system : verify_ntp ( device : anta . inventory . models . InventoryDevice ) -> anta . result_manager . models . TestResult Verifies NTP is synchronised . Args : device ( InventoryDevice ): InventoryDevice instance containing all devices information . Returns : TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if synchronized with NTP server * result = \"failure\" otherwise . * result = \"error\" if any exception is caught >>> exit () If you need to expose test description, you can use this workaround: from anta.tests.system import * print ( f ' { verify_ntp . __doc__ . split ( \" \\n \" )[ 0 ] } ' )","title":"Get test function documentation"},{"location":"usage-check-devices/","text":"How to use ANTA scripts \u00b6 ANTA comes with some scripts to leverage network testing immediatly or if you don\u2019t want to create your own application. This page describes how to use check-devices.py script to run your network testing. Create inventory & tests catalog Please visit this dedicated section for how to use inventory and catalog files. Check devices script \u00b6 The check-devices.py script comes with a number of options you can use for the testing. Some are mandatory where some others are optionals. Required options \u00b6 Specify inventory and test catalog \u00b6 There is no default file for inventory and tests catalog, so you have to provide paths in CLI using following triggers: check-devices.py -i .personal/avd-lab.yml \\ -c .personal/ceos-catalog.yml Specify username and password \u00b6 The script needs your credentials to connect to devices and they have to be provided in the CLI directly. So it is easy to execute this script in a CI pipeline by sending secrets using an environment variable. check-devices.py -i .personal/avd-lab.yml \\ -c .personal/ceos-catalog.yml \\ --username admin \\ --password admin123 Specify output format \u00b6 Since this script can be used for human reporting or within a more complete scenario, user is free to select either table , list or json output format. check-devices.py -i .personal/avd-lab.yml \\ -c .personal/ceos-catalog.yml \\ --username admin \\ --password admin123 \\ -- ( table | list | json ) This --table option provides a nice human readable format where --list is more a grepable output and --json is more to send output to another script Available options \u00b6 Then, besides the mandatory keys, some options are available such as: Tag ( --tag ): to run tests against a subset of your inventory. Timeout ( --timeout ): if some devices are not close to your tester, it might be useful to increase response delay. Enable Password ( --enable_password ): Allow to configure optional enable password required for some tests. Run tests for a specific host ( --hostip ) Run tests for a specific test ( --test ) Also, when you use --table for output, you can get some report summaries: Per host overview ( --by-host ): list number of sucessful, skipped, failed tests and list all failed tests. Per test overview ( --by-test ): list number of sucessful, skipped, failed hosts and list all failed hosts. Save JSON format to a file: use the --save <path/to/output/file.json> option. # Run testing check-devices.py -i .personal/avd-lab.yml \\ -c .personal/ceos-catalog.yml \\ --username admin \\ --password admin123 \\ -- ( table | list | json ) # Display saved results head -n 8 demo.json [ { \"host\" : \"10.73.252.11\" , \"test\" : \"verify_eos_version\" , \"result\" : \"failure\" , \"messages\" : \"[\\\"device is running version 4.27.2F-26069621.4272F (engineering build) not in expected versions: ['4.25.4M', '4.26.1F']\\\"]\" } ,","title":"Check Devices"},{"location":"usage-check-devices/#how-to-use-anta-scripts","text":"ANTA comes with some scripts to leverage network testing immediatly or if you don\u2019t want to create your own application. This page describes how to use check-devices.py script to run your network testing. Create inventory & tests catalog Please visit this dedicated section for how to use inventory and catalog files.","title":"How to use ANTA scripts"},{"location":"usage-check-devices/#check-devices-script","text":"The check-devices.py script comes with a number of options you can use for the testing. Some are mandatory where some others are optionals.","title":"Check devices script"},{"location":"usage-check-devices/#required-options","text":"","title":"Required options"},{"location":"usage-check-devices/#specify-inventory-and-test-catalog","text":"There is no default file for inventory and tests catalog, so you have to provide paths in CLI using following triggers: check-devices.py -i .personal/avd-lab.yml \\ -c .personal/ceos-catalog.yml","title":"Specify inventory and test catalog"},{"location":"usage-check-devices/#specify-username-and-password","text":"The script needs your credentials to connect to devices and they have to be provided in the CLI directly. So it is easy to execute this script in a CI pipeline by sending secrets using an environment variable. check-devices.py -i .personal/avd-lab.yml \\ -c .personal/ceos-catalog.yml \\ --username admin \\ --password admin123","title":"Specify username and password"},{"location":"usage-check-devices/#specify-output-format","text":"Since this script can be used for human reporting or within a more complete scenario, user is free to select either table , list or json output format. check-devices.py -i .personal/avd-lab.yml \\ -c .personal/ceos-catalog.yml \\ --username admin \\ --password admin123 \\ -- ( table | list | json ) This --table option provides a nice human readable format where --list is more a grepable output and --json is more to send output to another script","title":"Specify output format"},{"location":"usage-check-devices/#available-options","text":"Then, besides the mandatory keys, some options are available such as: Tag ( --tag ): to run tests against a subset of your inventory. Timeout ( --timeout ): if some devices are not close to your tester, it might be useful to increase response delay. Enable Password ( --enable_password ): Allow to configure optional enable password required for some tests. Run tests for a specific host ( --hostip ) Run tests for a specific test ( --test ) Also, when you use --table for output, you can get some report summaries: Per host overview ( --by-host ): list number of sucessful, skipped, failed tests and list all failed tests. Per test overview ( --by-test ): list number of sucessful, skipped, failed hosts and list all failed hosts. Save JSON format to a file: use the --save <path/to/output/file.json> option. # Run testing check-devices.py -i .personal/avd-lab.yml \\ -c .personal/ceos-catalog.yml \\ --username admin \\ --password admin123 \\ -- ( table | list | json ) # Display saved results head -n 8 demo.json [ { \"host\" : \"10.73.252.11\" , \"test\" : \"verify_eos_version\" , \"result\" : \"failure\" , \"messages\" : \"[\\\"device is running version 4.27.2F-26069621.4272F (engineering build) not in expected versions: ['4.25.4M', '4.26.1F']\\\"]\" } ,","title":"Available options"},{"location":"usage-inventory-catalog/","text":"Inventory & Catalog definition \u00b6 This page describes how to create an inventory and a tests catalog. Create an inventory file \u00b6 check-devices needs an inventory file to list all devices to tests. This inventory is a YAML file with the folowing keys: anta_inventory : hosts : - host : 1.1.1.1 networks : - network : '1.1.2.0/24' ranges : - start : 1.1.3.10 end : 1.1.3.21 In this configuration file, you can use different device definitions: hosts : is a list of single Arista EOS host to check. networks : is a list of networks where check-devices.py will search for active EOS devices. ranges : is a range of IP addresses where check-devices.py will search for active EOS devices. Your inventory file can be based on any of these 3 keys and shall start with anta_inventory key. Besides this standard definition, you can also define some tags to target a subset of devices during your tests exeution. it can be useful to only run test about VXLAN on leaf only and skip underlay devices. anta_inventory : hosts : - host : 1.1.1.1 tags : [ 'leaf' , 'border' ] networks : - network : '1.1.2.0/24' tags : [ 'leaf' ] ranges : - start : 1.1.3.10 end : 1.1.3.21 tags : [ 'spines' ] Tag definition is a list of string you defined according your own setup. If not defined, a default tag ( default ) is generated during script execution. Test Catalog \u00b6 In addition to your inventory file, you also have to define a catalog of tests to execute against all your devices. This catalogue list all your tests and their parameters. Its format is a YAML file and keys are tests functions inherited from the python path. Let\u2019s take an example below: All tests are located under anta.tests module and are categorised per family (one submodule). So to run test for software version, you can do: software : - verify_eos_version : It will load the test verify_eos_version located in anta.tests.software . But since this function has parameters, we will create a catalog with the following structure: software : - verify_eos_version : # List of allowed EOS versions. versions : - 4.25.4M - 4.26.1F To get a list of all available tests and their respective parameters, you can read the tests section of this website. The following example gives a very minimal tests catalog you can use in almost any situation --- # Load anta.tests.software software : # Verifies the device is running one of the allowed EOS version. - verify_eos_version : # List of allowed EOS versions. versions : - 4.25.4M - 4.26.1F # Load anta.tests.system system : # Verifies the device uptime is higher than a value. - verify_uptime : minimum : 1 # Load anta.tests.configuration configuration : # Verifies ZeroTouch is disabled. - verify_zerotouch : - verify_running_config_diffs :","title":"Inventory & Tests catalog"},{"location":"usage-inventory-catalog/#inventory-catalog-definition","text":"This page describes how to create an inventory and a tests catalog.","title":"Inventory &amp; Catalog definition"},{"location":"usage-inventory-catalog/#create-an-inventory-file","text":"check-devices needs an inventory file to list all devices to tests. This inventory is a YAML file with the folowing keys: anta_inventory : hosts : - host : 1.1.1.1 networks : - network : '1.1.2.0/24' ranges : - start : 1.1.3.10 end : 1.1.3.21 In this configuration file, you can use different device definitions: hosts : is a list of single Arista EOS host to check. networks : is a list of networks where check-devices.py will search for active EOS devices. ranges : is a range of IP addresses where check-devices.py will search for active EOS devices. Your inventory file can be based on any of these 3 keys and shall start with anta_inventory key. Besides this standard definition, you can also define some tags to target a subset of devices during your tests exeution. it can be useful to only run test about VXLAN on leaf only and skip underlay devices. anta_inventory : hosts : - host : 1.1.1.1 tags : [ 'leaf' , 'border' ] networks : - network : '1.1.2.0/24' tags : [ 'leaf' ] ranges : - start : 1.1.3.10 end : 1.1.3.21 tags : [ 'spines' ] Tag definition is a list of string you defined according your own setup. If not defined, a default tag ( default ) is generated during script execution.","title":"Create an inventory file"},{"location":"usage-inventory-catalog/#test-catalog","text":"In addition to your inventory file, you also have to define a catalog of tests to execute against all your devices. This catalogue list all your tests and their parameters. Its format is a YAML file and keys are tests functions inherited from the python path. Let\u2019s take an example below: All tests are located under anta.tests module and are categorised per family (one submodule). So to run test for software version, you can do: software : - verify_eos_version : It will load the test verify_eos_version located in anta.tests.software . But since this function has parameters, we will create a catalog with the following structure: software : - verify_eos_version : # List of allowed EOS versions. versions : - 4.25.4M - 4.26.1F To get a list of all available tests and their respective parameters, you can read the tests section of this website. The following example gives a very minimal tests catalog you can use in almost any situation --- # Load anta.tests.software software : # Verifies the device is running one of the allowed EOS version. - verify_eos_version : # List of allowed EOS versions. versions : - 4.25.4M - 4.26.1F # Load anta.tests.system system : # Verifies the device uptime is higher than a value. - verify_uptime : minimum : 1 # Load anta.tests.configuration configuration : # Verifies ZeroTouch is disabled. - verify_zerotouch : - verify_running_config_diffs :","title":"Test Catalog"},{"location":"usage/","text":"Repository usage \u00b6 Once you are done with the installation, you can use the the scripts or the ANTA package. How to use the scripts \u00b6 How to create an inventory from CVP \u00b6 The python script create-devices-inventory-from-cvp.py create an inventory text file using CVP. Run these commands to get an inventory with all devices IP address. ./create-devices-inventory-from-cvp.py --help ./create-devices-inventory-from-cvp.py -cvp 192 .168.0.5 -u arista -o inventory cat inventory/all.yml Run these commands to get an inventory with the IP address of the devices under the container Spine ./create-devices-inventory-from-cvp.py --help ./create-devices-inventory-from-cvp.py -cvp 192 .168.0.5 -u arista -o inventory -c Spine cat inventory/Spine.yml How to check devices state \u00b6 Info Please visit this dedicated section for check-devices.py script How to collect commands output \u00b6 Info Please visit this dedicated section for how to use inventory file. The python script collect-eos-commands.py runs show commands on devices and collects the output: Update the devices inventory Update the EOS commands list you would like to collect from the devices in text or JSON format Run the python script collect-eos-commands.py The commands output is saved in the output directory vi inventory.yml vi eos-commands.yaml ./collect-eos-commands.py --help ./collect-eos-commands.py -i inventory.yml -c eos-commands.yaml -o outdir -u username -p password ls outdir How to collect the scheduled show tech-support files \u00b6 Info Please visit this dedicated section for how to use inventory file. The python script collect-sheduled-show-tech.py collects the scheduled show tech-support files: Update the devices inventory Run the python script collect-sheduled-show-tech.py The files are saved in the output directory vi inventory.yml ./collect-sheduled-show-tech.py --help ./collect-sheduled-show-tech.py -i inventory.yml -u username -o outdir ls outdir How to clear counters \u00b6 The python script clear-counters.py clears counters: Info Please visit this dedicated section for how to use inventory file. Update the devices inventory Run the python script clear-counters.py vi inventory.yml ./clear-counters.py --help ./clear-counters.py -i inventory.yml -u username How to clear the MAC addresses which are blacklisted in EVPN \u00b6 The python script evpn-blacklist-recovery.py clears the MAC addresses which are blacklisted in EVPN: Info Please visit this dedicated section for how to use inventory file. Update the devices inventory Run the python script evpn-blacklist-recovery.py vi inventory.yml ./evpn-blacklist-recovery.py --help ./evpn-blacklist-recovery.py -i inventory.yml -u username","title":"Other scripts"},{"location":"usage/#repository-usage","text":"Once you are done with the installation, you can use the the scripts or the ANTA package.","title":"Repository usage"},{"location":"usage/#how-to-use-the-scripts","text":"","title":"How to use the scripts"},{"location":"usage/#how-to-create-an-inventory-from-cvp","text":"The python script create-devices-inventory-from-cvp.py create an inventory text file using CVP. Run these commands to get an inventory with all devices IP address. ./create-devices-inventory-from-cvp.py --help ./create-devices-inventory-from-cvp.py -cvp 192 .168.0.5 -u arista -o inventory cat inventory/all.yml Run these commands to get an inventory with the IP address of the devices under the container Spine ./create-devices-inventory-from-cvp.py --help ./create-devices-inventory-from-cvp.py -cvp 192 .168.0.5 -u arista -o inventory -c Spine cat inventory/Spine.yml","title":"How to create an inventory from CVP"},{"location":"usage/#how-to-check-devices-state","text":"Info Please visit this dedicated section for check-devices.py script","title":"How to check devices state"},{"location":"usage/#how-to-collect-commands-output","text":"Info Please visit this dedicated section for how to use inventory file. The python script collect-eos-commands.py runs show commands on devices and collects the output: Update the devices inventory Update the EOS commands list you would like to collect from the devices in text or JSON format Run the python script collect-eos-commands.py The commands output is saved in the output directory vi inventory.yml vi eos-commands.yaml ./collect-eos-commands.py --help ./collect-eos-commands.py -i inventory.yml -c eos-commands.yaml -o outdir -u username -p password ls outdir","title":"How to collect commands output"},{"location":"usage/#how-to-collect-the-scheduled-show-tech-support-files","text":"Info Please visit this dedicated section for how to use inventory file. The python script collect-sheduled-show-tech.py collects the scheduled show tech-support files: Update the devices inventory Run the python script collect-sheduled-show-tech.py The files are saved in the output directory vi inventory.yml ./collect-sheduled-show-tech.py --help ./collect-sheduled-show-tech.py -i inventory.yml -u username -o outdir ls outdir","title":"How to collect the scheduled show tech-support files"},{"location":"usage/#how-to-clear-counters","text":"The python script clear-counters.py clears counters: Info Please visit this dedicated section for how to use inventory file. Update the devices inventory Run the python script clear-counters.py vi inventory.yml ./clear-counters.py --help ./clear-counters.py -i inventory.yml -u username","title":"How to clear counters"},{"location":"usage/#how-to-clear-the-mac-addresses-which-are-blacklisted-in-evpn","text":"The python script evpn-blacklist-recovery.py clears the MAC addresses which are blacklisted in EVPN: Info Please visit this dedicated section for how to use inventory file. Update the devices inventory Run the python script evpn-blacklist-recovery.py vi inventory.yml ./evpn-blacklist-recovery.py --help ./evpn-blacklist-recovery.py -i inventory.yml -u username","title":"How to clear the MAC addresses which are blacklisted in EVPN"},{"location":"api/inventory/","text":"ANTA Inventory module \u00b6 Inventory Abstraction for ANTA framework. Attributes: Name Type Description timeout float Connection to device timeout. INVENTORY_ROOT_KEY str , Optional head of the YAML inventory. Default is anta_inventory EAPI_SESSION_TPL str , Optional Template for eAPI URL builder INVENTORY_OUTPUT_FORMAT List [ str ], Optional List of supported output format. Default [\u2018native\u2019, \u2018json\u2019] HW_MODEL_KEY str , Optional Name of the key in Arista eAPI JSON provided by device. Examples: Inventory file input print ( inventory . yml ) anta_inventory : hosts : - hosts : 1 . 1 . 1 . 1 - host : 2 . 2 . 2 . 2 tags : [ 'dc1' , 'spine' , 'pod01' ] networks : - network : 10 . 0 . 0 . 0 / 8 - network : 192 . 168 . 0 . 0 / 16 tags : [ 'dc1' , 'spine' , 'pod01' ] ranges : - start : 10 . 0 . 0 . 1 end : 10 . 0 . 0 . 11 tags : [ 'dc1' , 'spine' , 'pod01' ] Inventory result: test = AntaInventory ( ... inventory_file = ' examples / inventory . yml ' , ... username = ' ansible ' , ... password = ' ansible ' , ... auto_connect = True ) test . get_inventory () [ \"InventoryDevice(host=IPv4Address('192.168.0.17')\" , \"username='ansible'\" , \"password='ansible'\" , \"session=<ServerProxy for ansible:ansible@192.168.0.17/command-api>\" , \"url='https://ansible:ansible@192.168.0.17/command-api'\" , \"established=True\" , \"is_online=True\" , \"hw_model=cEOS-LAB\" , ... \"InventoryDevice(host=IPv4Address('192.168.0.2')\" , \"username='ansible'\" , \"password='ansible'\" , \"session=None\" , \"url='https://ansible:ansible@192.168.0.2/command-api'\" , \"established=False\" \"is_online=False\" , \"tags\" : [ ' dc1 ' , ' spine ' , ' pod01 ' ], \"hw_model=unset\" , ] Raises: Type Description InventoryRootKeyErrors Root key of inventory is missing. InventoryIncorrectSchema Inventory file is not following AntaInventory Schema. InventoryUnknownFormat Output format is not supported. Source code in anta/inventory/__init__.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 class AntaInventory (): \"\"\" Inventory Abstraction for ANTA framework. Attributes: timeout (float): Connection to device timeout. INVENTORY_ROOT_KEY (str, Optional): head of the YAML inventory. Default is anta_inventory EAPI_SESSION_TPL (str, Optional): Template for eAPI URL builder INVENTORY_OUTPUT_FORMAT (List[str],Optional): List of supported output format. Default ['native', 'json'] HW_MODEL_KEY (str,Optional): Name of the key in Arista eAPI JSON provided by device. Examples: Inventory file input print(inventory.yml) anta_inventory: hosts: - hosts: 1.1.1.1 - host: 2.2.2.2 tags: ['dc1', 'spine', 'pod01'] networks: - network: 10.0.0.0/8 - network: 192.168.0.0/16 tags: ['dc1', 'spine', 'pod01'] ranges: - start: 10.0.0.1 end: 10.0.0.11 tags: ['dc1', 'spine', 'pod01'] Inventory result: test = AntaInventory( ... inventory_file='examples/inventory.yml', ... username='ansible', ... password='ansible', ... auto_connect=True) test.get_inventory() [ \"InventoryDevice(host=IPv4Address('192.168.0.17')\", \"username='ansible'\", \"password='ansible'\", \"session=<ServerProxy for ansible:ansible@192.168.0.17/command-api>\", \"url='https://ansible:ansible@192.168.0.17/command-api'\", \"established=True\", \"is_online=True\", \"hw_model=cEOS-LAB\", ... \"InventoryDevice(host=IPv4Address('192.168.0.2')\", \"username='ansible'\", \"password='ansible'\", \"session=None\", \"url='https://ansible:ansible@192.168.0.2/command-api'\", \"established=False\" \"is_online=False\", \"tags\": ['dc1', 'spine', 'pod01'], \"hw_model=unset\", ] Raises: InventoryRootKeyErrors: Root key of inventory is missing. InventoryIncorrectSchema: Inventory file is not following AntaInventory Schema. InventoryUnknownFormat: Output format is not supported. \"\"\" # Root key of inventory part of the inventory file INVENTORY_ROOT_KEY = 'anta_inventory' # Template to build eAPI connection URL EAPI_SESSION_TPL = 'https://{{device_username}}:{{device_password}}@{{device}}/command-api' # Supported Output format INVENTORY_OUTPUT_FORMAT = [ 'native' , 'json' ] # HW model definition in show version HW_MODEL_KEY = 'modelName' # pylint: disable=R0913 def __init__ ( self , inventory_file : str , username : str , password : str , enable_password : str = None , auto_connect : bool = True , timeout : float = 5 ) -> None : # sourcery skip: remove-unnecessary-cast, simplify-len-comparison \"\"\"Class constructor. Args: inventory_file (str): Path to inventory YAML file where user has described his inputs username (str): Username to use to connect to devices password (str): Password to use to connect to devices auto_connect (bool, optional): Automatically build eAPI context for every devices. Defaults to True. timeout (float, optional): Timeout in second to wait before marking device down. Defaults to 5sec. \"\"\" self . set_credentials ( username , password , enable_password ) self . timeout = timeout self . _inventory = InventoryDevices () with open ( inventory_file , 'r' , encoding = 'utf8' ) as fd : data = yaml . load ( fd , Loader = SafeLoader ) # Load data using Pydantic try : self . _read_inventory = AntaInventoryInput ( ** data [ self . INVENTORY_ROOT_KEY ]) except KeyError as exc : logger . error ( f 'Inventory root key is missing: { self . INVENTORY_ROOT_KEY } ' ) raise InventoryRootKeyErrors ( f 'Inventory root key ( { self . INVENTORY_ROOT_KEY } ) is not defined in your inventory' ) from exc except ValidationError as exc : logger . error ( 'Inventory data are not compliant with inventory models' ) raise InventoryIncorrectSchema ( 'Inventory is not following schema' ) from exc # Read data from input if self . _read_inventory . dict ()[ 'hosts' ] is not None : self . _inventory_read_hosts () if self . _read_inventory . dict ()[ 'networks' ] is not None : self . _inventory_read_networks () if self . _read_inventory . dict ()[ 'ranges' ] is not None : self . _inventory_read_ranges () # Create RPC connection for all devices if auto_connect : self . connect_inventory () ########################################################################### # Boolean methods ########################################################################### def _is_ip_exist ( self , ip : str ) -> bool : \"\"\"Check if an IP is part of the current inventory. Args: ip (str): IP address to search in our inventory Returns: bool: True if device is in our inventory, False if not \"\"\" logger . debug ( f 'Checking if device { ip } is in our inventory' ) return len ([ str ( dev . host ) for dev in self . _inventory if str ( ip ) == str ( dev . host )]) == 1 def _is_device_online ( self , device : InventoryDevice , timeout : float = 5 ) -> bool : \"\"\" _is_device_online Check if device is online. Execute an eAPI call to check if device is online and has eAPI working as expected If device is ready to serve request, method returns True, else return False. Args: device (InventoryDevice): InventoryDevice structure to test timeout (float, optional): Request timeout. Defaults to 5. Returns: bool: True if device ready, False by default. \"\"\" logger . debug ( f 'Checking if device { device . host } is online' ) connection = Server ( device . url ) # Check connectivity setdefaulttimeout ( timeout ) try : connection . runCmds ( 1 , [ 'show version' ]) # pylint: disable=W0703 except Exception as exp : logger . warning ( f 'Service not running on device { device . host } with: f { exp } ' ) return False else : return True ########################################################################### # Internal methods ########################################################################### def _read_device_hw ( self , device : InventoryDevice , timeout : float = 5 ) -> Optional [ str ]: \"\"\" _read_device_hw Read HW model from the device and update entry with correct value. It returns HW model name from show version or None if device is not reachable or if it cannot find the modelName key Args: device (InventoryDevice): Device to update timeout (float, optional): Connection timeout. Defaults to 5. Returns: str: HW value read from the device using show version. \"\"\" logger . debug ( f 'Reading HW information for { device . host } ' ) connection = Server ( device . url ) try : setdefaulttimeout ( timeout ) response = connection . runCmds ( 1 , [ 'show version' ]) # pylint: disable=W0703 except Exception : logger . warning ( f 'Service not running on device { device . host } ' ) return None else : return response [ 0 ][ self . HW_MODEL_KEY ] if self . HW_MODEL_KEY in response [ 0 ] else None def _get_from_device ( self , device : InventoryDevice ) -> InventoryDevice : \"\"\" _get_from_device Update online flag for InventoryDevice. It updates following keys: - is_online - hw_model Args: device (InventoryDevice): Device to check using InventoryDevice structure. Returns: InventoryDevice: Updated structure with devices information (is_online, HW model) \"\"\" logger . debug ( f 'Refreshing is_online flag for device { device . host } ' ) device . is_online = self . _is_device_online ( device = device , timeout = self . timeout ) hw_model = self . _read_device_hw ( device = device , timeout = self . timeout ) if device . is_online and hw_model : device . hw_model = hw_model return device def _build_device_session_path ( self , host : str , username : str , password : str ) -> str : \"\"\"Construct URL to reach device using eAPI. Jinja2 render to build URL to use for eAPI session. Args: host (str): IP Address of the device to target in the eAPI session username (str): Username for authentication password (str): Password for authentication Returns: str: String to use to create eAPI session \"\"\" session_template = Template ( self . EAPI_SESSION_TPL ) return session_template . render ( device = host , device_username = username , device_password = password ) def _build_device_session ( self , device : InventoryDevice , timeout : float = 5 ) -> InventoryDevice : \"\"\"Create eAPI RPC session to Arista EOS devices. Args: device (InventoryDevice): Device information based on InventoryDevice structure timeout (int, optional): Device timeout to declare host as down. Defaults to 5. Returns: InventoryDevice: Updated device structure with its RPC connection \"\"\" connection = Server ( device . url ) # Check connectivity try : setdefaulttimeout ( timeout ) connection . runCmds ( 1 , [ 'show version' ]) # pylint: disable=W0703 except Exception : logger . warning ( f 'Service not running on device { device . host } ' ) device . session = None else : device . established = True device . session = connection return device def _add_device_to_inventory ( self , host_ip : str , tags : List [ str ] = None ) -> None : \"\"\"Add a InventoryDevice to final inventory. Create InventoryDevice and append to existing inventory Args: host_ip (str): IP address of the host \"\"\" assert self . _username is not None assert self . _password is not None if tags is None : tags = [ DEFAULT_TAG ] device = InventoryDevice ( host = host_ip , username = self . _username , password = self . _password , enable_password = self . _enable_password , url = self . _build_device_session_path ( host = host_ip , username = self . _username , password = self . _password ), tags = tags ) self . _inventory . append ( device ) def _inventory_read_hosts ( self ) -> None : \"\"\"Read input data from hosts section and create inventory structure. Build InventoryDevice structure for all hosts under hosts section \"\"\" assert self . _read_inventory . hosts is not None for host in self . _read_inventory . hosts : self . _add_device_to_inventory ( host_ip = str ( host . host ), tags = host . tags ) def _inventory_read_networks ( self ) -> None : \"\"\"Read input data from networks section and create inventory structure. Build InventoryDevice structure for all IPs available in each declared subnet \"\"\" assert self . _read_inventory . networks is not None for network in self . _read_inventory . networks : for host_ip in IPNetwork ( str ( network . network )): self . _add_device_to_inventory ( host_ip = host_ip , tags = network . tags ) def _inventory_read_ranges ( self ) -> None : \"\"\"Read input data from ranges section and create inventory structure. Build InventoryDevice structure for all IPs available in each declared range \"\"\" assert self . _read_inventory . ranges is not None for range_def in self . _read_inventory . ranges : range_increment = IPAddress ( str ( range_def . start )) range_stop = IPAddress ( str ( range_def . end )) while range_increment <= range_stop : self . _add_device_to_inventory ( host_ip = str ( range_increment ), tags = range_def . tags ) range_increment += 1 def _inventory_rebuild ( self , list_devices : Iterator [ Any ]) -> InventoryDevices : \"\"\" _inventory_rebuild Transform a list of InventoryDevice into a InventoryDevices object. Args: list_devices (List[InventoryDevice]): List of devices to add into InventoryDevices Returns: InventoryDevices: An object with all the devices. \"\"\" logger . debug ( 'Create a new version of InventoryDevices' ) inventory = InventoryDevices () for device in list_devices : inventory . append ( device ) return inventory def _filtered_inventory ( self , established_only : bool = False , tags : List [ str ] = None ) -> InventoryDevices : \"\"\" _filtered_inventory Generate a temporary inventory filtered. Args: established_only (bool, optional): Do we have to include non-established devices. Defaults to False. tags (List[str], optional): List of tags to use to filter devices. Default is [default]. Returns: InventoryDevices: A inventory with concerned devices \"\"\" if tags is None : tags = [ DEFAULT_TAG ] inventory_filtered_tags = InventoryDevices () for device in self . _inventory : if any ( tag in tags for tag in device . tags ): inventory_filtered_tags . append ( device ) if not established_only : return inventory_filtered_tags inventory_final = InventoryDevices () for device in inventory_filtered_tags : if device . established : inventory_final . append ( device ) return inventory_final ########################################################################### # Public methods ########################################################################### ########################################################################### # GET methods # TODO refactor this to avoid having a union of return of types .. def get_inventory ( self , format_out : str = 'native' , established_only : bool = True , tags : List [ str ] = None ) -> Union [ List [ InventoryDevice ], str , InventoryDevices ]: \"\"\"get_inventory Expose device inventory. Provides inventory has a list of InventoryDevice objects. If requried, it can be exposed in JSON format. Also, by default expose only active devices. Args: format (str, optional): Format output, can be native, list or JSON. Defaults to 'native'. established_only (bool, optional): Allow to expose also unreachable devices. Defaults to True. tags (List[str], optional): List of tags to use to filter devices. Default is [default]. Returns: InventoryDevices: List of InventoryDevice \"\"\" if tags is None : tags = [ DEFAULT_TAG ] if format_out not in [ 'native' , 'json' , 'list' ]: raise InventoryUnknownFormat ( f 'Unsupported inventory format: { format_out } . Only supported format are: { self . INVENTORY_OUTPUT_FORMAT } ' ) inventory = self . _filtered_inventory ( established_only , tags ) if format_out == 'list' : # pylint: disable=R1721 return [ dev for dev in inventory ] if format_out == 'json' : return inventory . json () return inventory def get_device ( self , host_ip : str ) -> Optional [ InventoryDevice ]: \"\"\"Get device information from a given IP. Args: host_ip (str): IP address of the device Returns: InventoryDevice: Device information \"\"\" if self . _is_ip_exist ( host_ip ): return [ dev for dev in self . _inventory if str ( dev . host ) == str ( host_ip )][ 0 ] return None def get_device_session ( self , host_ip : str ) -> Server : \"\"\"Expose RPC session of a given host from our inventory. Provide RPC session if the session exists, if not, it returns None Args: host_ip (str): IP address of the host to match Returns: jsonrpclib.Server: Instance to the device. None if session does not exist \"\"\" device = self . get_device ( host_ip = host_ip ) if device is None : return None return device . session ########################################################################### # CREATE methods def create_all_sessions ( self , refresh_online_first : bool = False ) -> None : \"\"\"Helper to build RPC sessions to all devices. Args: refresh_online_first (bool): Run a refresh of is_online flag for all devices. \"\"\" if refresh_online_first : logger . debug ( 'Running a refresh for devices online' ) self . refresh_device_facts () for device in self . _inventory : self . create_device_session ( host_ip = str ( device . host )) def create_device_session ( self , host_ip : str ) -> bool : \"\"\"Get session of a device. If device has already a session, function only returns active session, if not, try to build a new session Args: host_ip (str): IP address of the device Returns: bool: True if update succeed, False if not \"\"\" logger . debug ( f 'Searching for device { host_ip } in { self . _inventory } ' ) device = [ dev for dev in self . _inventory if str ( dev . host ) == host_ip ][: 1 ][ 0 ] or None if device is None : return False logger . debug ( f 'Search result is: { device } ' ) if device . is_online and not device . established and self . _is_ip_exist ( host_ip ): logger . debug ( f 'Trying to connect to device { str ( device . host ) } ' ) device = self . _build_device_session ( device = device , timeout = self . timeout ) return True return False ########################################################################### # MISC methods def set_credentials ( self , username : str = None , password : str = None , enable_password : str = None ) -> None : \"\"\" Set the credentials for the Inventory \"\"\" self . _username = username self . _password = password self . _enable_password = enable_password def connect_inventory ( self ) -> None : \"\"\"connect_inventory Helper to prepare inventory with network data.\"\"\" # Check if devices are online & update is_online flag self . refresh_device_facts () # Create eAPI session for all online devices self . create_all_sessions () def refresh_device_facts ( self ) -> None : \"\"\" refresh_online_flag_inventory Update is_online flag for all devices. Execute in parallel a call to _refresh_online_flag_device to test device connectivity. \"\"\" logger . debug ( 'Refreshing facts for current inventory' ) with ThreadPoolExecutor () as executor : results_map = executor . map ( self . _get_from_device , self . _inventory ) self . _inventory = self . _inventory_rebuild ( results_map ) __init__ ( inventory_file , username , password , enable_password = None , auto_connect = True , timeout = 5 ) \u00b6 Class constructor. Parameters: Name Type Description Default inventory_file str Path to inventory YAML file where user has described his inputs required username str Username to use to connect to devices required password str Password to use to connect to devices required auto_connect bool Automatically build eAPI context for every devices. Defaults to True. True timeout float Timeout in second to wait before marking device down. Defaults to 5sec. 5 Source code in anta/inventory/__init__.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def __init__ ( self , inventory_file : str , username : str , password : str , enable_password : str = None , auto_connect : bool = True , timeout : float = 5 ) -> None : # sourcery skip: remove-unnecessary-cast, simplify-len-comparison \"\"\"Class constructor. Args: inventory_file (str): Path to inventory YAML file where user has described his inputs username (str): Username to use to connect to devices password (str): Password to use to connect to devices auto_connect (bool, optional): Automatically build eAPI context for every devices. Defaults to True. timeout (float, optional): Timeout in second to wait before marking device down. Defaults to 5sec. \"\"\" self . set_credentials ( username , password , enable_password ) self . timeout = timeout self . _inventory = InventoryDevices () with open ( inventory_file , 'r' , encoding = 'utf8' ) as fd : data = yaml . load ( fd , Loader = SafeLoader ) # Load data using Pydantic try : self . _read_inventory = AntaInventoryInput ( ** data [ self . INVENTORY_ROOT_KEY ]) except KeyError as exc : logger . error ( f 'Inventory root key is missing: { self . INVENTORY_ROOT_KEY } ' ) raise InventoryRootKeyErrors ( f 'Inventory root key ( { self . INVENTORY_ROOT_KEY } ) is not defined in your inventory' ) from exc except ValidationError as exc : logger . error ( 'Inventory data are not compliant with inventory models' ) raise InventoryIncorrectSchema ( 'Inventory is not following schema' ) from exc # Read data from input if self . _read_inventory . dict ()[ 'hosts' ] is not None : self . _inventory_read_hosts () if self . _read_inventory . dict ()[ 'networks' ] is not None : self . _inventory_read_networks () if self . _read_inventory . dict ()[ 'ranges' ] is not None : self . _inventory_read_ranges () # Create RPC connection for all devices if auto_connect : self . connect_inventory () connect_inventory () \u00b6 connect_inventory Helper to prepare inventory with network data. Source code in anta/inventory/__init__.py 518 519 520 521 522 523 524 def connect_inventory ( self ) -> None : \"\"\"connect_inventory Helper to prepare inventory with network data.\"\"\" # Check if devices are online & update is_online flag self . refresh_device_facts () # Create eAPI session for all online devices self . create_all_sessions () create_all_sessions ( refresh_online_first = False ) \u00b6 Helper to build RPC sessions to all devices. Parameters: Name Type Description Default refresh_online_first bool Run a refresh of is_online flag for all devices. False Source code in anta/inventory/__init__.py 471 472 473 474 475 476 477 478 479 480 481 482 def create_all_sessions ( self , refresh_online_first : bool = False ) -> None : \"\"\"Helper to build RPC sessions to all devices. Args: refresh_online_first (bool): Run a refresh of is_online flag for all devices. \"\"\" if refresh_online_first : logger . debug ( 'Running a refresh for devices online' ) self . refresh_device_facts () for device in self . _inventory : self . create_device_session ( host_ip = str ( device . host )) create_device_session ( host_ip ) \u00b6 Get session of a device. If device has already a session, function only returns active session, if not, try to build a new session Parameters: Name Type Description Default host_ip str IP address of the device required Returns: Name Type Description bool bool True if update succeed, False if not Source code in anta/inventory/__init__.py 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 def create_device_session ( self , host_ip : str ) -> bool : \"\"\"Get session of a device. If device has already a session, function only returns active session, if not, try to build a new session Args: host_ip (str): IP address of the device Returns: bool: True if update succeed, False if not \"\"\" logger . debug ( f 'Searching for device { host_ip } in { self . _inventory } ' ) device = [ dev for dev in self . _inventory if str ( dev . host ) == host_ip ][: 1 ][ 0 ] or None if device is None : return False logger . debug ( f 'Search result is: { device } ' ) if device . is_online and not device . established and self . _is_ip_exist ( host_ip ): logger . debug ( f 'Trying to connect to device { str ( device . host ) } ' ) device = self . _build_device_session ( device = device , timeout = self . timeout ) return True return False get_device ( host_ip ) \u00b6 Get device information from a given IP. Parameters: Name Type Description Default host_ip str IP address of the device required Returns: Name Type Description InventoryDevice Optional [ InventoryDevice ] Device information Source code in anta/inventory/__init__.py 439 440 441 442 443 444 445 446 447 448 449 450 def get_device ( self , host_ip : str ) -> Optional [ InventoryDevice ]: \"\"\"Get device information from a given IP. Args: host_ip (str): IP address of the device Returns: InventoryDevice: Device information \"\"\" if self . _is_ip_exist ( host_ip ): return [ dev for dev in self . _inventory if str ( dev . host ) == str ( host_ip )][ 0 ] return None get_device_session ( host_ip ) \u00b6 Expose RPC session of a given host from our inventory. Provide RPC session if the session exists, if not, it returns None Parameters: Name Type Description Default host_ip str IP address of the host to match required Returns: Type Description Server jsonrpclib.Server: Instance to the device. None if session does not exist Source code in anta/inventory/__init__.py 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 def get_device_session ( self , host_ip : str ) -> Server : \"\"\"Expose RPC session of a given host from our inventory. Provide RPC session if the session exists, if not, it returns None Args: host_ip (str): IP address of the host to match Returns: jsonrpclib.Server: Instance to the device. None if session does not exist \"\"\" device = self . get_device ( host_ip = host_ip ) if device is None : return None return device . session get_inventory ( format_out = 'native' , established_only = True , tags = None ) \u00b6 get_inventory Expose device inventory. Provides inventory has a list of InventoryDevice objects. If requried, it can be exposed in JSON format. Also, by default expose only active devices. Parameters: Name Type Description Default format str Format output, can be native, list or JSON. Defaults to \u2018native\u2019. required established_only bool Allow to expose also unreachable devices. Defaults to True. True tags List [ str ] List of tags to use to filter devices. Default is [default]. None Returns: Name Type Description InventoryDevices Union [ List [ InventoryDevice ], str , InventoryDevices ] List of InventoryDevice Source code in anta/inventory/__init__.py 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 def get_inventory ( self , format_out : str = 'native' , established_only : bool = True , tags : List [ str ] = None ) -> Union [ List [ InventoryDevice ], str , InventoryDevices ]: \"\"\"get_inventory Expose device inventory. Provides inventory has a list of InventoryDevice objects. If requried, it can be exposed in JSON format. Also, by default expose only active devices. Args: format (str, optional): Format output, can be native, list or JSON. Defaults to 'native'. established_only (bool, optional): Allow to expose also unreachable devices. Defaults to True. tags (List[str], optional): List of tags to use to filter devices. Default is [default]. Returns: InventoryDevices: List of InventoryDevice \"\"\" if tags is None : tags = [ DEFAULT_TAG ] if format_out not in [ 'native' , 'json' , 'list' ]: raise InventoryUnknownFormat ( f 'Unsupported inventory format: { format_out } . Only supported format are: { self . INVENTORY_OUTPUT_FORMAT } ' ) inventory = self . _filtered_inventory ( established_only , tags ) if format_out == 'list' : # pylint: disable=R1721 return [ dev for dev in inventory ] if format_out == 'json' : return inventory . json () return inventory refresh_device_facts () \u00b6 refresh_online_flag_inventory Update is_online flag for all devices. Execute in parallel a call to _refresh_online_flag_device to test device connectivity. Source code in anta/inventory/__init__.py 526 527 528 529 530 531 532 533 534 535 536 def refresh_device_facts ( self ) -> None : \"\"\" refresh_online_flag_inventory Update is_online flag for all devices. Execute in parallel a call to _refresh_online_flag_device to test device connectivity. \"\"\" logger . debug ( 'Refreshing facts for current inventory' ) with ThreadPoolExecutor () as executor : results_map = executor . map ( self . _get_from_device , self . _inventory ) self . _inventory = self . _inventory_rebuild ( results_map ) set_credentials ( username = None , password = None , enable_password = None ) \u00b6 Set the credentials for the Inventory Source code in anta/inventory/__init__.py 510 511 512 513 514 515 516 def set_credentials ( self , username : str = None , password : str = None , enable_password : str = None ) -> None : \"\"\" Set the credentials for the Inventory \"\"\" self . _username = username self . _password = password self . _enable_password = enable_password Exceptions \u00b6 Manage Exception in Inventory module. InventoryIncorrectSchema \u00b6 Bases: Exception Error when user data does not follow ANTA schema. Source code in anta/inventory/exceptions.py 11 12 class InventoryIncorrectSchema ( Exception ): \"\"\"Error when user data does not follow ANTA schema.\"\"\" InventoryRootKeyErrors \u00b6 Bases: Exception Error raised when inventory root key is not found. Source code in anta/inventory/exceptions.py 7 8 class InventoryRootKeyErrors ( Exception ): \"\"\"Error raised when inventory root key is not found.\"\"\" InventoryUnknownFormat \u00b6 Bases: Exception Error when inventory format output is not a supported one. Source code in anta/inventory/exceptions.py 15 16 class InventoryUnknownFormat ( Exception ): \"\"\"Error when inventory format output is not a supported one.\"\"\"","title":"Inventory module"},{"location":"api/inventory/#anta-inventory-module","text":"Inventory Abstraction for ANTA framework. Attributes: Name Type Description timeout float Connection to device timeout. INVENTORY_ROOT_KEY str , Optional head of the YAML inventory. Default is anta_inventory EAPI_SESSION_TPL str , Optional Template for eAPI URL builder INVENTORY_OUTPUT_FORMAT List [ str ], Optional List of supported output format. Default [\u2018native\u2019, \u2018json\u2019] HW_MODEL_KEY str , Optional Name of the key in Arista eAPI JSON provided by device. Examples: Inventory file input print ( inventory . yml ) anta_inventory : hosts : - hosts : 1 . 1 . 1 . 1 - host : 2 . 2 . 2 . 2 tags : [ 'dc1' , 'spine' , 'pod01' ] networks : - network : 10 . 0 . 0 . 0 / 8 - network : 192 . 168 . 0 . 0 / 16 tags : [ 'dc1' , 'spine' , 'pod01' ] ranges : - start : 10 . 0 . 0 . 1 end : 10 . 0 . 0 . 11 tags : [ 'dc1' , 'spine' , 'pod01' ] Inventory result: test = AntaInventory ( ... inventory_file = ' examples / inventory . yml ' , ... username = ' ansible ' , ... password = ' ansible ' , ... auto_connect = True ) test . get_inventory () [ \"InventoryDevice(host=IPv4Address('192.168.0.17')\" , \"username='ansible'\" , \"password='ansible'\" , \"session=<ServerProxy for ansible:ansible@192.168.0.17/command-api>\" , \"url='https://ansible:ansible@192.168.0.17/command-api'\" , \"established=True\" , \"is_online=True\" , \"hw_model=cEOS-LAB\" , ... \"InventoryDevice(host=IPv4Address('192.168.0.2')\" , \"username='ansible'\" , \"password='ansible'\" , \"session=None\" , \"url='https://ansible:ansible@192.168.0.2/command-api'\" , \"established=False\" \"is_online=False\" , \"tags\" : [ ' dc1 ' , ' spine ' , ' pod01 ' ], \"hw_model=unset\" , ] Raises: Type Description InventoryRootKeyErrors Root key of inventory is missing. InventoryIncorrectSchema Inventory file is not following AntaInventory Schema. InventoryUnknownFormat Output format is not supported. Source code in anta/inventory/__init__.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 class AntaInventory (): \"\"\" Inventory Abstraction for ANTA framework. Attributes: timeout (float): Connection to device timeout. INVENTORY_ROOT_KEY (str, Optional): head of the YAML inventory. Default is anta_inventory EAPI_SESSION_TPL (str, Optional): Template for eAPI URL builder INVENTORY_OUTPUT_FORMAT (List[str],Optional): List of supported output format. Default ['native', 'json'] HW_MODEL_KEY (str,Optional): Name of the key in Arista eAPI JSON provided by device. Examples: Inventory file input print(inventory.yml) anta_inventory: hosts: - hosts: 1.1.1.1 - host: 2.2.2.2 tags: ['dc1', 'spine', 'pod01'] networks: - network: 10.0.0.0/8 - network: 192.168.0.0/16 tags: ['dc1', 'spine', 'pod01'] ranges: - start: 10.0.0.1 end: 10.0.0.11 tags: ['dc1', 'spine', 'pod01'] Inventory result: test = AntaInventory( ... inventory_file='examples/inventory.yml', ... username='ansible', ... password='ansible', ... auto_connect=True) test.get_inventory() [ \"InventoryDevice(host=IPv4Address('192.168.0.17')\", \"username='ansible'\", \"password='ansible'\", \"session=<ServerProxy for ansible:ansible@192.168.0.17/command-api>\", \"url='https://ansible:ansible@192.168.0.17/command-api'\", \"established=True\", \"is_online=True\", \"hw_model=cEOS-LAB\", ... \"InventoryDevice(host=IPv4Address('192.168.0.2')\", \"username='ansible'\", \"password='ansible'\", \"session=None\", \"url='https://ansible:ansible@192.168.0.2/command-api'\", \"established=False\" \"is_online=False\", \"tags\": ['dc1', 'spine', 'pod01'], \"hw_model=unset\", ] Raises: InventoryRootKeyErrors: Root key of inventory is missing. InventoryIncorrectSchema: Inventory file is not following AntaInventory Schema. InventoryUnknownFormat: Output format is not supported. \"\"\" # Root key of inventory part of the inventory file INVENTORY_ROOT_KEY = 'anta_inventory' # Template to build eAPI connection URL EAPI_SESSION_TPL = 'https://{{device_username}}:{{device_password}}@{{device}}/command-api' # Supported Output format INVENTORY_OUTPUT_FORMAT = [ 'native' , 'json' ] # HW model definition in show version HW_MODEL_KEY = 'modelName' # pylint: disable=R0913 def __init__ ( self , inventory_file : str , username : str , password : str , enable_password : str = None , auto_connect : bool = True , timeout : float = 5 ) -> None : # sourcery skip: remove-unnecessary-cast, simplify-len-comparison \"\"\"Class constructor. Args: inventory_file (str): Path to inventory YAML file where user has described his inputs username (str): Username to use to connect to devices password (str): Password to use to connect to devices auto_connect (bool, optional): Automatically build eAPI context for every devices. Defaults to True. timeout (float, optional): Timeout in second to wait before marking device down. Defaults to 5sec. \"\"\" self . set_credentials ( username , password , enable_password ) self . timeout = timeout self . _inventory = InventoryDevices () with open ( inventory_file , 'r' , encoding = 'utf8' ) as fd : data = yaml . load ( fd , Loader = SafeLoader ) # Load data using Pydantic try : self . _read_inventory = AntaInventoryInput ( ** data [ self . INVENTORY_ROOT_KEY ]) except KeyError as exc : logger . error ( f 'Inventory root key is missing: { self . INVENTORY_ROOT_KEY } ' ) raise InventoryRootKeyErrors ( f 'Inventory root key ( { self . INVENTORY_ROOT_KEY } ) is not defined in your inventory' ) from exc except ValidationError as exc : logger . error ( 'Inventory data are not compliant with inventory models' ) raise InventoryIncorrectSchema ( 'Inventory is not following schema' ) from exc # Read data from input if self . _read_inventory . dict ()[ 'hosts' ] is not None : self . _inventory_read_hosts () if self . _read_inventory . dict ()[ 'networks' ] is not None : self . _inventory_read_networks () if self . _read_inventory . dict ()[ 'ranges' ] is not None : self . _inventory_read_ranges () # Create RPC connection for all devices if auto_connect : self . connect_inventory () ########################################################################### # Boolean methods ########################################################################### def _is_ip_exist ( self , ip : str ) -> bool : \"\"\"Check if an IP is part of the current inventory. Args: ip (str): IP address to search in our inventory Returns: bool: True if device is in our inventory, False if not \"\"\" logger . debug ( f 'Checking if device { ip } is in our inventory' ) return len ([ str ( dev . host ) for dev in self . _inventory if str ( ip ) == str ( dev . host )]) == 1 def _is_device_online ( self , device : InventoryDevice , timeout : float = 5 ) -> bool : \"\"\" _is_device_online Check if device is online. Execute an eAPI call to check if device is online and has eAPI working as expected If device is ready to serve request, method returns True, else return False. Args: device (InventoryDevice): InventoryDevice structure to test timeout (float, optional): Request timeout. Defaults to 5. Returns: bool: True if device ready, False by default. \"\"\" logger . debug ( f 'Checking if device { device . host } is online' ) connection = Server ( device . url ) # Check connectivity setdefaulttimeout ( timeout ) try : connection . runCmds ( 1 , [ 'show version' ]) # pylint: disable=W0703 except Exception as exp : logger . warning ( f 'Service not running on device { device . host } with: f { exp } ' ) return False else : return True ########################################################################### # Internal methods ########################################################################### def _read_device_hw ( self , device : InventoryDevice , timeout : float = 5 ) -> Optional [ str ]: \"\"\" _read_device_hw Read HW model from the device and update entry with correct value. It returns HW model name from show version or None if device is not reachable or if it cannot find the modelName key Args: device (InventoryDevice): Device to update timeout (float, optional): Connection timeout. Defaults to 5. Returns: str: HW value read from the device using show version. \"\"\" logger . debug ( f 'Reading HW information for { device . host } ' ) connection = Server ( device . url ) try : setdefaulttimeout ( timeout ) response = connection . runCmds ( 1 , [ 'show version' ]) # pylint: disable=W0703 except Exception : logger . warning ( f 'Service not running on device { device . host } ' ) return None else : return response [ 0 ][ self . HW_MODEL_KEY ] if self . HW_MODEL_KEY in response [ 0 ] else None def _get_from_device ( self , device : InventoryDevice ) -> InventoryDevice : \"\"\" _get_from_device Update online flag for InventoryDevice. It updates following keys: - is_online - hw_model Args: device (InventoryDevice): Device to check using InventoryDevice structure. Returns: InventoryDevice: Updated structure with devices information (is_online, HW model) \"\"\" logger . debug ( f 'Refreshing is_online flag for device { device . host } ' ) device . is_online = self . _is_device_online ( device = device , timeout = self . timeout ) hw_model = self . _read_device_hw ( device = device , timeout = self . timeout ) if device . is_online and hw_model : device . hw_model = hw_model return device def _build_device_session_path ( self , host : str , username : str , password : str ) -> str : \"\"\"Construct URL to reach device using eAPI. Jinja2 render to build URL to use for eAPI session. Args: host (str): IP Address of the device to target in the eAPI session username (str): Username for authentication password (str): Password for authentication Returns: str: String to use to create eAPI session \"\"\" session_template = Template ( self . EAPI_SESSION_TPL ) return session_template . render ( device = host , device_username = username , device_password = password ) def _build_device_session ( self , device : InventoryDevice , timeout : float = 5 ) -> InventoryDevice : \"\"\"Create eAPI RPC session to Arista EOS devices. Args: device (InventoryDevice): Device information based on InventoryDevice structure timeout (int, optional): Device timeout to declare host as down. Defaults to 5. Returns: InventoryDevice: Updated device structure with its RPC connection \"\"\" connection = Server ( device . url ) # Check connectivity try : setdefaulttimeout ( timeout ) connection . runCmds ( 1 , [ 'show version' ]) # pylint: disable=W0703 except Exception : logger . warning ( f 'Service not running on device { device . host } ' ) device . session = None else : device . established = True device . session = connection return device def _add_device_to_inventory ( self , host_ip : str , tags : List [ str ] = None ) -> None : \"\"\"Add a InventoryDevice to final inventory. Create InventoryDevice and append to existing inventory Args: host_ip (str): IP address of the host \"\"\" assert self . _username is not None assert self . _password is not None if tags is None : tags = [ DEFAULT_TAG ] device = InventoryDevice ( host = host_ip , username = self . _username , password = self . _password , enable_password = self . _enable_password , url = self . _build_device_session_path ( host = host_ip , username = self . _username , password = self . _password ), tags = tags ) self . _inventory . append ( device ) def _inventory_read_hosts ( self ) -> None : \"\"\"Read input data from hosts section and create inventory structure. Build InventoryDevice structure for all hosts under hosts section \"\"\" assert self . _read_inventory . hosts is not None for host in self . _read_inventory . hosts : self . _add_device_to_inventory ( host_ip = str ( host . host ), tags = host . tags ) def _inventory_read_networks ( self ) -> None : \"\"\"Read input data from networks section and create inventory structure. Build InventoryDevice structure for all IPs available in each declared subnet \"\"\" assert self . _read_inventory . networks is not None for network in self . _read_inventory . networks : for host_ip in IPNetwork ( str ( network . network )): self . _add_device_to_inventory ( host_ip = host_ip , tags = network . tags ) def _inventory_read_ranges ( self ) -> None : \"\"\"Read input data from ranges section and create inventory structure. Build InventoryDevice structure for all IPs available in each declared range \"\"\" assert self . _read_inventory . ranges is not None for range_def in self . _read_inventory . ranges : range_increment = IPAddress ( str ( range_def . start )) range_stop = IPAddress ( str ( range_def . end )) while range_increment <= range_stop : self . _add_device_to_inventory ( host_ip = str ( range_increment ), tags = range_def . tags ) range_increment += 1 def _inventory_rebuild ( self , list_devices : Iterator [ Any ]) -> InventoryDevices : \"\"\" _inventory_rebuild Transform a list of InventoryDevice into a InventoryDevices object. Args: list_devices (List[InventoryDevice]): List of devices to add into InventoryDevices Returns: InventoryDevices: An object with all the devices. \"\"\" logger . debug ( 'Create a new version of InventoryDevices' ) inventory = InventoryDevices () for device in list_devices : inventory . append ( device ) return inventory def _filtered_inventory ( self , established_only : bool = False , tags : List [ str ] = None ) -> InventoryDevices : \"\"\" _filtered_inventory Generate a temporary inventory filtered. Args: established_only (bool, optional): Do we have to include non-established devices. Defaults to False. tags (List[str], optional): List of tags to use to filter devices. Default is [default]. Returns: InventoryDevices: A inventory with concerned devices \"\"\" if tags is None : tags = [ DEFAULT_TAG ] inventory_filtered_tags = InventoryDevices () for device in self . _inventory : if any ( tag in tags for tag in device . tags ): inventory_filtered_tags . append ( device ) if not established_only : return inventory_filtered_tags inventory_final = InventoryDevices () for device in inventory_filtered_tags : if device . established : inventory_final . append ( device ) return inventory_final ########################################################################### # Public methods ########################################################################### ########################################################################### # GET methods # TODO refactor this to avoid having a union of return of types .. def get_inventory ( self , format_out : str = 'native' , established_only : bool = True , tags : List [ str ] = None ) -> Union [ List [ InventoryDevice ], str , InventoryDevices ]: \"\"\"get_inventory Expose device inventory. Provides inventory has a list of InventoryDevice objects. If requried, it can be exposed in JSON format. Also, by default expose only active devices. Args: format (str, optional): Format output, can be native, list or JSON. Defaults to 'native'. established_only (bool, optional): Allow to expose also unreachable devices. Defaults to True. tags (List[str], optional): List of tags to use to filter devices. Default is [default]. Returns: InventoryDevices: List of InventoryDevice \"\"\" if tags is None : tags = [ DEFAULT_TAG ] if format_out not in [ 'native' , 'json' , 'list' ]: raise InventoryUnknownFormat ( f 'Unsupported inventory format: { format_out } . Only supported format are: { self . INVENTORY_OUTPUT_FORMAT } ' ) inventory = self . _filtered_inventory ( established_only , tags ) if format_out == 'list' : # pylint: disable=R1721 return [ dev for dev in inventory ] if format_out == 'json' : return inventory . json () return inventory def get_device ( self , host_ip : str ) -> Optional [ InventoryDevice ]: \"\"\"Get device information from a given IP. Args: host_ip (str): IP address of the device Returns: InventoryDevice: Device information \"\"\" if self . _is_ip_exist ( host_ip ): return [ dev for dev in self . _inventory if str ( dev . host ) == str ( host_ip )][ 0 ] return None def get_device_session ( self , host_ip : str ) -> Server : \"\"\"Expose RPC session of a given host from our inventory. Provide RPC session if the session exists, if not, it returns None Args: host_ip (str): IP address of the host to match Returns: jsonrpclib.Server: Instance to the device. None if session does not exist \"\"\" device = self . get_device ( host_ip = host_ip ) if device is None : return None return device . session ########################################################################### # CREATE methods def create_all_sessions ( self , refresh_online_first : bool = False ) -> None : \"\"\"Helper to build RPC sessions to all devices. Args: refresh_online_first (bool): Run a refresh of is_online flag for all devices. \"\"\" if refresh_online_first : logger . debug ( 'Running a refresh for devices online' ) self . refresh_device_facts () for device in self . _inventory : self . create_device_session ( host_ip = str ( device . host )) def create_device_session ( self , host_ip : str ) -> bool : \"\"\"Get session of a device. If device has already a session, function only returns active session, if not, try to build a new session Args: host_ip (str): IP address of the device Returns: bool: True if update succeed, False if not \"\"\" logger . debug ( f 'Searching for device { host_ip } in { self . _inventory } ' ) device = [ dev for dev in self . _inventory if str ( dev . host ) == host_ip ][: 1 ][ 0 ] or None if device is None : return False logger . debug ( f 'Search result is: { device } ' ) if device . is_online and not device . established and self . _is_ip_exist ( host_ip ): logger . debug ( f 'Trying to connect to device { str ( device . host ) } ' ) device = self . _build_device_session ( device = device , timeout = self . timeout ) return True return False ########################################################################### # MISC methods def set_credentials ( self , username : str = None , password : str = None , enable_password : str = None ) -> None : \"\"\" Set the credentials for the Inventory \"\"\" self . _username = username self . _password = password self . _enable_password = enable_password def connect_inventory ( self ) -> None : \"\"\"connect_inventory Helper to prepare inventory with network data.\"\"\" # Check if devices are online & update is_online flag self . refresh_device_facts () # Create eAPI session for all online devices self . create_all_sessions () def refresh_device_facts ( self ) -> None : \"\"\" refresh_online_flag_inventory Update is_online flag for all devices. Execute in parallel a call to _refresh_online_flag_device to test device connectivity. \"\"\" logger . debug ( 'Refreshing facts for current inventory' ) with ThreadPoolExecutor () as executor : results_map = executor . map ( self . _get_from_device , self . _inventory ) self . _inventory = self . _inventory_rebuild ( results_map )","title":"ANTA Inventory module"},{"location":"api/inventory/#anta.inventory.AntaInventory.__init__","text":"Class constructor. Parameters: Name Type Description Default inventory_file str Path to inventory YAML file where user has described his inputs required username str Username to use to connect to devices required password str Password to use to connect to devices required auto_connect bool Automatically build eAPI context for every devices. Defaults to True. True timeout float Timeout in second to wait before marking device down. Defaults to 5sec. 5 Source code in anta/inventory/__init__.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def __init__ ( self , inventory_file : str , username : str , password : str , enable_password : str = None , auto_connect : bool = True , timeout : float = 5 ) -> None : # sourcery skip: remove-unnecessary-cast, simplify-len-comparison \"\"\"Class constructor. Args: inventory_file (str): Path to inventory YAML file where user has described his inputs username (str): Username to use to connect to devices password (str): Password to use to connect to devices auto_connect (bool, optional): Automatically build eAPI context for every devices. Defaults to True. timeout (float, optional): Timeout in second to wait before marking device down. Defaults to 5sec. \"\"\" self . set_credentials ( username , password , enable_password ) self . timeout = timeout self . _inventory = InventoryDevices () with open ( inventory_file , 'r' , encoding = 'utf8' ) as fd : data = yaml . load ( fd , Loader = SafeLoader ) # Load data using Pydantic try : self . _read_inventory = AntaInventoryInput ( ** data [ self . INVENTORY_ROOT_KEY ]) except KeyError as exc : logger . error ( f 'Inventory root key is missing: { self . INVENTORY_ROOT_KEY } ' ) raise InventoryRootKeyErrors ( f 'Inventory root key ( { self . INVENTORY_ROOT_KEY } ) is not defined in your inventory' ) from exc except ValidationError as exc : logger . error ( 'Inventory data are not compliant with inventory models' ) raise InventoryIncorrectSchema ( 'Inventory is not following schema' ) from exc # Read data from input if self . _read_inventory . dict ()[ 'hosts' ] is not None : self . _inventory_read_hosts () if self . _read_inventory . dict ()[ 'networks' ] is not None : self . _inventory_read_networks () if self . _read_inventory . dict ()[ 'ranges' ] is not None : self . _inventory_read_ranges () # Create RPC connection for all devices if auto_connect : self . connect_inventory ()","title":"__init__()"},{"location":"api/inventory/#anta.inventory.AntaInventory.connect_inventory","text":"connect_inventory Helper to prepare inventory with network data. Source code in anta/inventory/__init__.py 518 519 520 521 522 523 524 def connect_inventory ( self ) -> None : \"\"\"connect_inventory Helper to prepare inventory with network data.\"\"\" # Check if devices are online & update is_online flag self . refresh_device_facts () # Create eAPI session for all online devices self . create_all_sessions ()","title":"connect_inventory()"},{"location":"api/inventory/#anta.inventory.AntaInventory.create_all_sessions","text":"Helper to build RPC sessions to all devices. Parameters: Name Type Description Default refresh_online_first bool Run a refresh of is_online flag for all devices. False Source code in anta/inventory/__init__.py 471 472 473 474 475 476 477 478 479 480 481 482 def create_all_sessions ( self , refresh_online_first : bool = False ) -> None : \"\"\"Helper to build RPC sessions to all devices. Args: refresh_online_first (bool): Run a refresh of is_online flag for all devices. \"\"\" if refresh_online_first : logger . debug ( 'Running a refresh for devices online' ) self . refresh_device_facts () for device in self . _inventory : self . create_device_session ( host_ip = str ( device . host ))","title":"create_all_sessions()"},{"location":"api/inventory/#anta.inventory.AntaInventory.create_device_session","text":"Get session of a device. If device has already a session, function only returns active session, if not, try to build a new session Parameters: Name Type Description Default host_ip str IP address of the device required Returns: Name Type Description bool bool True if update succeed, False if not Source code in anta/inventory/__init__.py 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 def create_device_session ( self , host_ip : str ) -> bool : \"\"\"Get session of a device. If device has already a session, function only returns active session, if not, try to build a new session Args: host_ip (str): IP address of the device Returns: bool: True if update succeed, False if not \"\"\" logger . debug ( f 'Searching for device { host_ip } in { self . _inventory } ' ) device = [ dev for dev in self . _inventory if str ( dev . host ) == host_ip ][: 1 ][ 0 ] or None if device is None : return False logger . debug ( f 'Search result is: { device } ' ) if device . is_online and not device . established and self . _is_ip_exist ( host_ip ): logger . debug ( f 'Trying to connect to device { str ( device . host ) } ' ) device = self . _build_device_session ( device = device , timeout = self . timeout ) return True return False","title":"create_device_session()"},{"location":"api/inventory/#anta.inventory.AntaInventory.get_device","text":"Get device information from a given IP. Parameters: Name Type Description Default host_ip str IP address of the device required Returns: Name Type Description InventoryDevice Optional [ InventoryDevice ] Device information Source code in anta/inventory/__init__.py 439 440 441 442 443 444 445 446 447 448 449 450 def get_device ( self , host_ip : str ) -> Optional [ InventoryDevice ]: \"\"\"Get device information from a given IP. Args: host_ip (str): IP address of the device Returns: InventoryDevice: Device information \"\"\" if self . _is_ip_exist ( host_ip ): return [ dev for dev in self . _inventory if str ( dev . host ) == str ( host_ip )][ 0 ] return None","title":"get_device()"},{"location":"api/inventory/#anta.inventory.AntaInventory.get_device_session","text":"Expose RPC session of a given host from our inventory. Provide RPC session if the session exists, if not, it returns None Parameters: Name Type Description Default host_ip str IP address of the host to match required Returns: Type Description Server jsonrpclib.Server: Instance to the device. None if session does not exist Source code in anta/inventory/__init__.py 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 def get_device_session ( self , host_ip : str ) -> Server : \"\"\"Expose RPC session of a given host from our inventory. Provide RPC session if the session exists, if not, it returns None Args: host_ip (str): IP address of the host to match Returns: jsonrpclib.Server: Instance to the device. None if session does not exist \"\"\" device = self . get_device ( host_ip = host_ip ) if device is None : return None return device . session","title":"get_device_session()"},{"location":"api/inventory/#anta.inventory.AntaInventory.get_inventory","text":"get_inventory Expose device inventory. Provides inventory has a list of InventoryDevice objects. If requried, it can be exposed in JSON format. Also, by default expose only active devices. Parameters: Name Type Description Default format str Format output, can be native, list or JSON. Defaults to \u2018native\u2019. required established_only bool Allow to expose also unreachable devices. Defaults to True. True tags List [ str ] List of tags to use to filter devices. Default is [default]. None Returns: Name Type Description InventoryDevices Union [ List [ InventoryDevice ], str , InventoryDevices ] List of InventoryDevice Source code in anta/inventory/__init__.py 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 def get_inventory ( self , format_out : str = 'native' , established_only : bool = True , tags : List [ str ] = None ) -> Union [ List [ InventoryDevice ], str , InventoryDevices ]: \"\"\"get_inventory Expose device inventory. Provides inventory has a list of InventoryDevice objects. If requried, it can be exposed in JSON format. Also, by default expose only active devices. Args: format (str, optional): Format output, can be native, list or JSON. Defaults to 'native'. established_only (bool, optional): Allow to expose also unreachable devices. Defaults to True. tags (List[str], optional): List of tags to use to filter devices. Default is [default]. Returns: InventoryDevices: List of InventoryDevice \"\"\" if tags is None : tags = [ DEFAULT_TAG ] if format_out not in [ 'native' , 'json' , 'list' ]: raise InventoryUnknownFormat ( f 'Unsupported inventory format: { format_out } . Only supported format are: { self . INVENTORY_OUTPUT_FORMAT } ' ) inventory = self . _filtered_inventory ( established_only , tags ) if format_out == 'list' : # pylint: disable=R1721 return [ dev for dev in inventory ] if format_out == 'json' : return inventory . json () return inventory","title":"get_inventory()"},{"location":"api/inventory/#anta.inventory.AntaInventory.refresh_device_facts","text":"refresh_online_flag_inventory Update is_online flag for all devices. Execute in parallel a call to _refresh_online_flag_device to test device connectivity. Source code in anta/inventory/__init__.py 526 527 528 529 530 531 532 533 534 535 536 def refresh_device_facts ( self ) -> None : \"\"\" refresh_online_flag_inventory Update is_online flag for all devices. Execute in parallel a call to _refresh_online_flag_device to test device connectivity. \"\"\" logger . debug ( 'Refreshing facts for current inventory' ) with ThreadPoolExecutor () as executor : results_map = executor . map ( self . _get_from_device , self . _inventory ) self . _inventory = self . _inventory_rebuild ( results_map )","title":"refresh_device_facts()"},{"location":"api/inventory/#anta.inventory.AntaInventory.set_credentials","text":"Set the credentials for the Inventory Source code in anta/inventory/__init__.py 510 511 512 513 514 515 516 def set_credentials ( self , username : str = None , password : str = None , enable_password : str = None ) -> None : \"\"\" Set the credentials for the Inventory \"\"\" self . _username = username self . _password = password self . _enable_password = enable_password","title":"set_credentials()"},{"location":"api/inventory/#exceptions","text":"Manage Exception in Inventory module.","title":"Exceptions"},{"location":"api/inventory/#anta.inventory.exceptions.InventoryIncorrectSchema","text":"Bases: Exception Error when user data does not follow ANTA schema. Source code in anta/inventory/exceptions.py 11 12 class InventoryIncorrectSchema ( Exception ): \"\"\"Error when user data does not follow ANTA schema.\"\"\"","title":"InventoryIncorrectSchema"},{"location":"api/inventory/#anta.inventory.exceptions.InventoryRootKeyErrors","text":"Bases: Exception Error raised when inventory root key is not found. Source code in anta/inventory/exceptions.py 7 8 class InventoryRootKeyErrors ( Exception ): \"\"\"Error raised when inventory root key is not found.\"\"\"","title":"InventoryRootKeyErrors"},{"location":"api/inventory/#anta.inventory.exceptions.InventoryUnknownFormat","text":"Bases: Exception Error when inventory format output is not a supported one. Source code in anta/inventory/exceptions.py 15 16 class InventoryUnknownFormat ( Exception ): \"\"\"Error when inventory format output is not a supported one.\"\"\"","title":"InventoryUnknownFormat"},{"location":"api/inventory.models.input/","text":"Data models for anta.inventory \u00b6 Bases: BaseModel User\u2019s inventory model. Attributes: Name Type Description networks List [ AntaInventoryNetwork ], Optional List of AntaInventoryNetwork objects for networks. hosts List [ AntaInventoryHost ], Optional List of AntaInventoryHost objects for hosts. range List [ AntaInventoryRange ], Optional List of AntaInventoryRange objects for ranges. Source code in anta/inventory/models.py 59 60 61 62 63 64 65 66 67 68 69 70 71 class AntaInventoryInput ( BaseModel ): \"\"\" User's inventory model. Attributes: networks (List[AntaInventoryNetwork],Optional): List of AntaInventoryNetwork objects for networks. hosts (List[AntaInventoryHost],Optional): List of AntaInventoryHost objects for hosts. range (List[AntaInventoryRange],Optional): List of AntaInventoryRange objects for ranges. \"\"\" networks : Optional [ List [ AntaInventoryNetwork ]] hosts : Optional [ List [ AntaInventoryHost ]] ranges : Optional [ List [ AntaInventoryRange ]] User inventory components \u00b6 Bases: BaseModel Host definition for user\u2019s inventory. Attributes: Name Type Description host IPvAnyAddress IPv4 or IPv6 address of the device tags List [ str ] List of attached tags read from inventory file. Source code in anta/inventory/models.py 18 19 20 21 22 23 24 25 26 27 28 class AntaInventoryHost ( BaseModel ): \"\"\" Host definition for user's inventory. Attributes: host (IPvAnyAddress): IPv4 or IPv6 address of the device tags (List[str]): List of attached tags read from inventory file. \"\"\" host : IPvAnyAddress tags : List [ str ] = [ DEFAULT_TAG ] Bases: BaseModel Network definition for user\u2019s inventory. Attributes: Name Type Description network IPvAnyNetwork Subnet to use for testing. tags List [ str ] List of attached tags read from inventory file. Source code in anta/inventory/models.py 31 32 33 34 35 36 37 38 39 40 41 class AntaInventoryNetwork ( BaseModel ): \"\"\" Network definition for user's inventory. Attributes: network (IPvAnyNetwork): Subnet to use for testing. tags (List[str]): List of attached tags read from inventory file. \"\"\" network : IPvAnyNetwork tags : List [ str ] = [ DEFAULT_TAG ] Bases: BaseModel IP Range definition for user\u2019s inventory. Attributes: Name Type Description start IPvAnyAddress IPv4 or IPv6 address for the begining of the range. stop IPvAnyAddress IPv4 or IPv6 address for the end of the range. tags List [ str ] List of attached tags read from inventory file. Source code in anta/inventory/models.py 44 45 46 47 48 49 50 51 52 53 54 55 56 class AntaInventoryRange ( BaseModel ): \"\"\" IP Range definition for user's inventory. Attributes: start (IPvAnyAddress): IPv4 or IPv6 address for the begining of the range. stop (IPvAnyAddress): IPv4 or IPv6 address for the end of the range. tags (List[str]): List of attached tags read from inventory file. \"\"\" start : IPvAnyAddress end : IPvAnyAddress tags : List [ str ] = [ DEFAULT_TAG ]","title":"User Inventory data model"},{"location":"api/inventory.models.input/#data-models-for-antainventory","text":"Bases: BaseModel User\u2019s inventory model. Attributes: Name Type Description networks List [ AntaInventoryNetwork ], Optional List of AntaInventoryNetwork objects for networks. hosts List [ AntaInventoryHost ], Optional List of AntaInventoryHost objects for hosts. range List [ AntaInventoryRange ], Optional List of AntaInventoryRange objects for ranges. Source code in anta/inventory/models.py 59 60 61 62 63 64 65 66 67 68 69 70 71 class AntaInventoryInput ( BaseModel ): \"\"\" User's inventory model. Attributes: networks (List[AntaInventoryNetwork],Optional): List of AntaInventoryNetwork objects for networks. hosts (List[AntaInventoryHost],Optional): List of AntaInventoryHost objects for hosts. range (List[AntaInventoryRange],Optional): List of AntaInventoryRange objects for ranges. \"\"\" networks : Optional [ List [ AntaInventoryNetwork ]] hosts : Optional [ List [ AntaInventoryHost ]] ranges : Optional [ List [ AntaInventoryRange ]]","title":"Data models for anta.inventory"},{"location":"api/inventory.models.input/#user-inventory-components","text":"Bases: BaseModel Host definition for user\u2019s inventory. Attributes: Name Type Description host IPvAnyAddress IPv4 or IPv6 address of the device tags List [ str ] List of attached tags read from inventory file. Source code in anta/inventory/models.py 18 19 20 21 22 23 24 25 26 27 28 class AntaInventoryHost ( BaseModel ): \"\"\" Host definition for user's inventory. Attributes: host (IPvAnyAddress): IPv4 or IPv6 address of the device tags (List[str]): List of attached tags read from inventory file. \"\"\" host : IPvAnyAddress tags : List [ str ] = [ DEFAULT_TAG ] Bases: BaseModel Network definition for user\u2019s inventory. Attributes: Name Type Description network IPvAnyNetwork Subnet to use for testing. tags List [ str ] List of attached tags read from inventory file. Source code in anta/inventory/models.py 31 32 33 34 35 36 37 38 39 40 41 class AntaInventoryNetwork ( BaseModel ): \"\"\" Network definition for user's inventory. Attributes: network (IPvAnyNetwork): Subnet to use for testing. tags (List[str]): List of attached tags read from inventory file. \"\"\" network : IPvAnyNetwork tags : List [ str ] = [ DEFAULT_TAG ] Bases: BaseModel IP Range definition for user\u2019s inventory. Attributes: Name Type Description start IPvAnyAddress IPv4 or IPv6 address for the begining of the range. stop IPvAnyAddress IPv4 or IPv6 address for the end of the range. tags List [ str ] List of attached tags read from inventory file. Source code in anta/inventory/models.py 44 45 46 47 48 49 50 51 52 53 54 55 56 class AntaInventoryRange ( BaseModel ): \"\"\" IP Range definition for user's inventory. Attributes: start (IPvAnyAddress): IPv4 or IPv6 address for the begining of the range. stop (IPvAnyAddress): IPv4 or IPv6 address for the end of the range. tags (List[str]): List of attached tags read from inventory file. \"\"\" start : IPvAnyAddress end : IPvAnyAddress tags : List [ str ] = [ DEFAULT_TAG ]","title":"User inventory components"},{"location":"api/inventory.models/","text":"Inventory Entry \u00b6 Bases: BaseModel Inventory model exposed by Inventory class. Attributes: Name Type Description host IPvAnyAddress IPv4 or IPv6 address of the device. username str Username to use for connection. password password Password to use for connection. enable_password Optional [ str ] enable_password to use on the device, required for some tests session Any JSONRPC session. established bool Flag to mark if connection is established (True) or not (False). Default: False. is_online bool Flag to mark if host is alive (True) or not (False). Default: False. hw_model str HW name gathered during device discovery. url str eAPI URL to use to build session. tags List [ str ] List of attached tags read from inventory file. Source code in anta/inventory/models.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 class InventoryDevice ( BaseModel ): \"\"\" Inventory model exposed by Inventory class. Attributes: host (IPvAnyAddress): IPv4 or IPv6 address of the device. username (str): Username to use for connection. password (password): Password to use for connection. enable_password (Optional[str]): enable_password to use on the device, required for some tests session (Any): JSONRPC session. established (bool): Flag to mark if connection is established (True) or not (False). Default: False. is_online (bool): Flag to mark if host is alive (True) or not (False). Default: False. hw_model (str): HW name gathered during device discovery. url (str): eAPI URL to use to build session. tags (List[str]): List of attached tags read from inventory file. \"\"\" host : IPvAnyAddress username : str password : str enable_password : Optional [ str ] session : Any established = False is_online = False hw_model : str = DEFAULT_HW_MODEL url : str tags : List [ str ] = [ DEFAULT_TAG ] def assert_enable_password_is_not_none ( self , test_name : Optional [ str ] = None ) -> None : \"\"\" raise ValueError is enable_password is None \"\"\" if not self . enable_password : if test_name : message = f \" { test_name } requires `enable_password` to be set\" else : message = \"`enable_password` is not set\" raise ValueError ( message ) assert_enable_password_is_not_none ( test_name = None ) \u00b6 raise ValueError is enable_password is None Source code in anta/inventory/models.py 105 106 107 108 109 110 111 112 113 114 def assert_enable_password_is_not_none ( self , test_name : Optional [ str ] = None ) -> None : \"\"\" raise ValueError is enable_password is None \"\"\" if not self . enable_password : if test_name : message = f \" { test_name } requires `enable_password` to be set\" else : message = \"`enable_password` is not set\" raise ValueError ( message ) Inventory \u00b6 Bases: BaseModel Inventory model to list all InventoryDevice entries. Attributes: Name Type Description __root__(List[InventoryDevice]) A list of InventoryDevice objects. Source code in anta/inventory/models.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 class InventoryDevices ( BaseModel ): \"\"\" Inventory model to list all InventoryDevice entries. Attributes: __root__(List[InventoryDevice]): A list of InventoryDevice objects. \"\"\" # pylint: disable=R0801 __root__ : List [ InventoryDevice ] = [] def append ( self , value : InventoryDevice ) -> None : \"\"\"Add support for append method.\"\"\" self . __root__ . append ( value ) def __iter__ ( self ) -> Iterator [ InventoryDevice ]: \"\"\"Use custom iter method.\"\"\" return iter ( self . __root__ ) def __getitem__ ( self , item : int ) -> InventoryDevice : \"\"\"Use custom getitem method.\"\"\" return self . __root__ [ item ] def __len__ ( self ) -> int : \"\"\"Support for length of __root__\"\"\" return len ( self . __root__ ) __getitem__ ( item ) \u00b6 Use custom getitem method. Source code in anta/inventory/models.py 136 137 138 def __getitem__ ( self , item : int ) -> InventoryDevice : \"\"\"Use custom getitem method.\"\"\" return self . __root__ [ item ] __iter__ () \u00b6 Use custom iter method. Source code in anta/inventory/models.py 132 133 134 def __iter__ ( self ) -> Iterator [ InventoryDevice ]: \"\"\"Use custom iter method.\"\"\" return iter ( self . __root__ ) __len__ () \u00b6 Support for length of root Source code in anta/inventory/models.py 140 141 142 def __len__ ( self ) -> int : \"\"\"Support for length of __root__\"\"\" return len ( self . __root__ ) append ( value ) \u00b6 Add support for append method. Source code in anta/inventory/models.py 128 129 130 def append ( self , value : InventoryDevice ) -> None : \"\"\"Add support for append method.\"\"\" self . __root__ . append ( value )","title":"Generated Inventory data model"},{"location":"api/inventory.models/#inventory-entry","text":"Bases: BaseModel Inventory model exposed by Inventory class. Attributes: Name Type Description host IPvAnyAddress IPv4 or IPv6 address of the device. username str Username to use for connection. password password Password to use for connection. enable_password Optional [ str ] enable_password to use on the device, required for some tests session Any JSONRPC session. established bool Flag to mark if connection is established (True) or not (False). Default: False. is_online bool Flag to mark if host is alive (True) or not (False). Default: False. hw_model str HW name gathered during device discovery. url str eAPI URL to use to build session. tags List [ str ] List of attached tags read from inventory file. Source code in anta/inventory/models.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 class InventoryDevice ( BaseModel ): \"\"\" Inventory model exposed by Inventory class. Attributes: host (IPvAnyAddress): IPv4 or IPv6 address of the device. username (str): Username to use for connection. password (password): Password to use for connection. enable_password (Optional[str]): enable_password to use on the device, required for some tests session (Any): JSONRPC session. established (bool): Flag to mark if connection is established (True) or not (False). Default: False. is_online (bool): Flag to mark if host is alive (True) or not (False). Default: False. hw_model (str): HW name gathered during device discovery. url (str): eAPI URL to use to build session. tags (List[str]): List of attached tags read from inventory file. \"\"\" host : IPvAnyAddress username : str password : str enable_password : Optional [ str ] session : Any established = False is_online = False hw_model : str = DEFAULT_HW_MODEL url : str tags : List [ str ] = [ DEFAULT_TAG ] def assert_enable_password_is_not_none ( self , test_name : Optional [ str ] = None ) -> None : \"\"\" raise ValueError is enable_password is None \"\"\" if not self . enable_password : if test_name : message = f \" { test_name } requires `enable_password` to be set\" else : message = \"`enable_password` is not set\" raise ValueError ( message )","title":"Inventory Entry"},{"location":"api/inventory.models/#anta.inventory.models.InventoryDevice.assert_enable_password_is_not_none","text":"raise ValueError is enable_password is None Source code in anta/inventory/models.py 105 106 107 108 109 110 111 112 113 114 def assert_enable_password_is_not_none ( self , test_name : Optional [ str ] = None ) -> None : \"\"\" raise ValueError is enable_password is None \"\"\" if not self . enable_password : if test_name : message = f \" { test_name } requires `enable_password` to be set\" else : message = \"`enable_password` is not set\" raise ValueError ( message )","title":"assert_enable_password_is_not_none()"},{"location":"api/inventory.models/#inventory","text":"Bases: BaseModel Inventory model to list all InventoryDevice entries. Attributes: Name Type Description __root__(List[InventoryDevice]) A list of InventoryDevice objects. Source code in anta/inventory/models.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 class InventoryDevices ( BaseModel ): \"\"\" Inventory model to list all InventoryDevice entries. Attributes: __root__(List[InventoryDevice]): A list of InventoryDevice objects. \"\"\" # pylint: disable=R0801 __root__ : List [ InventoryDevice ] = [] def append ( self , value : InventoryDevice ) -> None : \"\"\"Add support for append method.\"\"\" self . __root__ . append ( value ) def __iter__ ( self ) -> Iterator [ InventoryDevice ]: \"\"\"Use custom iter method.\"\"\" return iter ( self . __root__ ) def __getitem__ ( self , item : int ) -> InventoryDevice : \"\"\"Use custom getitem method.\"\"\" return self . __root__ [ item ] def __len__ ( self ) -> int : \"\"\"Support for length of __root__\"\"\" return len ( self . __root__ )","title":"Inventory"},{"location":"api/inventory.models/#anta.inventory.models.InventoryDevices.__getitem__","text":"Use custom getitem method. Source code in anta/inventory/models.py 136 137 138 def __getitem__ ( self , item : int ) -> InventoryDevice : \"\"\"Use custom getitem method.\"\"\" return self . __root__ [ item ]","title":"__getitem__()"},{"location":"api/inventory.models/#anta.inventory.models.InventoryDevices.__iter__","text":"Use custom iter method. Source code in anta/inventory/models.py 132 133 134 def __iter__ ( self ) -> Iterator [ InventoryDevice ]: \"\"\"Use custom iter method.\"\"\" return iter ( self . __root__ )","title":"__iter__()"},{"location":"api/inventory.models/#anta.inventory.models.InventoryDevices.__len__","text":"Support for length of root Source code in anta/inventory/models.py 140 141 142 def __len__ ( self ) -> int : \"\"\"Support for length of __root__\"\"\" return len ( self . __root__ )","title":"__len__()"},{"location":"api/inventory.models/#anta.inventory.models.InventoryDevices.append","text":"Add support for append method. Source code in anta/inventory/models.py 128 129 130 def append ( self , value : InventoryDevice ) -> None : \"\"\"Add support for append method.\"\"\" self . __root__ . append ( value )","title":"append()"},{"location":"api/result_manager/","text":"ANTA ResultManager module \u00b6 Helper to manage Test Results and generate reports. Examples: Create Inventory: inventory_anta = AntaInventory( inventory_file='examples/inventory.yml', username='ansible', password='ansible', timeout=0.5, auto_connect=True ) Create Result Manager: manager = ResultManager() Run tests for all connected devices: for device in inventory_anta . get_inventory () : manager . add_test_result ( verify_eos_version ( device = device , versions = [ '4.28.0F' ] ) ) manager . add_test_result ( verify_uptime ( device = device , minimum = 1 ) ) Print result in native format: manager.get_results() [ TestResult( host=IPv4Address('192.168.0.10'), test='verify_eos_version', result='failure', message=\"device is running version 4.27.3F-26379303.4273F (engineering build) and test expect ['4.28.0F']\" ), TestResult( host=IPv4Address('192.168.0.10'), test='verify_eos_version', result='success', message=None ), ] Source code in anta/result_manager/__init__.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 class ResultManager : \"\"\" Helper to manage Test Results and generate reports. Examples: Create Inventory: inventory_anta = AntaInventory( inventory_file='examples/inventory.yml', username='ansible', password='ansible', timeout=0.5, auto_connect=True ) Create Result Manager: manager = ResultManager() Run tests for all connected devices: for device in inventory_anta.get_inventory(): manager.add_test_result( verify_eos_version( device=device, versions=['4.28.0F'] ) ) manager.add_test_result( verify_uptime( device=device, minimum=1 ) ) Print result in native format: manager.get_results() [ TestResult( host=IPv4Address('192.168.0.10'), test='verify_eos_version', result='failure', message=\"device is running version 4.27.3F-26379303.4273F (engineering build) and test expect ['4.28.0F']\" ), TestResult( host=IPv4Address('192.168.0.10'), test='verify_eos_version', result='success', message=None ), ] \"\"\" def __init__ ( self ) -> None : \"\"\" Class constructor.\"\"\" logger . debug ( 'Instantiate result-manager' ) self . _result_entries = ListResult () def __len__ ( self ) -> int : \"\"\" Implement __len__ method to count number of results. \"\"\" return len ( self . _result_entries ) def add_test_result ( self , entry : TestResult ) -> None : \"\"\"Add a result to the list Args: entry (TestResult): TestResult data to add to the report \"\"\" logger . info ( f 'add new test result to manager: { entry } ' ) self . _result_entries . append ( entry ) def get_results ( self , output_format : str = \"native\" ) -> Any : \"\"\" Expose list of all test results in different format Support multiple format: - native: ListResults format - list: a list of TestResult - json: a native JSON format Args: output_format (str, optional): format selector. Can be either native/list/json. Defaults to 'native'. Returns: any: List of results. \"\"\" logger . info ( f 'retrieve list of result using output_format { output_format } ' ) if output_format == 'list' : return list ( self . _result_entries ) if output_format == \"json\" : return json . dumps ( pydantic_to_dict ( self . _result_entries ), indent = 4 ) # Default return for native format. return self . _result_entries def get_result_by_test ( self , test_name : str , output_format : str = \"native\" ) -> Any : \"\"\" Get list of test result for a given test. Args: test_name (str): Test name to use to filter results output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'. Returns: list[TestResult]: List of results related to the test. \"\"\" logger . info ( f 'retrieve list of result using output_format { output_format } for test { test_name } ' ) if output_format == \"list\" : return [ result for result in self . _result_entries if str ( result . test ) == test_name ] result_manager_filtered = ListResult () for result in self . _result_entries : if result . test == test_name : result_manager_filtered . append ( result ) return result_manager_filtered def get_result_by_host ( self , host_ip : str , output_format : str = \"native\" ) -> Any : \"\"\" Get list of test result for a given host. Args: host_ip (str): IP Address of the host to use to filter results. output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'. Returns: Any: List of results related to the host. \"\"\" logger . info ( f 'retrieve list of result using output_format { output_format } for host { host_ip } ' ) if output_format == \"list\" : return [ result for result in self . _result_entries if str ( result . host ) == host_ip ] result_manager_filtered = ListResult () for result in self . _result_entries : if str ( result . host ) == host_ip : result_manager_filtered . append ( result ) return result_manager_filtered def get_testcases ( self ) -> List [ str ]: \"\"\" Get list of name of all test cases in current manager. Returns: List[str]: List of names for all tests. \"\"\" logger . info ( 'build list of testcases registered in result-manager' ) result_list = [] for testcase in self . _result_entries : if str ( testcase . test ) not in result_list : result_list . append ( str ( testcase . test )) logger . debug ( f 'list of tests name: { result_list } ' ) return result_list def get_hosts ( self ) -> List [ str ]: \"\"\" Get list of IP addresses in current manager. Returns: List[str]: List of IP addresses. \"\"\" logger . info ( 'build list of host ip registered in result-manager' ) result_list = [] for testcase in self . _result_entries : if str ( testcase . host ) not in result_list : result_list . append ( str ( testcase . host )) logger . debug ( f 'list of tests name: { result_list } ' ) return result_list __init__ () \u00b6 Class constructor. Source code in anta/result_manager/__init__.py 71 72 73 74 def __init__ ( self ) -> None : \"\"\" Class constructor.\"\"\" logger . debug ( 'Instantiate result-manager' ) self . _result_entries = ListResult () __len__ () \u00b6 Implement len method to count number of results. Source code in anta/result_manager/__init__.py 76 77 78 79 80 def __len__ ( self ) -> int : \"\"\" Implement __len__ method to count number of results. \"\"\" return len ( self . _result_entries ) add_test_result ( entry ) \u00b6 Add a result to the list Parameters: Name Type Description Default entry TestResult TestResult data to add to the report required Source code in anta/result_manager/__init__.py 82 83 84 85 86 87 88 89 def add_test_result ( self , entry : TestResult ) -> None : \"\"\"Add a result to the list Args: entry (TestResult): TestResult data to add to the report \"\"\" logger . info ( f 'add new test result to manager: { entry } ' ) self . _result_entries . append ( entry ) get_hosts () \u00b6 Get list of IP addresses in current manager. Returns: Type Description List [ str ] List[str]: List of IP addresses. Source code in anta/result_manager/__init__.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def get_hosts ( self ) -> List [ str ]: \"\"\" Get list of IP addresses in current manager. Returns: List[str]: List of IP addresses. \"\"\" logger . info ( 'build list of host ip registered in result-manager' ) result_list = [] for testcase in self . _result_entries : if str ( testcase . host ) not in result_list : result_list . append ( str ( testcase . host )) logger . debug ( f 'list of tests name: { result_list } ' ) return result_list get_result_by_host ( host_ip , output_format = 'native' ) \u00b6 Get list of test result for a given host. Parameters: Name Type Description Default host_ip str IP Address of the host to use to filter results. required output_format str format selector. Can be either native/list. Defaults to \u2018native\u2019. 'native' Returns: Name Type Description Any Any List of results related to the host. Source code in anta/result_manager/__init__.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def get_result_by_host ( self , host_ip : str , output_format : str = \"native\" ) -> Any : \"\"\" Get list of test result for a given host. Args: host_ip (str): IP Address of the host to use to filter results. output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'. Returns: Any: List of results related to the host. \"\"\" logger . info ( f 'retrieve list of result using output_format { output_format } for host { host_ip } ' ) if output_format == \"list\" : return [ result for result in self . _result_entries if str ( result . host ) == host_ip ] result_manager_filtered = ListResult () for result in self . _result_entries : if str ( result . host ) == host_ip : result_manager_filtered . append ( result ) return result_manager_filtered get_result_by_test ( test_name , output_format = 'native' ) \u00b6 Get list of test result for a given test. Parameters: Name Type Description Default test_name str Test name to use to filter results required output_format str format selector. Can be either native/list. Defaults to \u2018native\u2019. 'native' Returns: Type Description Any list[TestResult]: List of results related to the test. Source code in anta/result_manager/__init__.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def get_result_by_test ( self , test_name : str , output_format : str = \"native\" ) -> Any : \"\"\" Get list of test result for a given test. Args: test_name (str): Test name to use to filter results output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'. Returns: list[TestResult]: List of results related to the test. \"\"\" logger . info ( f 'retrieve list of result using output_format { output_format } for test { test_name } ' ) if output_format == \"list\" : return [ result for result in self . _result_entries if str ( result . test ) == test_name ] result_manager_filtered = ListResult () for result in self . _result_entries : if result . test == test_name : result_manager_filtered . append ( result ) return result_manager_filtered get_results ( output_format = 'native' ) \u00b6 Expose list of all test results in different format Support multiple format native: ListResults format list: a list of TestResult json: a native JSON format Parameters: Name Type Description Default output_format str format selector. Can be either native/list/json. Defaults to \u2018native\u2019. 'native' Returns: Name Type Description any Any List of results. Source code in anta/result_manager/__init__.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def get_results ( self , output_format : str = \"native\" ) -> Any : \"\"\" Expose list of all test results in different format Support multiple format: - native: ListResults format - list: a list of TestResult - json: a native JSON format Args: output_format (str, optional): format selector. Can be either native/list/json. Defaults to 'native'. Returns: any: List of results. \"\"\" logger . info ( f 'retrieve list of result using output_format { output_format } ' ) if output_format == 'list' : return list ( self . _result_entries ) if output_format == \"json\" : return json . dumps ( pydantic_to_dict ( self . _result_entries ), indent = 4 ) # Default return for native format. return self . _result_entries get_testcases () \u00b6 Get list of name of all test cases in current manager. Returns: Type Description List [ str ] List[str]: List of names for all tests. Source code in anta/result_manager/__init__.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def get_testcases ( self ) -> List [ str ]: \"\"\" Get list of name of all test cases in current manager. Returns: List[str]: List of names for all tests. \"\"\" logger . info ( 'build list of testcases registered in result-manager' ) result_list = [] for testcase in self . _result_entries : if str ( testcase . test ) not in result_list : result_list . append ( str ( testcase . test )) logger . debug ( f 'list of tests name: { result_list } ' ) return result_list","title":"Result Manager module"},{"location":"api/result_manager/#anta-resultmanager-module","text":"Helper to manage Test Results and generate reports. Examples: Create Inventory: inventory_anta = AntaInventory( inventory_file='examples/inventory.yml', username='ansible', password='ansible', timeout=0.5, auto_connect=True ) Create Result Manager: manager = ResultManager() Run tests for all connected devices: for device in inventory_anta . get_inventory () : manager . add_test_result ( verify_eos_version ( device = device , versions = [ '4.28.0F' ] ) ) manager . add_test_result ( verify_uptime ( device = device , minimum = 1 ) ) Print result in native format: manager.get_results() [ TestResult( host=IPv4Address('192.168.0.10'), test='verify_eos_version', result='failure', message=\"device is running version 4.27.3F-26379303.4273F (engineering build) and test expect ['4.28.0F']\" ), TestResult( host=IPv4Address('192.168.0.10'), test='verify_eos_version', result='success', message=None ), ] Source code in anta/result_manager/__init__.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 class ResultManager : \"\"\" Helper to manage Test Results and generate reports. Examples: Create Inventory: inventory_anta = AntaInventory( inventory_file='examples/inventory.yml', username='ansible', password='ansible', timeout=0.5, auto_connect=True ) Create Result Manager: manager = ResultManager() Run tests for all connected devices: for device in inventory_anta.get_inventory(): manager.add_test_result( verify_eos_version( device=device, versions=['4.28.0F'] ) ) manager.add_test_result( verify_uptime( device=device, minimum=1 ) ) Print result in native format: manager.get_results() [ TestResult( host=IPv4Address('192.168.0.10'), test='verify_eos_version', result='failure', message=\"device is running version 4.27.3F-26379303.4273F (engineering build) and test expect ['4.28.0F']\" ), TestResult( host=IPv4Address('192.168.0.10'), test='verify_eos_version', result='success', message=None ), ] \"\"\" def __init__ ( self ) -> None : \"\"\" Class constructor.\"\"\" logger . debug ( 'Instantiate result-manager' ) self . _result_entries = ListResult () def __len__ ( self ) -> int : \"\"\" Implement __len__ method to count number of results. \"\"\" return len ( self . _result_entries ) def add_test_result ( self , entry : TestResult ) -> None : \"\"\"Add a result to the list Args: entry (TestResult): TestResult data to add to the report \"\"\" logger . info ( f 'add new test result to manager: { entry } ' ) self . _result_entries . append ( entry ) def get_results ( self , output_format : str = \"native\" ) -> Any : \"\"\" Expose list of all test results in different format Support multiple format: - native: ListResults format - list: a list of TestResult - json: a native JSON format Args: output_format (str, optional): format selector. Can be either native/list/json. Defaults to 'native'. Returns: any: List of results. \"\"\" logger . info ( f 'retrieve list of result using output_format { output_format } ' ) if output_format == 'list' : return list ( self . _result_entries ) if output_format == \"json\" : return json . dumps ( pydantic_to_dict ( self . _result_entries ), indent = 4 ) # Default return for native format. return self . _result_entries def get_result_by_test ( self , test_name : str , output_format : str = \"native\" ) -> Any : \"\"\" Get list of test result for a given test. Args: test_name (str): Test name to use to filter results output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'. Returns: list[TestResult]: List of results related to the test. \"\"\" logger . info ( f 'retrieve list of result using output_format { output_format } for test { test_name } ' ) if output_format == \"list\" : return [ result for result in self . _result_entries if str ( result . test ) == test_name ] result_manager_filtered = ListResult () for result in self . _result_entries : if result . test == test_name : result_manager_filtered . append ( result ) return result_manager_filtered def get_result_by_host ( self , host_ip : str , output_format : str = \"native\" ) -> Any : \"\"\" Get list of test result for a given host. Args: host_ip (str): IP Address of the host to use to filter results. output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'. Returns: Any: List of results related to the host. \"\"\" logger . info ( f 'retrieve list of result using output_format { output_format } for host { host_ip } ' ) if output_format == \"list\" : return [ result for result in self . _result_entries if str ( result . host ) == host_ip ] result_manager_filtered = ListResult () for result in self . _result_entries : if str ( result . host ) == host_ip : result_manager_filtered . append ( result ) return result_manager_filtered def get_testcases ( self ) -> List [ str ]: \"\"\" Get list of name of all test cases in current manager. Returns: List[str]: List of names for all tests. \"\"\" logger . info ( 'build list of testcases registered in result-manager' ) result_list = [] for testcase in self . _result_entries : if str ( testcase . test ) not in result_list : result_list . append ( str ( testcase . test )) logger . debug ( f 'list of tests name: { result_list } ' ) return result_list def get_hosts ( self ) -> List [ str ]: \"\"\" Get list of IP addresses in current manager. Returns: List[str]: List of IP addresses. \"\"\" logger . info ( 'build list of host ip registered in result-manager' ) result_list = [] for testcase in self . _result_entries : if str ( testcase . host ) not in result_list : result_list . append ( str ( testcase . host )) logger . debug ( f 'list of tests name: { result_list } ' ) return result_list","title":"ANTA ResultManager module"},{"location":"api/result_manager/#anta.result_manager.ResultManager.__init__","text":"Class constructor. Source code in anta/result_manager/__init__.py 71 72 73 74 def __init__ ( self ) -> None : \"\"\" Class constructor.\"\"\" logger . debug ( 'Instantiate result-manager' ) self . _result_entries = ListResult ()","title":"__init__()"},{"location":"api/result_manager/#anta.result_manager.ResultManager.__len__","text":"Implement len method to count number of results. Source code in anta/result_manager/__init__.py 76 77 78 79 80 def __len__ ( self ) -> int : \"\"\" Implement __len__ method to count number of results. \"\"\" return len ( self . _result_entries )","title":"__len__()"},{"location":"api/result_manager/#anta.result_manager.ResultManager.add_test_result","text":"Add a result to the list Parameters: Name Type Description Default entry TestResult TestResult data to add to the report required Source code in anta/result_manager/__init__.py 82 83 84 85 86 87 88 89 def add_test_result ( self , entry : TestResult ) -> None : \"\"\"Add a result to the list Args: entry (TestResult): TestResult data to add to the report \"\"\" logger . info ( f 'add new test result to manager: { entry } ' ) self . _result_entries . append ( entry )","title":"add_test_result()"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_hosts","text":"Get list of IP addresses in current manager. Returns: Type Description List [ str ] List[str]: List of IP addresses. Source code in anta/result_manager/__init__.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def get_hosts ( self ) -> List [ str ]: \"\"\" Get list of IP addresses in current manager. Returns: List[str]: List of IP addresses. \"\"\" logger . info ( 'build list of host ip registered in result-manager' ) result_list = [] for testcase in self . _result_entries : if str ( testcase . host ) not in result_list : result_list . append ( str ( testcase . host )) logger . debug ( f 'list of tests name: { result_list } ' ) return result_list","title":"get_hosts()"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_result_by_host","text":"Get list of test result for a given host. Parameters: Name Type Description Default host_ip str IP Address of the host to use to filter results. required output_format str format selector. Can be either native/list. Defaults to \u2018native\u2019. 'native' Returns: Name Type Description Any Any List of results related to the host. Source code in anta/result_manager/__init__.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def get_result_by_host ( self , host_ip : str , output_format : str = \"native\" ) -> Any : \"\"\" Get list of test result for a given host. Args: host_ip (str): IP Address of the host to use to filter results. output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'. Returns: Any: List of results related to the host. \"\"\" logger . info ( f 'retrieve list of result using output_format { output_format } for host { host_ip } ' ) if output_format == \"list\" : return [ result for result in self . _result_entries if str ( result . host ) == host_ip ] result_manager_filtered = ListResult () for result in self . _result_entries : if str ( result . host ) == host_ip : result_manager_filtered . append ( result ) return result_manager_filtered","title":"get_result_by_host()"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_result_by_test","text":"Get list of test result for a given test. Parameters: Name Type Description Default test_name str Test name to use to filter results required output_format str format selector. Can be either native/list. Defaults to \u2018native\u2019. 'native' Returns: Type Description Any list[TestResult]: List of results related to the test. Source code in anta/result_manager/__init__.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def get_result_by_test ( self , test_name : str , output_format : str = \"native\" ) -> Any : \"\"\" Get list of test result for a given test. Args: test_name (str): Test name to use to filter results output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'. Returns: list[TestResult]: List of results related to the test. \"\"\" logger . info ( f 'retrieve list of result using output_format { output_format } for test { test_name } ' ) if output_format == \"list\" : return [ result for result in self . _result_entries if str ( result . test ) == test_name ] result_manager_filtered = ListResult () for result in self . _result_entries : if result . test == test_name : result_manager_filtered . append ( result ) return result_manager_filtered","title":"get_result_by_test()"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_results","text":"Expose list of all test results in different format Support multiple format native: ListResults format list: a list of TestResult json: a native JSON format Parameters: Name Type Description Default output_format str format selector. Can be either native/list/json. Defaults to \u2018native\u2019. 'native' Returns: Name Type Description any Any List of results. Source code in anta/result_manager/__init__.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def get_results ( self , output_format : str = \"native\" ) -> Any : \"\"\" Expose list of all test results in different format Support multiple format: - native: ListResults format - list: a list of TestResult - json: a native JSON format Args: output_format (str, optional): format selector. Can be either native/list/json. Defaults to 'native'. Returns: any: List of results. \"\"\" logger . info ( f 'retrieve list of result using output_format { output_format } ' ) if output_format == 'list' : return list ( self . _result_entries ) if output_format == \"json\" : return json . dumps ( pydantic_to_dict ( self . _result_entries ), indent = 4 ) # Default return for native format. return self . _result_entries","title":"get_results()"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_testcases","text":"Get list of name of all test cases in current manager. Returns: Type Description List [ str ] List[str]: List of names for all tests. Source code in anta/result_manager/__init__.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def get_testcases ( self ) -> List [ str ]: \"\"\" Get list of name of all test cases in current manager. Returns: List[str]: List of names for all tests. \"\"\" logger . info ( 'build list of testcases registered in result-manager' ) result_list = [] for testcase in self . _result_entries : if str ( testcase . test ) not in result_list : result_list . append ( str ( testcase . test )) logger . debug ( f 'list of tests name: { result_list } ' ) return result_list","title":"get_testcases()"},{"location":"api/tests.configuration/","text":"ANTA catalog for configuration tests \u00b6 Test functions related to the device configuration verify_running_config_diffs ( device ) \u00b6 Verifies there is no difference between the running-config and the startup-config. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if there is no difference between the running-config and the startup-config TestResult result = \u201cfailure\u201d if there are differences TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/configuration.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def verify_running_config_diffs ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no difference between the running-config and the startup-config. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if there is no difference between the running-config and the startup-config * result = \"failure\" if there are differences * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : device . assert_enable_password_is_not_none ( \"verify_running_config_diffs\" ) response = device . session . runCmds ( 1 , [ { \"cmd\" : \"enable\" , \"input\" : str ( device . enable_password )}, \"show running-config diffs\" , ], \"text\" , ) logger . debug ( f 'query result is: { response } ' ) if len ( response [ 1 ][ \"output\" ]) == 0 : result . is_success () else : result . is_failure () for line in response [ 1 ][ \"output\" ]: result . is_failure ( line ) except ( ValueError , jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result verify_zerotouch ( device ) \u00b6 Verifies ZeroTouch is disabled. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if ZTP is disabled TestResult result = \u201cfailure\u201d if ZTP is enabled TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/configuration.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def verify_zerotouch ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies ZeroTouch is disabled. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if ZTP is disabled * result = \"failure\" if ZTP is enabled * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show zerotouch\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) if response [ 0 ][ \"mode\" ] == \"disabled\" : result . is_success () else : result . is_failure ( \"ZTP is NOT disabled\" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"Configuration"},{"location":"api/tests.configuration/#anta-catalog-for-configuration-tests","text":"Test functions related to the device configuration","title":"ANTA catalog for configuration tests"},{"location":"api/tests.configuration/#anta.tests.configuration.verify_running_config_diffs","text":"Verifies there is no difference between the running-config and the startup-config. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if there is no difference between the running-config and the startup-config TestResult result = \u201cfailure\u201d if there are differences TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/configuration.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def verify_running_config_diffs ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no difference between the running-config and the startup-config. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if there is no difference between the running-config and the startup-config * result = \"failure\" if there are differences * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : device . assert_enable_password_is_not_none ( \"verify_running_config_diffs\" ) response = device . session . runCmds ( 1 , [ { \"cmd\" : \"enable\" , \"input\" : str ( device . enable_password )}, \"show running-config diffs\" , ], \"text\" , ) logger . debug ( f 'query result is: { response } ' ) if len ( response [ 1 ][ \"output\" ]) == 0 : result . is_success () else : result . is_failure () for line in response [ 1 ][ \"output\" ]: result . is_failure ( line ) except ( ValueError , jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_running_config_diffs()"},{"location":"api/tests.configuration/#anta.tests.configuration.verify_zerotouch","text":"Verifies ZeroTouch is disabled. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if ZTP is disabled TestResult result = \u201cfailure\u201d if ZTP is enabled TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/configuration.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def verify_zerotouch ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies ZeroTouch is disabled. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if ZTP is disabled * result = \"failure\" if ZTP is enabled * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show zerotouch\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) if response [ 0 ][ \"mode\" ] == \"disabled\" : result . is_success () else : result . is_failure ( \"ZTP is NOT disabled\" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_zerotouch()"},{"location":"api/tests.hardware/","text":"ANTA catalog for hardware tests \u00b6 Test functions related to the hardware or environement verify_adverse_drops ( device ) \u00b6 Verifies there is no adverse drops on DCS-7280E and DCS-7500E switches. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if the device (DCS-7280E and DCS-7500E) doesnt reports adverse drops. TestResult result = \u201cfailure\u201d if the device (DCS-7280E and DCS-7500E) report adverse drops. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/hardware.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 @skip_on_platforms ([ \"cEOSLab\" , \"vEOS-lab\" ]) def verify_adverse_drops ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no adverse drops on DCS-7280E and DCS-7500E switches. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if the device (DCS-7280E and DCS-7500E) doesnt reports adverse drops. * result = \"failure\" if the device (DCS-7280E and DCS-7500E) report adverse drops. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show hardware counter drop\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) if response [ 0 ][ \"totalAdverseDrops\" ] == 0 : result . is_success () else : result . is_failure ( f \"Device TotalAdverseDrops counter is { response [ 0 ][ 'totalAdverseDrops' ] } .\" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result verify_environment_cooling ( device ) \u00b6 Verifies the fans status is OK. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if the fans status is OK. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/hardware.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 @skip_on_platforms ([ \"cEOSLab\" , \"vEOS-lab\" ]) def verify_environment_cooling ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the fans status is OK. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if the fans status is OK. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show system environment cooling\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) if response [ 0 ][ \"systemStatus\" ] == \"coolingOk\" : result . is_success () else : result . is_failure ( f \"Device cooling is not OK, systemStatus: { response [ 0 ][ 'systemStatus' ] } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result verify_environment_power ( device ) \u00b6 Verifies the power supplies status is OK. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if the power supplies status is OK. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/hardware.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 @skip_on_platforms ([ \"cEOSLab\" , \"vEOS-lab\" ]) def verify_environment_power ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the power supplies status is OK. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if the power supplies status is OK. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show system environment power\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) wrong_power_supplies = { powersupply : { \"state\" : value [ \"state\" ]} for powersupply , value in response [ 0 ][ \"powerSupplies\" ] . items () if value [ \"state\" ] != \"ok\" } if len ( wrong_power_supplies ) == 0 : result . is_success () else : result . is_failure ( \"The following power suppliers are not ok:\" ) result . messages . append ( str ( wrong_power_supplies )) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result verify_system_temperature ( device ) \u00b6 Verifies the device temperature is currently OK and the device did not report any temperature alarm in the past. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if the device temperature is OK. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/hardware.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @skip_on_platforms ([ \"cEOSLab\" , \"vEOS-lab\" ]) def verify_system_temperature ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the device temperature is currently OK and the device did not report any temperature alarm in the past. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if the device temperature is OK. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show system environment temperature\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) if response [ 0 ][ \"systemStatus\" ] == \"temperatureOk\" : result . is_success () else : result . is_failure ( f \"Device temperature is not OK, systemStatus: { response [ 0 ][ 'systemStatus' ] } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result verify_transceiver_temperature ( device ) \u00b6 Verifies the transceivers temperature is currently OK and the device did not report any alarm in the past for its transceivers temperature. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if the device transceivers temperature of the device is currently OK AND the device did not report any alarm in the past for its transceivers temperature. TestResult result = \u201cfailure\u201d otherwise, TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/hardware.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 @skip_on_platforms ([ \"cEOSLab\" , \"vEOS-lab\" ]) def verify_transceiver_temperature ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the transceivers temperature is currently OK and the device did not report any alarm in the past for its transceivers temperature. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if the device transceivers temperature of the device is currently OK AND the device did not report any alarm in the past for its transceivers temperature. * result = \"failure\" otherwise, * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show system environment temperature transceiver\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) # Get the list of sensors sensors = response [ 0 ][ \"tempSensors\" ] wrong_sensors = { sensor [ \"name\" ]: { \"hwStatus\" : sensor [ \"hwStatus\" ], \"alertCount\" : sensor [ \"alertCount\" ], } for sensor in sensors if sensor [ \"hwStatus\" ] != \"ok\" or sensor [ \"alertCount\" ] != 0 } if len ( wrong_sensors ) == 0 : result . is_success () else : result . is_failure ( \"The following sensors do not have the correct temperature or had alarms in the past:\" ) result . messages . append ( str ( wrong_sensors )) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result verify_transceivers_manufacturers ( device , manufacturers = None ) \u00b6 Verifies the device is only using transceivers from supported manufacturers. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required manufacturers list List of allowed transceivers manufacturers. None Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the test was not executed because no manufacturers were given TestResult result = \u201csuccess\u201d if the device is only using transceivers from supported manufacturers. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/hardware.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @skip_on_platforms ([ \"cEOSLab\" , \"vEOS-lab\" ]) def verify_transceivers_manufacturers ( device : InventoryDevice , manufacturers : List [ str ] = None ) -> TestResult : \"\"\" Verifies the device is only using transceivers from supported manufacturers. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. manufacturers (list): List of allowed transceivers manufacturers. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the test was not executed because no manufacturers were given * result = \"success\" if the device is only using transceivers from supported manufacturers. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not manufacturers : result . is_skipped ( \"verify_transceivers_manufacturers was not run as no \" \"manufacturers were given\" ) return result try : response = device . session . runCmds ( 1 , [ \"show inventory\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) wrong_manufacturers = { interface : value [ \"mfgName\" ] for interface , value in response [ 0 ][ \"xcvrSlots\" ] . items () if value [ \"mfgName\" ] not in manufacturers } if len ( wrong_manufacturers ) == 0 : result . is_success () else : result . is_failure ( \"The following interfaces have transceivers from unauthorized manufacturers\" ) result . messages . append ( str ( wrong_manufacturers )) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result","title":"Hardware"},{"location":"api/tests.hardware/#anta-catalog-for-hardware-tests","text":"Test functions related to the hardware or environement","title":"ANTA catalog for hardware tests"},{"location":"api/tests.hardware/#anta.tests.hardware.verify_adverse_drops","text":"Verifies there is no adverse drops on DCS-7280E and DCS-7500E switches. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if the device (DCS-7280E and DCS-7500E) doesnt reports adverse drops. TestResult result = \u201cfailure\u201d if the device (DCS-7280E and DCS-7500E) report adverse drops. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/hardware.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 @skip_on_platforms ([ \"cEOSLab\" , \"vEOS-lab\" ]) def verify_adverse_drops ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no adverse drops on DCS-7280E and DCS-7500E switches. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if the device (DCS-7280E and DCS-7500E) doesnt reports adverse drops. * result = \"failure\" if the device (DCS-7280E and DCS-7500E) report adverse drops. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show hardware counter drop\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) if response [ 0 ][ \"totalAdverseDrops\" ] == 0 : result . is_success () else : result . is_failure ( f \"Device TotalAdverseDrops counter is { response [ 0 ][ 'totalAdverseDrops' ] } .\" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result","title":"verify_adverse_drops()"},{"location":"api/tests.hardware/#anta.tests.hardware.verify_environment_cooling","text":"Verifies the fans status is OK. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if the fans status is OK. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/hardware.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 @skip_on_platforms ([ \"cEOSLab\" , \"vEOS-lab\" ]) def verify_environment_cooling ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the fans status is OK. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if the fans status is OK. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show system environment cooling\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) if response [ 0 ][ \"systemStatus\" ] == \"coolingOk\" : result . is_success () else : result . is_failure ( f \"Device cooling is not OK, systemStatus: { response [ 0 ][ 'systemStatus' ] } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result","title":"verify_environment_cooling()"},{"location":"api/tests.hardware/#anta.tests.hardware.verify_environment_power","text":"Verifies the power supplies status is OK. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if the power supplies status is OK. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/hardware.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 @skip_on_platforms ([ \"cEOSLab\" , \"vEOS-lab\" ]) def verify_environment_power ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the power supplies status is OK. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if the power supplies status is OK. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show system environment power\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) wrong_power_supplies = { powersupply : { \"state\" : value [ \"state\" ]} for powersupply , value in response [ 0 ][ \"powerSupplies\" ] . items () if value [ \"state\" ] != \"ok\" } if len ( wrong_power_supplies ) == 0 : result . is_success () else : result . is_failure ( \"The following power suppliers are not ok:\" ) result . messages . append ( str ( wrong_power_supplies )) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result","title":"verify_environment_power()"},{"location":"api/tests.hardware/#anta.tests.hardware.verify_system_temperature","text":"Verifies the device temperature is currently OK and the device did not report any temperature alarm in the past. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if the device temperature is OK. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/hardware.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @skip_on_platforms ([ \"cEOSLab\" , \"vEOS-lab\" ]) def verify_system_temperature ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the device temperature is currently OK and the device did not report any temperature alarm in the past. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if the device temperature is OK. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show system environment temperature\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) if response [ 0 ][ \"systemStatus\" ] == \"temperatureOk\" : result . is_success () else : result . is_failure ( f \"Device temperature is not OK, systemStatus: { response [ 0 ][ 'systemStatus' ] } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result","title":"verify_system_temperature()"},{"location":"api/tests.hardware/#anta.tests.hardware.verify_transceiver_temperature","text":"Verifies the transceivers temperature is currently OK and the device did not report any alarm in the past for its transceivers temperature. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if the device transceivers temperature of the device is currently OK AND the device did not report any alarm in the past for its transceivers temperature. TestResult result = \u201cfailure\u201d otherwise, TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/hardware.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 @skip_on_platforms ([ \"cEOSLab\" , \"vEOS-lab\" ]) def verify_transceiver_temperature ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the transceivers temperature is currently OK and the device did not report any alarm in the past for its transceivers temperature. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if the device transceivers temperature of the device is currently OK AND the device did not report any alarm in the past for its transceivers temperature. * result = \"failure\" otherwise, * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show system environment temperature transceiver\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) # Get the list of sensors sensors = response [ 0 ][ \"tempSensors\" ] wrong_sensors = { sensor [ \"name\" ]: { \"hwStatus\" : sensor [ \"hwStatus\" ], \"alertCount\" : sensor [ \"alertCount\" ], } for sensor in sensors if sensor [ \"hwStatus\" ] != \"ok\" or sensor [ \"alertCount\" ] != 0 } if len ( wrong_sensors ) == 0 : result . is_success () else : result . is_failure ( \"The following sensors do not have the correct temperature or had alarms in the past:\" ) result . messages . append ( str ( wrong_sensors )) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result","title":"verify_transceiver_temperature()"},{"location":"api/tests.hardware/#anta.tests.hardware.verify_transceivers_manufacturers","text":"Verifies the device is only using transceivers from supported manufacturers. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required manufacturers list List of allowed transceivers manufacturers. None Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the test was not executed because no manufacturers were given TestResult result = \u201csuccess\u201d if the device is only using transceivers from supported manufacturers. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/hardware.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @skip_on_platforms ([ \"cEOSLab\" , \"vEOS-lab\" ]) def verify_transceivers_manufacturers ( device : InventoryDevice , manufacturers : List [ str ] = None ) -> TestResult : \"\"\" Verifies the device is only using transceivers from supported manufacturers. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. manufacturers (list): List of allowed transceivers manufacturers. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the test was not executed because no manufacturers were given * result = \"success\" if the device is only using transceivers from supported manufacturers. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not manufacturers : result . is_skipped ( \"verify_transceivers_manufacturers was not run as no \" \"manufacturers were given\" ) return result try : response = device . session . runCmds ( 1 , [ \"show inventory\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) wrong_manufacturers = { interface : value [ \"mfgName\" ] for interface , value in response [ 0 ][ \"xcvrSlots\" ] . items () if value [ \"mfgName\" ] not in manufacturers } if len ( wrong_manufacturers ) == 0 : result . is_success () else : result . is_failure ( \"The following interfaces have transceivers from unauthorized manufacturers\" ) result . messages . append ( str ( wrong_manufacturers )) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result","title":"verify_transceivers_manufacturers()"},{"location":"api/tests.interfaces/","text":"ANTA catalog for interfaces tests \u00b6 Test functions related to the device interfaces verify_illegal_lacp ( device ) \u00b6 Verifies there is no illegal LACP packets received. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if there is no illegal LACP packets received. in particular \u201csuccess\u201d if there is no port-channel TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 def verify_illegal_lacp ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no illegal LACP packets received. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if there is no illegal LACP packets received. in particular \"success\" if there is no port-channel * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_illegal_lacp\" ) try : response = device . session . runCmds ( 1 , [ \"show lacp counters all-ports\" ], \"json\" ) po_with_illegal_lacp = { portchannel : [ interface for interface , interface_dict in portchannel_dict [ \"interfaces\" ] . items () if interface_dict [ \"illegalRxCount\" ] != 0 ] for portchannel , portchannel_dict in response [ 0 ][ \"portChannels\" ] . items () } if len ( po_with_illegal_lacp ) == 0 : result . is_success () else : result . is_failure ( \"The following port-channels have recieved illegal lacp packets on the \" f \"following ports: { po_with_illegal_lacp } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result verify_interface_discards ( device ) \u00b6 Verifies interfaces packet discard counters are equal to zero. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if interfaces discard counters are equal to zero. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def verify_interface_discards ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies interfaces packet discard counters are equal to zero. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if interfaces discard counters are equal to zero. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_interface_discards\" ) try : response = device . session . runCmds ( 1 , [ \"show interfaces counters discards\" ], \"json\" ) wrong_interfaces = { interface : { counter : value for counter , value in outer_v . items if value > 0 } for interface , outer_v in response [ 0 ][ \"interfaces\" ] } if len ( wrong_interfaces ) == 0 : result . is_success () else : result . is_failure ( f \"The following interfaces have non 0 discard counter(s): { wrong_interfaces } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result verify_interface_errdisabled ( device ) \u00b6 Verifies there is no interface in error disable state. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if no interface is in error disable state. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def verify_interface_errdisabled ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no interface in error disable state. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if no interface is in error disable state. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_interface_errdisabled\" ) try : response = device . session . runCmds ( 1 , [ \"show interfaces status\" ], \"json\" ) errdisabled_interfaces = [ interface for interface , value in response [ 0 ][ \"interfaceStatuses\" ] . items () if value [ \"linkStatus\" ] == \"errdisabled\" ] if len ( errdisabled_interfaces ) == 0 : result . is_success () else : result . is_failure ( f \"The following interfaces are in error disabled state: { errdisabled_interfaces } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result verify_interface_errors ( device ) \u00b6 Verifies interfaces error counters are equal to zero. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if interfaces error counters are equal to zero. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def verify_interface_errors ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies interfaces error counters are equal to zero. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if interfaces error counters are equal to zero. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_interface_errors\" ) try : response = device . session . runCmds ( 1 , [ \"show interfaces counters errors\" ], \"json\" ) wrong_interfaces = { interface : { counter : value for counter , value in outer_v . items if value > 0 } for interface , outer_v in response [ 0 ][ \"interfaceErrorCounters\" ] } if len ( wrong_interfaces ) == 0 : result . is_success () else : result . is_failure ( f \"The following interfaces have non 0 error counter(s): { wrong_interfaces } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result verify_interface_utilization ( device ) \u00b6 Verifies interfaces utilization is below 75%. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if interfaces utilization is below 75% TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def verify_interface_utilization ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies interfaces utilization is below 75%. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if interfaces utilization is below 75% * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_interface_utilization\" ) try : # TODO make it JSON - bad news it seems percentages are not in the json payload response = device . session . runCmds ( 1 , [ \"show interfaces counters rates\" ], \"text\" ) wrong_interfaces = {} for line in response [ 0 ][ \"output\" ] . split ( \" \\n \" )[ 1 :]: if len ( line ) > 0 : if line . split ()[ - 5 ] == \"-\" or line . split ()[ - 2 ] == \"-\" : pass elif float ( line . split ()[ - 5 ] . replace ( \"%\" , \"\" )) > 75.0 : wrong_interfaces [ line . split ()[ 0 ]] = line . split ()[ - 5 ] elif float ( line . split ()[ - 2 ] . replace ( \"%\" , \"\" )) > 75.0 : wrong_interfaces [ line . split ()[ 0 ]] = line . split ()[ - 2 ] if len ( wrong_interfaces ) == 0 : result . is_success () else : result . is_failure ( f \"The following interfaces have a usage > 75%: { wrong_interfaces } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result verify_interfaces_status ( device , minimum = None ) \u00b6 Verifies the number of Ethernet interfaces up/up on the device is higher or equal than a value. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required minimum int Expected minimum number of Ethernet interfaces up/up None Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the minimum parameter is missing TestResult result = \u201csuccess\u201d if the number of Ethernet interface up/up is >= minimum TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def verify_interfaces_status ( device : InventoryDevice , minimum : int = None ) -> TestResult : \"\"\" Verifies the number of Ethernet interfaces up/up on the device is higher or equal than a value. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. minimum (int): Expected minimum number of Ethernet interfaces up/up Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the `minimum` parameter is missing * result = \"success\" if the number of Ethernet interface up/up is >= minimum * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_interfaces_status\" ) if not minimum : result . result = \"skipped\" result . messages . append ( \"verify_interfaces_status was not run as no minimum value was given.\" ) return result try : response = device . session . runCmds ( 1 , [ \"show interfaces description\" ], \"json\" ) count_up_up = 0 other_ethernet_interfaces = [] for interface in response [ 0 ][ \"interfaceDescriptions\" ]: interface_dict = response [ 0 ][ \"interfaceDescriptions\" ][ interface ] if \"Ethernet\" in interface : if ( interface_dict [ \"lineProtocolStatus\" ] == \"up\" and interface_dict [ \"interfaceStatus\" ] == \"up\" ): count_up_up += 1 else : other_ethernet_interfaces . append ( interface ) if count_up_up >= minimum : result . is_success () else : result . is_failure ( f \"Only { count_up_up } , less than { minimum } Ethernet interfaces are UP/UP\" ) result . messages . append ( f \"The following Ethernet interfaces are not UP/UP: { other_ethernet_interfaces } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result verify_loopback_count ( device , number = None ) \u00b6 Verifies the number of loopback interfaces on the device is the one we expect. And if none of the loopback is down. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required number int Expected number of loopback interfaces. None Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if the number of loopback is equal to number and if none of the loopback is down TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 def verify_loopback_count ( device : InventoryDevice , number : int = None ) -> TestResult : \"\"\" Verifies the number of loopback interfaces on the device is the one we expect. And if none of the loopback is down. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. number (int): Expected number of loopback interfaces. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if the number of loopback is equal to `number` and if none of the loopback is down * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_loopback_count\" ) if not number : result . is_skipped ( \"verify_loopback_count was not run as no number value was given.\" ) return result try : response = device . session . runCmds ( 1 , [ \"show ip interface brief \" ], \"json\" ) loopback_count = 0 down_loopback_interfaces = [] for interface in response [ 0 ][ \"interfaceDescriptions\" ]: interface_dict = response [ 0 ][ \"interfaceDescriptions\" ][ interface ] if \"Loopback\" in interface : loopback_count += 1 if not ( interface_dict [ \"lineProtocolStatus\" ] == \"up\" and interface_dict [ \"interfaceStatus\" ] == \"up\" ): down_loopback_interfaces . append ( interface ) if loopback_count == number and len ( down_loopback_interfaces ) == 0 : result . is_success () else : result . is_failure () if loopback_count != number : result . is_failure ( f \"Found { loopback_count } Loopbacks when expecting { number } \" ) elif len ( down_loopback_interfaces ) != 0 : result . is_failure ( f \"The following Loopbacks are not up: { down_loopback_interfaces } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result verify_portchannels ( device ) \u00b6 Verifies there is no inactive port in port channels. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if there is no inactive ports in port-channels in particular \u201csuccess\u201d if there is no port-channel TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 def verify_portchannels ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no inactive port in port channels. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if there is no inactive ports in port-channels in particular \"success\" if there is no port-channel * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_portchannels\" ) try : response = device . session . runCmds ( 1 , [ \"show port-channel\" ], \"json\" ) po_with_invactive_ports = { portchannel : { \"inactivePorts\" : portchannel_dict [ \"inactivePorts\" ]} for portchannel , portchannel_dict in response [ 0 ][ \"portChannels\" ] . items () if len ( portchannel_dict [ \"inactivePorts\" ]) != 0 } if len ( po_with_invactive_ports ) == 0 : result . is_success () else : result . is_failure ( f \"The following port-channels have inactive port(s): { po_with_invactive_ports } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result verify_spanning_tree_blocked_ports ( device ) \u00b6 Verifies there is no spanning-tree blocked ports. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if there is no spanning-tree blocked ports TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 def verify_spanning_tree_blocked_ports ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no spanning-tree blocked ports. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if there is no spanning-tree blocked ports * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_spanning_tree_blocked_ports\" ) try : response = device . session . runCmds ( 1 , [ \"show spanning-tree blockedports\" ], \"json\" ) if len ( response [ 0 ][ \"spanningTreeInstances\" ]) == 0 : result . is_success () else : result . is_failure () # TODO: a bit lazy would need a real output for this result . messages . append ( f \"The following ports are spanning-tree blocked { response [ 0 ][ 'spanningTreeInstances' ] } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result verify_storm_control_drops ( device ) \u00b6 Verifies the device did not drop packets due its to storm-control configuration. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if the device did not drop packet due to its storm-control configuration. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def verify_storm_control_drops ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the device did not drop packets due its to storm-control configuration. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if the device did not drop packet due to its storm-control configuration. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_storm_control_drops\" ) try : response = device . session . runCmds ( 1 , [ \"show storm-control\" ], \"json\" ) storm_controlled_interfaces : Dict [ str , Dict [ str , Any ]] = {} for interface , interface_dict in response [ 0 ][ \"interfaces\" ] . items (): for traffic_type , traffic_type_dict in interface_dict [ \"trafficTypes\" ]: if \"drop\" in traffic_type_dict and traffic_type_dict [ \"drop\" ] != 0 : storm_controlled_interface_dict = ( storm_controlled_interfaces . setdefault ( interface , {}) ) storm_controlled_interface_dict . update ( { traffic_type : traffic_type_dict [ \"drop\" ]} ) if len ( storm_controlled_interfaces ) == 0 : result . is_success () else : result . is_failure ( f \"The following interfaces have none 0 storm-control drop counters { storm_controlled_interfaces } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result verify_svi ( device ) \u00b6 Verifies there is no interface vlan down. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if no SVI is down TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 def verify_svi ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no interface vlan down. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if no SVI is down * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_svi\" ) try : response = device . session . runCmds ( 1 , [ \"show ip interface brief\" ], \"json\" ) down_svis = [] for interface in response [ 0 ][ \"interfaceDescriptions\" ]: interface_dict = response [ 0 ][ \"interfaceDescriptions\" ][ interface ] if \"Vlan\" in interface : if not ( interface_dict [ \"lineProtocolStatus\" ] == \"up\" and interface_dict [ \"interfaceStatus\" ] == \"up\" ): down_svis . append ( interface ) if len ( down_svis ) == 0 : result . is_success () else : result . is_failure ( f \"The following SVIs are not up: { down_svis } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result","title":"Interfaces"},{"location":"api/tests.interfaces/#anta-catalog-for-interfaces-tests","text":"Test functions related to the device interfaces","title":"ANTA catalog for interfaces tests"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_illegal_lacp","text":"Verifies there is no illegal LACP packets received. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if there is no illegal LACP packets received. in particular \u201csuccess\u201d if there is no port-channel TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 def verify_illegal_lacp ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no illegal LACP packets received. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if there is no illegal LACP packets received. in particular \"success\" if there is no port-channel * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_illegal_lacp\" ) try : response = device . session . runCmds ( 1 , [ \"show lacp counters all-ports\" ], \"json\" ) po_with_illegal_lacp = { portchannel : [ interface for interface , interface_dict in portchannel_dict [ \"interfaces\" ] . items () if interface_dict [ \"illegalRxCount\" ] != 0 ] for portchannel , portchannel_dict in response [ 0 ][ \"portChannels\" ] . items () } if len ( po_with_illegal_lacp ) == 0 : result . is_success () else : result . is_failure ( \"The following port-channels have recieved illegal lacp packets on the \" f \"following ports: { po_with_illegal_lacp } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result","title":"verify_illegal_lacp()"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_interface_discards","text":"Verifies interfaces packet discard counters are equal to zero. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if interfaces discard counters are equal to zero. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def verify_interface_discards ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies interfaces packet discard counters are equal to zero. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if interfaces discard counters are equal to zero. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_interface_discards\" ) try : response = device . session . runCmds ( 1 , [ \"show interfaces counters discards\" ], \"json\" ) wrong_interfaces = { interface : { counter : value for counter , value in outer_v . items if value > 0 } for interface , outer_v in response [ 0 ][ \"interfaces\" ] } if len ( wrong_interfaces ) == 0 : result . is_success () else : result . is_failure ( f \"The following interfaces have non 0 discard counter(s): { wrong_interfaces } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result","title":"verify_interface_discards()"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_interface_errdisabled","text":"Verifies there is no interface in error disable state. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if no interface is in error disable state. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def verify_interface_errdisabled ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no interface in error disable state. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if no interface is in error disable state. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_interface_errdisabled\" ) try : response = device . session . runCmds ( 1 , [ \"show interfaces status\" ], \"json\" ) errdisabled_interfaces = [ interface for interface , value in response [ 0 ][ \"interfaceStatuses\" ] . items () if value [ \"linkStatus\" ] == \"errdisabled\" ] if len ( errdisabled_interfaces ) == 0 : result . is_success () else : result . is_failure ( f \"The following interfaces are in error disabled state: { errdisabled_interfaces } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result","title":"verify_interface_errdisabled()"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_interface_errors","text":"Verifies interfaces error counters are equal to zero. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if interfaces error counters are equal to zero. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def verify_interface_errors ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies interfaces error counters are equal to zero. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if interfaces error counters are equal to zero. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_interface_errors\" ) try : response = device . session . runCmds ( 1 , [ \"show interfaces counters errors\" ], \"json\" ) wrong_interfaces = { interface : { counter : value for counter , value in outer_v . items if value > 0 } for interface , outer_v in response [ 0 ][ \"interfaceErrorCounters\" ] } if len ( wrong_interfaces ) == 0 : result . is_success () else : result . is_failure ( f \"The following interfaces have non 0 error counter(s): { wrong_interfaces } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result","title":"verify_interface_errors()"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_interface_utilization","text":"Verifies interfaces utilization is below 75%. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if interfaces utilization is below 75% TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def verify_interface_utilization ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies interfaces utilization is below 75%. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if interfaces utilization is below 75% * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_interface_utilization\" ) try : # TODO make it JSON - bad news it seems percentages are not in the json payload response = device . session . runCmds ( 1 , [ \"show interfaces counters rates\" ], \"text\" ) wrong_interfaces = {} for line in response [ 0 ][ \"output\" ] . split ( \" \\n \" )[ 1 :]: if len ( line ) > 0 : if line . split ()[ - 5 ] == \"-\" or line . split ()[ - 2 ] == \"-\" : pass elif float ( line . split ()[ - 5 ] . replace ( \"%\" , \"\" )) > 75.0 : wrong_interfaces [ line . split ()[ 0 ]] = line . split ()[ - 5 ] elif float ( line . split ()[ - 2 ] . replace ( \"%\" , \"\" )) > 75.0 : wrong_interfaces [ line . split ()[ 0 ]] = line . split ()[ - 2 ] if len ( wrong_interfaces ) == 0 : result . is_success () else : result . is_failure ( f \"The following interfaces have a usage > 75%: { wrong_interfaces } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result","title":"verify_interface_utilization()"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_interfaces_status","text":"Verifies the number of Ethernet interfaces up/up on the device is higher or equal than a value. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required minimum int Expected minimum number of Ethernet interfaces up/up None Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the minimum parameter is missing TestResult result = \u201csuccess\u201d if the number of Ethernet interface up/up is >= minimum TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def verify_interfaces_status ( device : InventoryDevice , minimum : int = None ) -> TestResult : \"\"\" Verifies the number of Ethernet interfaces up/up on the device is higher or equal than a value. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. minimum (int): Expected minimum number of Ethernet interfaces up/up Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the `minimum` parameter is missing * result = \"success\" if the number of Ethernet interface up/up is >= minimum * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_interfaces_status\" ) if not minimum : result . result = \"skipped\" result . messages . append ( \"verify_interfaces_status was not run as no minimum value was given.\" ) return result try : response = device . session . runCmds ( 1 , [ \"show interfaces description\" ], \"json\" ) count_up_up = 0 other_ethernet_interfaces = [] for interface in response [ 0 ][ \"interfaceDescriptions\" ]: interface_dict = response [ 0 ][ \"interfaceDescriptions\" ][ interface ] if \"Ethernet\" in interface : if ( interface_dict [ \"lineProtocolStatus\" ] == \"up\" and interface_dict [ \"interfaceStatus\" ] == \"up\" ): count_up_up += 1 else : other_ethernet_interfaces . append ( interface ) if count_up_up >= minimum : result . is_success () else : result . is_failure ( f \"Only { count_up_up } , less than { minimum } Ethernet interfaces are UP/UP\" ) result . messages . append ( f \"The following Ethernet interfaces are not UP/UP: { other_ethernet_interfaces } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result","title":"verify_interfaces_status()"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_loopback_count","text":"Verifies the number of loopback interfaces on the device is the one we expect. And if none of the loopback is down. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required number int Expected number of loopback interfaces. None Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if the number of loopback is equal to number and if none of the loopback is down TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 def verify_loopback_count ( device : InventoryDevice , number : int = None ) -> TestResult : \"\"\" Verifies the number of loopback interfaces on the device is the one we expect. And if none of the loopback is down. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. number (int): Expected number of loopback interfaces. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if the number of loopback is equal to `number` and if none of the loopback is down * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_loopback_count\" ) if not number : result . is_skipped ( \"verify_loopback_count was not run as no number value was given.\" ) return result try : response = device . session . runCmds ( 1 , [ \"show ip interface brief \" ], \"json\" ) loopback_count = 0 down_loopback_interfaces = [] for interface in response [ 0 ][ \"interfaceDescriptions\" ]: interface_dict = response [ 0 ][ \"interfaceDescriptions\" ][ interface ] if \"Loopback\" in interface : loopback_count += 1 if not ( interface_dict [ \"lineProtocolStatus\" ] == \"up\" and interface_dict [ \"interfaceStatus\" ] == \"up\" ): down_loopback_interfaces . append ( interface ) if loopback_count == number and len ( down_loopback_interfaces ) == 0 : result . is_success () else : result . is_failure () if loopback_count != number : result . is_failure ( f \"Found { loopback_count } Loopbacks when expecting { number } \" ) elif len ( down_loopback_interfaces ) != 0 : result . is_failure ( f \"The following Loopbacks are not up: { down_loopback_interfaces } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result","title":"verify_loopback_count()"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_portchannels","text":"Verifies there is no inactive port in port channels. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if there is no inactive ports in port-channels in particular \u201csuccess\u201d if there is no port-channel TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 def verify_portchannels ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no inactive port in port channels. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if there is no inactive ports in port-channels in particular \"success\" if there is no port-channel * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_portchannels\" ) try : response = device . session . runCmds ( 1 , [ \"show port-channel\" ], \"json\" ) po_with_invactive_ports = { portchannel : { \"inactivePorts\" : portchannel_dict [ \"inactivePorts\" ]} for portchannel , portchannel_dict in response [ 0 ][ \"portChannels\" ] . items () if len ( portchannel_dict [ \"inactivePorts\" ]) != 0 } if len ( po_with_invactive_ports ) == 0 : result . is_success () else : result . is_failure ( f \"The following port-channels have inactive port(s): { po_with_invactive_ports } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result","title":"verify_portchannels()"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_spanning_tree_blocked_ports","text":"Verifies there is no spanning-tree blocked ports. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if there is no spanning-tree blocked ports TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 def verify_spanning_tree_blocked_ports ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no spanning-tree blocked ports. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if there is no spanning-tree blocked ports * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_spanning_tree_blocked_ports\" ) try : response = device . session . runCmds ( 1 , [ \"show spanning-tree blockedports\" ], \"json\" ) if len ( response [ 0 ][ \"spanningTreeInstances\" ]) == 0 : result . is_success () else : result . is_failure () # TODO: a bit lazy would need a real output for this result . messages . append ( f \"The following ports are spanning-tree blocked { response [ 0 ][ 'spanningTreeInstances' ] } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result","title":"verify_spanning_tree_blocked_ports()"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_storm_control_drops","text":"Verifies the device did not drop packets due its to storm-control configuration. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if the device did not drop packet due to its storm-control configuration. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def verify_storm_control_drops ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the device did not drop packets due its to storm-control configuration. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if the device did not drop packet due to its storm-control configuration. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_storm_control_drops\" ) try : response = device . session . runCmds ( 1 , [ \"show storm-control\" ], \"json\" ) storm_controlled_interfaces : Dict [ str , Dict [ str , Any ]] = {} for interface , interface_dict in response [ 0 ][ \"interfaces\" ] . items (): for traffic_type , traffic_type_dict in interface_dict [ \"trafficTypes\" ]: if \"drop\" in traffic_type_dict and traffic_type_dict [ \"drop\" ] != 0 : storm_controlled_interface_dict = ( storm_controlled_interfaces . setdefault ( interface , {}) ) storm_controlled_interface_dict . update ( { traffic_type : traffic_type_dict [ \"drop\" ]} ) if len ( storm_controlled_interfaces ) == 0 : result . is_success () else : result . is_failure ( f \"The following interfaces have none 0 storm-control drop counters { storm_controlled_interfaces } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result","title":"verify_storm_control_drops()"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_svi","text":"Verifies there is no interface vlan down. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if no SVI is down TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/interfaces.py 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 def verify_svi ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no interface vlan down. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if no SVI is down * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" result = TestResult ( host = str ( device . host ), test = \"verify_svi\" ) try : response = device . session . runCmds ( 1 , [ \"show ip interface brief\" ], \"json\" ) down_svis = [] for interface in response [ 0 ][ \"interfaceDescriptions\" ]: interface_dict = response [ 0 ][ \"interfaceDescriptions\" ][ interface ] if \"Vlan\" in interface : if not ( interface_dict [ \"lineProtocolStatus\" ] == \"up\" and interface_dict [ \"interfaceStatus\" ] == \"up\" ): down_svis . append ( interface ) if len ( down_svis ) == 0 : result . is_success () else : result . is_failure ( f \"The following SVIs are not up: { down_svis } \" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result","title":"verify_svi()"},{"location":"api/tests/","text":"ANTA Tests landing page \u00b6 This section describes all the available tests provided by ANTA package. Configuration Hardware interfaces MLAG Multicast Profiles System Software Routing Generic Routing BGP Routing OSPF Al these tests can be imported in a catalog to be used by check-devices.py script.","title":"Overview"},{"location":"api/tests/#anta-tests-landing-page","text":"This section describes all the available tests provided by ANTA package. Configuration Hardware interfaces MLAG Multicast Profiles System Software Routing Generic Routing BGP Routing OSPF Al these tests can be imported in a catalog to be used by check-devices.py script.","title":"ANTA Tests landing page"},{"location":"api/tests.mlag/","text":"ANTA catalog for mlag tests \u00b6 Test functions related to Multi-Chassis LAG verify_mlag_config_sanity ( device ) \u00b6 Verifies there is no MLAG config-sanity inconsistencies. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if there is no MLAG config-sanity inconsistencies TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/mlag.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def verify_mlag_config_sanity ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no MLAG config-sanity inconsistencies. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if there is no MLAG config-sanity inconsistencies * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show mlag config-sanity\" ], \"json\" ) if \"mlagActive\" not in response [ 0 ] . keys (): result . is_error ( 'incorrect JSON response' ) elif response [ 0 ][ \"mlagActive\" ] is False : # MLAG is not running result . is_skipped ( \"MLAG is disabled\" ) elif ( len ( response [ 0 ][ \"globalConfiguration\" ]) > 0 or len ( response [ 0 ][ \"interfaceConfiguration\" ]) > 0 ): result . is_failure () if len ( response [ 0 ][ \"globalConfiguration\" ]) > 0 : result . is_failure ( \"MLAG config-sanity returned some Global inconsistencies: \" f \" { response [ 0 ][ 'response' ][ 'globalConfiguration' ] } \" ) if len ( response [ 0 ][ \"interfaceConfiguration\" ]) > 0 : result . is_failure ( \"MLAG config-sanity returned some Interface inconsistencies: \" f \" { response [ 0 ][ 'response' ][ 'interfaceConfiguration' ] } \" ) else : result . is_success () except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result verify_mlag_interfaces ( device ) \u00b6 Verifies there is no inactive or active-partial MLAG interfaces. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if there is no inactive or active-partial MLAG interfaces. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/mlag.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def verify_mlag_interfaces ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no inactive or active-partial MLAG interfaces. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if there is no inactive or active-partial MLAG interfaces. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show mlag\" ], \"json\" ) if response [ 0 ][ \"state\" ] == \"disabled\" : result . is_skipped ( \"MLAG is disabled\" ) elif ( response [ 0 ][ \"mlagPorts\" ][ \"Inactive\" ] != 0 or response [ 0 ][ \"mlagPorts\" ][ \"Active-partial\" ] != 0 ): result . is_failure ( f \"MLAG status is not OK: { response [ 0 ][ 'mlagPorts' ] } \" ) else : result . is_success () except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result verify_mlag_status ( device ) \u00b6 Verifies the MLAG status: state is active, negotiation status is connected, local int is up, peer link is up. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if the MLAG status is OK TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/mlag.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def verify_mlag_status ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the MLAG status: state is active, negotiation status is connected, local int is up, peer link is up. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if the MLAG status is OK * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show mlag\" ], \"json\" ) if response [ 0 ][ \"state\" ] == \"disabled\" : result . is_skipped ( \"MLAG is disabled\" ) elif ( response [ 0 ][ \"state\" ] != \"active\" or response [ 0 ][ \"negStatus\" ] != \"connected\" or response [ 0 ][ \"localIntfStatus\" ] != \"up\" or response [ 0 ][ \"peerLinkStatus\" ] != \"up\" ): result . is_failure ( f \"MLAG status is not OK: { response [ 0 ] } \" ) else : result . is_success () except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"MLAG"},{"location":"api/tests.mlag/#anta-catalog-for-mlag-tests","text":"Test functions related to Multi-Chassis LAG","title":"ANTA catalog for mlag tests"},{"location":"api/tests.mlag/#anta.tests.mlag.verify_mlag_config_sanity","text":"Verifies there is no MLAG config-sanity inconsistencies. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if there is no MLAG config-sanity inconsistencies TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/mlag.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def verify_mlag_config_sanity ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no MLAG config-sanity inconsistencies. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if there is no MLAG config-sanity inconsistencies * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show mlag config-sanity\" ], \"json\" ) if \"mlagActive\" not in response [ 0 ] . keys (): result . is_error ( 'incorrect JSON response' ) elif response [ 0 ][ \"mlagActive\" ] is False : # MLAG is not running result . is_skipped ( \"MLAG is disabled\" ) elif ( len ( response [ 0 ][ \"globalConfiguration\" ]) > 0 or len ( response [ 0 ][ \"interfaceConfiguration\" ]) > 0 ): result . is_failure () if len ( response [ 0 ][ \"globalConfiguration\" ]) > 0 : result . is_failure ( \"MLAG config-sanity returned some Global inconsistencies: \" f \" { response [ 0 ][ 'response' ][ 'globalConfiguration' ] } \" ) if len ( response [ 0 ][ \"interfaceConfiguration\" ]) > 0 : result . is_failure ( \"MLAG config-sanity returned some Interface inconsistencies: \" f \" { response [ 0 ][ 'response' ][ 'interfaceConfiguration' ] } \" ) else : result . is_success () except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_mlag_config_sanity()"},{"location":"api/tests.mlag/#anta.tests.mlag.verify_mlag_interfaces","text":"Verifies there is no inactive or active-partial MLAG interfaces. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if there is no inactive or active-partial MLAG interfaces. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/mlag.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def verify_mlag_interfaces ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no inactive or active-partial MLAG interfaces. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if there is no inactive or active-partial MLAG interfaces. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show mlag\" ], \"json\" ) if response [ 0 ][ \"state\" ] == \"disabled\" : result . is_skipped ( \"MLAG is disabled\" ) elif ( response [ 0 ][ \"mlagPorts\" ][ \"Inactive\" ] != 0 or response [ 0 ][ \"mlagPorts\" ][ \"Active-partial\" ] != 0 ): result . is_failure ( f \"MLAG status is not OK: { response [ 0 ][ 'mlagPorts' ] } \" ) else : result . is_success () except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_mlag_interfaces()"},{"location":"api/tests.mlag/#anta.tests.mlag.verify_mlag_status","text":"Verifies the MLAG status: state is active, negotiation status is connected, local int is up, peer link is up. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if the MLAG status is OK TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/mlag.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def verify_mlag_status ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the MLAG status: state is active, negotiation status is connected, local int is up, peer link is up. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if the MLAG status is OK * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show mlag\" ], \"json\" ) if response [ 0 ][ \"state\" ] == \"disabled\" : result . is_skipped ( \"MLAG is disabled\" ) elif ( response [ 0 ][ \"state\" ] != \"active\" or response [ 0 ][ \"negStatus\" ] != \"connected\" or response [ 0 ][ \"localIntfStatus\" ] != \"up\" or response [ 0 ][ \"peerLinkStatus\" ] != \"up\" ): result . is_failure ( f \"MLAG status is not OK: { response [ 0 ] } \" ) else : result . is_success () except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_mlag_status()"},{"location":"api/tests.multicast/","text":"ANTA catalog for multicast tests \u00b6 Test functions related to multicast verify_igmp_snooping_global ( device , configuration ) \u00b6 Verifies the IGMP snooping global configuration. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required configuration str Expected global IGMP snooping configuration (enabled or disabled). required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the configuration parameter was missing TestResult result = \u201csuccess\u201d if IGMP snooping is globally configured TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/multicast.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def verify_igmp_snooping_global ( device : InventoryDevice , configuration : str ) -> TestResult : \"\"\" Verifies the IGMP snooping global configuration. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. configuration (str): Expected global IGMP snooping configuration (enabled or disabled). Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the `configuration` parameter was missing * result = \"success\" if IGMP snooping is globally configured * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not configuration : result . is_skipped ( \"verify_igmp_snooping_global was not run as no configuration was given\" ) return result try : response = device . session . runCmds ( 1 , [ \"show ip igmp snooping\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) igmp_state = response [ 0 ][ \"igmpSnoopingState\" ] if igmp_state == configuration : result . is_success () else : result . is_failure ( f \"IGMP state is not valid: { igmp_state } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result verify_igmp_snooping_vlans ( device , vlans , configuration ) \u00b6 Verifies the IGMP snooping configuration for some VLANs. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required vlans List [ str ] A list of VLANs required configuration str Expected IGMP snooping configuration (enabled or disabled) for these VLANs. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if IGMP snooping is configured on these vlans TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/multicast.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def verify_igmp_snooping_vlans ( device : InventoryDevice , vlans : List [ str ], configuration : str ) -> TestResult : \"\"\" Verifies the IGMP snooping configuration for some VLANs. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. vlans (List[str]): A list of VLANs configuration (str): Expected IGMP snooping configuration (enabled or disabled) for these VLANs. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if IGMP snooping is configured on these vlans * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not vlans or not configuration : result . result = \"skipped\" result . messages . append ( \"verify_igmp_snooping_vlans was not run as no \" \"vlans or configuration was given\" ) return result try : response = device . session . runCmds ( 1 , [ \"show ip igmp snooping\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) result . is_success () for vlan in vlans : if vlan not in response [ 0 ][ \"vlans\" ]: result . is_failure ( f \"Supplied vlan { vlan } is not present on the device.\" ) continue igmp_state = response [ 0 ][ \"vlans\" ][ str ( vlan )][ \"igmpSnoopingState\" ] if igmp_state != configuration : result . is_failure () result . messages . append ( f \"IGMP state for vlan { vlan } is { igmp_state } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result","title":"Multicast"},{"location":"api/tests.multicast/#anta-catalog-for-multicast-tests","text":"Test functions related to multicast","title":"ANTA catalog for multicast tests"},{"location":"api/tests.multicast/#anta.tests.multicast.verify_igmp_snooping_global","text":"Verifies the IGMP snooping global configuration. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required configuration str Expected global IGMP snooping configuration (enabled or disabled). required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the configuration parameter was missing TestResult result = \u201csuccess\u201d if IGMP snooping is globally configured TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/multicast.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def verify_igmp_snooping_global ( device : InventoryDevice , configuration : str ) -> TestResult : \"\"\" Verifies the IGMP snooping global configuration. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. configuration (str): Expected global IGMP snooping configuration (enabled or disabled). Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the `configuration` parameter was missing * result = \"success\" if IGMP snooping is globally configured * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not configuration : result . is_skipped ( \"verify_igmp_snooping_global was not run as no configuration was given\" ) return result try : response = device . session . runCmds ( 1 , [ \"show ip igmp snooping\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) igmp_state = response [ 0 ][ \"igmpSnoopingState\" ] if igmp_state == configuration : result . is_success () else : result . is_failure ( f \"IGMP state is not valid: { igmp_state } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result","title":"verify_igmp_snooping_global()"},{"location":"api/tests.multicast/#anta.tests.multicast.verify_igmp_snooping_vlans","text":"Verifies the IGMP snooping configuration for some VLANs. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required vlans List [ str ] A list of VLANs required configuration str Expected IGMP snooping configuration (enabled or disabled) for these VLANs. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if IGMP snooping is configured on these vlans TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/multicast.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def verify_igmp_snooping_vlans ( device : InventoryDevice , vlans : List [ str ], configuration : str ) -> TestResult : \"\"\" Verifies the IGMP snooping configuration for some VLANs. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. vlans (List[str]): A list of VLANs configuration (str): Expected IGMP snooping configuration (enabled or disabled) for these VLANs. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if IGMP snooping is configured on these vlans * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not vlans or not configuration : result . result = \"skipped\" result . messages . append ( \"verify_igmp_snooping_vlans was not run as no \" \"vlans or configuration was given\" ) return result try : response = device . session . runCmds ( 1 , [ \"show ip igmp snooping\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) result . is_success () for vlan in vlans : if vlan not in response [ 0 ][ \"vlans\" ]: result . is_failure ( f \"Supplied vlan { vlan } is not present on the device.\" ) continue igmp_state = response [ 0 ][ \"vlans\" ][ str ( vlan )][ \"igmpSnoopingState\" ] if igmp_state != configuration : result . is_failure () result . messages . append ( f \"IGMP state for vlan { vlan } is { igmp_state } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result","title":"verify_igmp_snooping_vlans()"},{"location":"api/tests.profiles/","text":"ANTA catalog for profiles tests \u00b6 Test functions related to ASIC profiles verify_tcam_profile ( device , profile ) \u00b6 Verifies the configured TCAM profile is the expected one. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required profile str The expected TCAM profile.0 required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cmode\u201d if the profile parameter is missing TestResult result = \u201csuccess\u201d if TCAM profile is correct TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/profiles.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 @skip_on_platforms ([ \"cEOSLab\" , \"VEOS-LAB\" ]) def verify_tcam_profile ( device : InventoryDevice , profile : str ) -> TestResult : \"\"\" Verifies the configured TCAM profile is the expected one. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. profile (str): The expected TCAM profile.0 Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"mode\" if the `profile` parameter is missing * result = \"success\" if TCAM profile is correct * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not profile : result . is_skipped ( \"verify_tcam_profile was not run as no profile was given\" ) return result try : response = device . session . runCmds ( 1 , [ \"show hardware tcam profile\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) if ( response [ 0 ][ \"pmfProfiles\" ][ \"FixedSystem\" ][ \"status\" ] == response [ 0 ][ \"pmfProfiles\" ][ \"FixedSystem\" ][ \"config\" ] ) and ( response [ 0 ][ \"pmfProfiles\" ][ \"FixedSystem\" ][ \"status\" ] == profile ): result . is_success () else : result . is_failure ( f 'Incorrect profile configured on device: { response [ 0 ][ \"pmfProfiles\" ][ \"FixedSystem\" ][ \"status\" ] } ' ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { e . __class__ . __name__ } - { str ( e ) } ' ) result . is_error ( str ( e )) return result verify_unified_forwarding_table_mode ( device , mode ) \u00b6 Verifies the device is using the expected Unified Forwarding Table mode. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required mode str The expected Unified Forwarding Table mode. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cmode\u201d if the mode parameter is missing TestResult result = \u201csuccess\u201d if UFT mode is correct TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/profiles.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @skip_on_platforms ([ \"cEOSLab\" , \"VEOS-LAB\" ]) def verify_unified_forwarding_table_mode ( device : InventoryDevice , mode : str ) -> TestResult : \"\"\" Verifies the device is using the expected Unified Forwarding Table mode. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. mode (str): The expected Unified Forwarding Table mode. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"mode\" if the `mode` parameter is missing * result = \"success\" if UFT mode is correct * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not mode : result . is_skipped ( \"verify_unified_forwarding_table_mode was not run as no mode was given\" ) return result try : response = device . session . runCmds ( 1 , [ \"show platform trident forwarding-table partition\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) response_data = response [ 0 ][ \"uftMode\" ] if response_data == mode : result . is_success () else : result . is_failure ( f \"device is not running correct UFT mode (expected: { mode } / running: { response_data } )\" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"Profiles"},{"location":"api/tests.profiles/#anta-catalog-for-profiles-tests","text":"Test functions related to ASIC profiles","title":"ANTA catalog for profiles tests"},{"location":"api/tests.profiles/#anta.tests.profiles.verify_tcam_profile","text":"Verifies the configured TCAM profile is the expected one. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required profile str The expected TCAM profile.0 required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cmode\u201d if the profile parameter is missing TestResult result = \u201csuccess\u201d if TCAM profile is correct TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/profiles.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 @skip_on_platforms ([ \"cEOSLab\" , \"VEOS-LAB\" ]) def verify_tcam_profile ( device : InventoryDevice , profile : str ) -> TestResult : \"\"\" Verifies the configured TCAM profile is the expected one. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. profile (str): The expected TCAM profile.0 Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"mode\" if the `profile` parameter is missing * result = \"success\" if TCAM profile is correct * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not profile : result . is_skipped ( \"verify_tcam_profile was not run as no profile was given\" ) return result try : response = device . session . runCmds ( 1 , [ \"show hardware tcam profile\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) if ( response [ 0 ][ \"pmfProfiles\" ][ \"FixedSystem\" ][ \"status\" ] == response [ 0 ][ \"pmfProfiles\" ][ \"FixedSystem\" ][ \"config\" ] ) and ( response [ 0 ][ \"pmfProfiles\" ][ \"FixedSystem\" ][ \"status\" ] == profile ): result . is_success () else : result . is_failure ( f 'Incorrect profile configured on device: { response [ 0 ][ \"pmfProfiles\" ][ \"FixedSystem\" ][ \"status\" ] } ' ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { e . __class__ . __name__ } - { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_tcam_profile()"},{"location":"api/tests.profiles/#anta.tests.profiles.verify_unified_forwarding_table_mode","text":"Verifies the device is using the expected Unified Forwarding Table mode. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required mode str The expected Unified Forwarding Table mode. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cmode\u201d if the mode parameter is missing TestResult result = \u201csuccess\u201d if UFT mode is correct TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/profiles.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @skip_on_platforms ([ \"cEOSLab\" , \"VEOS-LAB\" ]) def verify_unified_forwarding_table_mode ( device : InventoryDevice , mode : str ) -> TestResult : \"\"\" Verifies the device is using the expected Unified Forwarding Table mode. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. mode (str): The expected Unified Forwarding Table mode. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"mode\" if the `mode` parameter is missing * result = \"success\" if UFT mode is correct * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not mode : result . is_skipped ( \"verify_unified_forwarding_table_mode was not run as no mode was given\" ) return result try : response = device . session . runCmds ( 1 , [ \"show platform trident forwarding-table partition\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) response_data = response [ 0 ][ \"uftMode\" ] if response_data == mode : result . is_success () else : result . is_failure ( f \"device is not running correct UFT mode (expected: { mode } / running: { response_data } )\" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_unified_forwarding_table_mode()"},{"location":"api/tests.routing.bgp/","text":"ANTA catalog for routing-bgp tests \u00b6 BGP test functions verify_bgp_evpn_count ( device , number ) \u00b6 Verifies all EVPN BGP sessions are established (default VRF) and the actual number of BGP EVPN neighbors is the one we expect (default VRF). Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required number int The expected number of BGP EVPN neighbors in the default VRF. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the number parameter is missing TestResult result = \u201csuccess\u201d if all EVPN BGP sessions are Established and if the actual number of BGP EVPN neighbors is the one we expect. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/bgp.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 @check_bgp_family_enable ( \"evpn\" ) def verify_bgp_evpn_count ( device : InventoryDevice , number : int ) -> TestResult : \"\"\" Verifies all EVPN BGP sessions are established (default VRF) and the actual number of BGP EVPN neighbors is the one we expect (default VRF). Args: device (InventoryDevice): InventoryDevice instance containing all devices information. number (int): The expected number of BGP EVPN neighbors in the default VRF. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the `number` parameter is missing * result = \"success\" if all EVPN BGP sessions are Established and if the actual number of BGP EVPN neighbors is the one we expect. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not number : result . is_skipped ( \"verify_bgp_evpn_count could not run because number was not supplied.\" ) return result try : response = device . session . runCmds ( 1 , [ \"show bgp evpn summary\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) peers = response [ 0 ][ \"vrfs\" ][ \"default\" ][ \"peers\" ] if len ( peers ) == number : result . is_success () else : result . is_failure () if len ( peers ) != number : result . messages . append ( f \"Expecting { number } BGP EVPN peers and got { len ( peers ) } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result verify_bgp_evpn_state ( device ) \u00b6 Verifies all EVPN BGP sessions are established (default VRF). Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if no BGP EVPN peers are returned by the device TestResult result = \u201csuccess\u201d if all EVPN BGP sessions are established. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/bgp.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 @check_bgp_family_enable ( \"evpn\" ) def verify_bgp_evpn_state ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies all EVPN BGP sessions are established (default VRF). Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if no BGP EVPN peers are returned by the device * result = \"success\" if all EVPN BGP sessions are established. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show bgp evpn summary\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) bgp_vrfs = response [ 0 ][ \"vrfs\" ] peers = bgp_vrfs [ \"default\" ][ \"peers\" ] non_established_peers = [ peer for peer , peer_dict in peers . items () if peer_dict [ \"peerState\" ] != \"Established\" ] if not non_established_peers : result . is_success () else : result . is_failure ( f \"The following EVPN peers are not established: { non_established_peers } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result verify_bgp_ipv4_unicast_count ( device , number , vrf = 'default' ) \u00b6 Verifies all IPv4 unicast BGP sessions are established and all BGP messages queues for these sessions are empty and the actual number of BGP IPv4 unicast neighbors is the one we expect. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required number int Expected number of BGP IPv4 unicast neighbors required vrf(str) VRF to verify. default is \u201cdefault\u201d. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the number or vrf parameter is missing TestResult result = \u201csuccess\u201d if all IPv4 unicast BGP sessions are established and if all BGP messages queues for these sessions are empty and if the actual number of BGP IPv4 unicast neighbors is equal to `number. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/bgp.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 @check_bgp_family_enable ( \"ipv4\" ) def verify_bgp_ipv4_unicast_count ( device : InventoryDevice , number : int , vrf : str = \"default\" ) -> TestResult : \"\"\" Verifies all IPv4 unicast BGP sessions are established and all BGP messages queues for these sessions are empty and the actual number of BGP IPv4 unicast neighbors is the one we expect. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. number (int): Expected number of BGP IPv4 unicast neighbors vrf(str): VRF to verify. default is \"default\". Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the `number` or `vrf` parameter is missing * result = \"success\" if all IPv4 unicast BGP sessions are established and if all BGP messages queues for these sessions are empty and if the actual number of BGP IPv4 unicast neighbors is equal to `number. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not number or not vrf : result . is_skipped ( \"verify_bgp_ipv4_unicast_count could not run because number of vrf was not supplied\" ) return result try : response = device . session . runCmds ( 1 , [ f \"show bgp ipv4 unicast summary vrf { vrf } \" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) bgp_vrfs = response [ 0 ][ \"vrfs\" ] peer_state_issue = {} peer_number = len ( bgp_vrfs [ vrf ][ \"peers\" ]) for peer in bgp_vrfs [ vrf ][ \"peers\" ]: if ( ( bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"peerState\" ] != \"Established\" ) or ( bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"inMsgQueue\" ] != 0 ) or ( bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"outMsgQueue\" ] != 0 ) ): peer_state_issue [ peer ] = { \"peerState\" : bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"peerState\" ], \"inMsgQueue\" : bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"inMsgQueue\" ], \"outMsgQueue\" : bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"outMsgQueue\" ], } if peer_number == number : result . is_success () else : result . is_failure () if peer_number != number : result . is_failure ( f \"Expecting { number } BGP peer in vrf { vrf } and got { peer_number } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result verify_bgp_ipv4_unicast_state ( device ) \u00b6 Verifies all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if no BGP vrf are returned by the device TestResult result = \u201csuccess\u201d if all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/bgp.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 @check_bgp_family_enable ( \"ipv4\" ) def verify_bgp_ipv4_unicast_state ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if no BGP vrf are returned by the device * result = \"success\" if all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show bgp ipv4 unicast summary vrf all\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) bgp_vrfs = response [ 0 ][ \"vrfs\" ] state_issue : Dict [ str , Any ] = {} for vrf in bgp_vrfs : for peer in bgp_vrfs [ vrf ][ \"peers\" ]: if ( ( bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"peerState\" ] != \"Established\" ) or ( bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"inMsgQueue\" ] != 0 ) or ( bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"outMsgQueue\" ] != 0 ) ): vrf_dict = state_issue . setdefault ( vrf , {}) vrf_dict . update ( { peer : { \"peerState\" : bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"peerState\" ], \"inMsgQueue\" : bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"inMsgQueue\" ], \"outMsgQueue\" : bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"outMsgQueue\" ], } } ) if not state_issue : result . is_success () else : result . is_failure ( f \"Some IPv4 Unicast BGP Peer are not up: { state_issue } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result verify_bgp_ipv6_unicast_state ( device ) \u00b6 Verifies all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if no BGP vrf are returned by the device TestResult result = \u201csuccess\u201d if all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/bgp.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 @check_bgp_family_enable ( \"ipv6\" ) def verify_bgp_ipv6_unicast_state ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if no BGP vrf are returned by the device * result = \"success\" if all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show bgp ipv6 unicast summary vrf all\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) bgp_vrfs = response [ 0 ][ \"vrfs\" ] state_issue : Dict [ str , Any ] = {} for vrf in bgp_vrfs : for peer in bgp_vrfs [ vrf ][ \"peers\" ]: if ( ( bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"peerState\" ] != \"Established\" ) or ( bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"inMsgQueue\" ] != 0 ) or ( bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"outMsgQueue\" ] != 0 ) ): vrf_dict = state_issue . setdefault ( vrf , {}) vrf_dict . update ( { peer : { \"peerState\" : bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"peerState\" ], \"inMsgQueue\" : bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"inMsgQueue\" ], \"outMsgQueue\" : bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"outMsgQueue\" ], } } ) if len ( state_issue ) == 0 : result . is_success () else : result . is_failure ( f \"Some IPv6 Unicast BGP Peer are not up: { state_issue } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result verify_bgp_rtc_count ( device , number ) \u00b6 Verifies all RTC BGP sessions are established (default VRF) and the actual number of BGP RTC neighbors is the one we expect (default VRF). Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required number int The expected number of BGP RTC neighbors (default VRF). required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the number parameter is missing TestResult result = \u201csuccess\u201d if all RTC BGP sessions are established and if the actual number of BGP RTC neighbors is the one we expect. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/bgp.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 @check_bgp_family_enable ( \"rtc\" ) def verify_bgp_rtc_count ( device : InventoryDevice , number : int ) -> TestResult : \"\"\" Verifies all RTC BGP sessions are established (default VRF) and the actual number of BGP RTC neighbors is the one we expect (default VRF). Args: device (InventoryDevice): InventoryDevice instance containing all devices information. number (int): The expected number of BGP RTC neighbors (default VRF). Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the `number` parameter is missing * result = \"success\" if all RTC BGP sessions are established and if the actual number of BGP RTC neighbors is the one we expect. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not number : result . is_skipped ( \"verify_bgp_rtc_count could not run because number was not supplied\" ) return result try : response = device . session . runCmds ( 1 , [ \"show bgp rt-membership summary\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) peers = response [ 0 ][ \"vrfs\" ][ \"default\" ][ \"peers\" ] non_established_peers = [ peer for peer , peer_dict in peers . items () if peer_dict [ \"peerState\" ] != \"Established\" ] if not non_established_peers and len ( peers ) == number : result . is_success () else : result . is_failure () if len ( peers ) != number : result . is_failure ( f \"Expecting { number } BGP RTC peers and got { len ( peers ) } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result verify_bgp_rtc_state ( device ) \u00b6 Verifies all RTC BGP sessions are established (default VRF). Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if no BGP RTC peers are returned by the device TestResult result = \u201csuccess\u201d if all RTC BGP sessions are Established. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/bgp.py 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 @check_bgp_family_enable ( \"rtc\" ) def verify_bgp_rtc_state ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies all RTC BGP sessions are established (default VRF). Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if no BGP RTC peers are returned by the device * result = \"success\" if all RTC BGP sessions are Established. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show bgp rt-membership summary\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) peers = response [ 0 ][ \"vrfs\" ][ \"default\" ][ \"peers\" ] non_established_peers = [ peer for peer , peer_dict in peers . items () if peer_dict [ \"peerState\" ] != \"Established\" ] if not non_established_peers : result . is_success () else : result . is_failure ( f \"The following RTC peers are not established: { non_established_peers } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"BGP"},{"location":"api/tests.routing.bgp/#anta-catalog-for-routing-bgp-tests","text":"BGP test functions","title":"ANTA catalog for routing-bgp tests"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.verify_bgp_evpn_count","text":"Verifies all EVPN BGP sessions are established (default VRF) and the actual number of BGP EVPN neighbors is the one we expect (default VRF). Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required number int The expected number of BGP EVPN neighbors in the default VRF. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the number parameter is missing TestResult result = \u201csuccess\u201d if all EVPN BGP sessions are Established and if the actual number of BGP EVPN neighbors is the one we expect. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/bgp.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 @check_bgp_family_enable ( \"evpn\" ) def verify_bgp_evpn_count ( device : InventoryDevice , number : int ) -> TestResult : \"\"\" Verifies all EVPN BGP sessions are established (default VRF) and the actual number of BGP EVPN neighbors is the one we expect (default VRF). Args: device (InventoryDevice): InventoryDevice instance containing all devices information. number (int): The expected number of BGP EVPN neighbors in the default VRF. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the `number` parameter is missing * result = \"success\" if all EVPN BGP sessions are Established and if the actual number of BGP EVPN neighbors is the one we expect. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not number : result . is_skipped ( \"verify_bgp_evpn_count could not run because number was not supplied.\" ) return result try : response = device . session . runCmds ( 1 , [ \"show bgp evpn summary\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) peers = response [ 0 ][ \"vrfs\" ][ \"default\" ][ \"peers\" ] if len ( peers ) == number : result . is_success () else : result . is_failure () if len ( peers ) != number : result . messages . append ( f \"Expecting { number } BGP EVPN peers and got { len ( peers ) } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_bgp_evpn_count()"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.verify_bgp_evpn_state","text":"Verifies all EVPN BGP sessions are established (default VRF). Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if no BGP EVPN peers are returned by the device TestResult result = \u201csuccess\u201d if all EVPN BGP sessions are established. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/bgp.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 @check_bgp_family_enable ( \"evpn\" ) def verify_bgp_evpn_state ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies all EVPN BGP sessions are established (default VRF). Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if no BGP EVPN peers are returned by the device * result = \"success\" if all EVPN BGP sessions are established. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show bgp evpn summary\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) bgp_vrfs = response [ 0 ][ \"vrfs\" ] peers = bgp_vrfs [ \"default\" ][ \"peers\" ] non_established_peers = [ peer for peer , peer_dict in peers . items () if peer_dict [ \"peerState\" ] != \"Established\" ] if not non_established_peers : result . is_success () else : result . is_failure ( f \"The following EVPN peers are not established: { non_established_peers } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_bgp_evpn_state()"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.verify_bgp_ipv4_unicast_count","text":"Verifies all IPv4 unicast BGP sessions are established and all BGP messages queues for these sessions are empty and the actual number of BGP IPv4 unicast neighbors is the one we expect. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required number int Expected number of BGP IPv4 unicast neighbors required vrf(str) VRF to verify. default is \u201cdefault\u201d. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the number or vrf parameter is missing TestResult result = \u201csuccess\u201d if all IPv4 unicast BGP sessions are established and if all BGP messages queues for these sessions are empty and if the actual number of BGP IPv4 unicast neighbors is equal to `number. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/bgp.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 @check_bgp_family_enable ( \"ipv4\" ) def verify_bgp_ipv4_unicast_count ( device : InventoryDevice , number : int , vrf : str = \"default\" ) -> TestResult : \"\"\" Verifies all IPv4 unicast BGP sessions are established and all BGP messages queues for these sessions are empty and the actual number of BGP IPv4 unicast neighbors is the one we expect. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. number (int): Expected number of BGP IPv4 unicast neighbors vrf(str): VRF to verify. default is \"default\". Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the `number` or `vrf` parameter is missing * result = \"success\" if all IPv4 unicast BGP sessions are established and if all BGP messages queues for these sessions are empty and if the actual number of BGP IPv4 unicast neighbors is equal to `number. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not number or not vrf : result . is_skipped ( \"verify_bgp_ipv4_unicast_count could not run because number of vrf was not supplied\" ) return result try : response = device . session . runCmds ( 1 , [ f \"show bgp ipv4 unicast summary vrf { vrf } \" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) bgp_vrfs = response [ 0 ][ \"vrfs\" ] peer_state_issue = {} peer_number = len ( bgp_vrfs [ vrf ][ \"peers\" ]) for peer in bgp_vrfs [ vrf ][ \"peers\" ]: if ( ( bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"peerState\" ] != \"Established\" ) or ( bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"inMsgQueue\" ] != 0 ) or ( bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"outMsgQueue\" ] != 0 ) ): peer_state_issue [ peer ] = { \"peerState\" : bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"peerState\" ], \"inMsgQueue\" : bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"inMsgQueue\" ], \"outMsgQueue\" : bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"outMsgQueue\" ], } if peer_number == number : result . is_success () else : result . is_failure () if peer_number != number : result . is_failure ( f \"Expecting { number } BGP peer in vrf { vrf } and got { peer_number } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_bgp_ipv4_unicast_count()"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.verify_bgp_ipv4_unicast_state","text":"Verifies all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if no BGP vrf are returned by the device TestResult result = \u201csuccess\u201d if all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/bgp.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 @check_bgp_family_enable ( \"ipv4\" ) def verify_bgp_ipv4_unicast_state ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if no BGP vrf are returned by the device * result = \"success\" if all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show bgp ipv4 unicast summary vrf all\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) bgp_vrfs = response [ 0 ][ \"vrfs\" ] state_issue : Dict [ str , Any ] = {} for vrf in bgp_vrfs : for peer in bgp_vrfs [ vrf ][ \"peers\" ]: if ( ( bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"peerState\" ] != \"Established\" ) or ( bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"inMsgQueue\" ] != 0 ) or ( bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"outMsgQueue\" ] != 0 ) ): vrf_dict = state_issue . setdefault ( vrf , {}) vrf_dict . update ( { peer : { \"peerState\" : bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"peerState\" ], \"inMsgQueue\" : bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"inMsgQueue\" ], \"outMsgQueue\" : bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"outMsgQueue\" ], } } ) if not state_issue : result . is_success () else : result . is_failure ( f \"Some IPv4 Unicast BGP Peer are not up: { state_issue } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_bgp_ipv4_unicast_state()"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.verify_bgp_ipv6_unicast_state","text":"Verifies all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if no BGP vrf are returned by the device TestResult result = \u201csuccess\u201d if all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/bgp.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 @check_bgp_family_enable ( \"ipv6\" ) def verify_bgp_ipv6_unicast_state ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if no BGP vrf are returned by the device * result = \"success\" if all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show bgp ipv6 unicast summary vrf all\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) bgp_vrfs = response [ 0 ][ \"vrfs\" ] state_issue : Dict [ str , Any ] = {} for vrf in bgp_vrfs : for peer in bgp_vrfs [ vrf ][ \"peers\" ]: if ( ( bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"peerState\" ] != \"Established\" ) or ( bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"inMsgQueue\" ] != 0 ) or ( bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"outMsgQueue\" ] != 0 ) ): vrf_dict = state_issue . setdefault ( vrf , {}) vrf_dict . update ( { peer : { \"peerState\" : bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"peerState\" ], \"inMsgQueue\" : bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"inMsgQueue\" ], \"outMsgQueue\" : bgp_vrfs [ vrf ][ \"peers\" ][ peer ][ \"outMsgQueue\" ], } } ) if len ( state_issue ) == 0 : result . is_success () else : result . is_failure ( f \"Some IPv6 Unicast BGP Peer are not up: { state_issue } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_bgp_ipv6_unicast_state()"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.verify_bgp_rtc_count","text":"Verifies all RTC BGP sessions are established (default VRF) and the actual number of BGP RTC neighbors is the one we expect (default VRF). Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required number int The expected number of BGP RTC neighbors (default VRF). required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the number parameter is missing TestResult result = \u201csuccess\u201d if all RTC BGP sessions are established and if the actual number of BGP RTC neighbors is the one we expect. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/bgp.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 @check_bgp_family_enable ( \"rtc\" ) def verify_bgp_rtc_count ( device : InventoryDevice , number : int ) -> TestResult : \"\"\" Verifies all RTC BGP sessions are established (default VRF) and the actual number of BGP RTC neighbors is the one we expect (default VRF). Args: device (InventoryDevice): InventoryDevice instance containing all devices information. number (int): The expected number of BGP RTC neighbors (default VRF). Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the `number` parameter is missing * result = \"success\" if all RTC BGP sessions are established and if the actual number of BGP RTC neighbors is the one we expect. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not number : result . is_skipped ( \"verify_bgp_rtc_count could not run because number was not supplied\" ) return result try : response = device . session . runCmds ( 1 , [ \"show bgp rt-membership summary\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) peers = response [ 0 ][ \"vrfs\" ][ \"default\" ][ \"peers\" ] non_established_peers = [ peer for peer , peer_dict in peers . items () if peer_dict [ \"peerState\" ] != \"Established\" ] if not non_established_peers and len ( peers ) == number : result . is_success () else : result . is_failure () if len ( peers ) != number : result . is_failure ( f \"Expecting { number } BGP RTC peers and got { len ( peers ) } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_bgp_rtc_count()"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.verify_bgp_rtc_state","text":"Verifies all RTC BGP sessions are established (default VRF). Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if no BGP RTC peers are returned by the device TestResult result = \u201csuccess\u201d if all RTC BGP sessions are Established. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/bgp.py 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 @check_bgp_family_enable ( \"rtc\" ) def verify_bgp_rtc_state ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies all RTC BGP sessions are established (default VRF). Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if no BGP RTC peers are returned by the device * result = \"success\" if all RTC BGP sessions are Established. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show bgp rt-membership summary\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) peers = response [ 0 ][ \"vrfs\" ][ \"default\" ][ \"peers\" ] non_established_peers = [ peer for peer , peer_dict in peers . items () if peer_dict [ \"peerState\" ] != \"Established\" ] if not non_established_peers : result . is_success () else : result . is_failure ( f \"The following RTC peers are not established: { non_established_peers } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_bgp_rtc_state()"},{"location":"api/tests.routing.generic/","text":"ANTA catalog for routing-generic tests \u00b6 Generic routing test functions verify_bfd ( device ) \u00b6 Verifies there is no BFD peer in down state (all VRF, IPv4 neighbors). Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if routing-table size is OK TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/generic.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def verify_bfd ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no BFD peer in down state (all VRF, IPv4 neighbors). Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if routing-table size is OK * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show bfd peers\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) has_failed : bool = False for vrf in response [ 0 ][ \"vrfs\" ]: for neighbor in response [ 0 ][ \"vrfs\" ][ vrf ][ \"ipv4Neighbors\" ]: for interface in response [ 0 ][ \"vrfs\" ][ vrf ][ \"ipv4Neighbors\" ][ neighbor ][ \"peerStats\" ]: if ( response [ 0 ][ \"vrfs\" ][ vrf ][ \"ipv4Neighbors\" ][ neighbor ][ \"peerStats\" ][ interface ][ \"status\" ] != \"up\" ): intf_state = response [ 0 ][ \"vrfs\" ][ vrf ][ \"ipv4Neighbors\" ][ neighbor ][ \"peerStats\" ][ interface ][ \"status\" ] intf_name = response [ 0 ][ \"vrfs\" ][ vrf ][ \"ipv4Neighbors\" ][ neighbor ][ \"peerStats\" ][ interface ] has_failed = True result . is_failure ( f \"bfd state on interface { intf_name } is { intf_state } (expected up)\" ) if has_failed is False : result . is_success () except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result verify_routing_protocol_model ( device , model = 'multi-agent' ) \u00b6 Verifies the configured routing protocol model is the one we expect. And if there is no mismatch between the configured and operating routing protocol model. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required model(str) Expected routing protocol model (multi-agent or ribd). Default is multi-agent required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the test model parameter is missing TestResult result = \u201csuccess\u201d if routing model is well configured TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/generic.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def verify_routing_protocol_model ( device : InventoryDevice , model : str = \"multi-agent\" ) -> TestResult : \"\"\" Verifies the configured routing protocol model is the one we expect. And if there is no mismatch between the configured and operating routing protocol model. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. model(str): Expected routing protocol model (multi-agent or ribd). Default is multi-agent Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the test `model` parameter is missing * result = \"success\" if routing model is well configured * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not model : result . is_skipped ( \"verify_routing_protocol_model was not run as no model was given\" ) return result try : response = device . session . runCmds ( 1 , [{ \"cmd\" : \"show ip route summary\" , \"revision\" : 3 }], \"json\" ) logger . debug ( f 'query result is: { response } ' ) configured_model = response [ 0 ][ \"protoModelStatus\" ][ \"configuredProtoModel\" ] operating_model = response [ 0 ][ \"protoModelStatus\" ][ \"operatingProtoModel\" ] if configured_model == operating_model == model : result . is_success () else : result . is_failure ( f \"routing model is misconfigured: configured: { configured_model } - \" f \"operating: { operating_model } - expected: { model } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result verify_routing_table_size ( device , minimum , maximum ) \u00b6 Verifies the size of the IP routing table (default VRF). Should be between the two provided thresholds. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required minimum(int) Expected minimum routing table (default VRF) size. required maximum(int) Expected maximum routing table (default VRF) size. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the test minimum or maximum parameters are missing TestResult result = \u201csuccess\u201d if routing-table size is correct TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/generic.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def verify_routing_table_size ( device : InventoryDevice , minimum : int , maximum : int ) -> TestResult : \"\"\" Verifies the size of the IP routing table (default VRF). Should be between the two provided thresholds. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. minimum(int): Expected minimum routing table (default VRF) size. maximum(int): Expected maximum routing table (default VRF) size. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the test `minimum` or `maximum` parameters are missing * result = \"success\" if routing-table size is correct * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not minimum or not maximum : result . is_skipped ( \"verify_routing_table_size was not run as no \" \"minimum or maximum were given\" ) return result try : response = device . session . runCmds ( 1 , [{ \"cmd\" : \"show ip route summary\" , \"revision\" : 3 }], \"json\" ) logger . debug ( f 'query result is: { response } ' ) total_routes = int ( response [ 0 ][ \"vrfs\" ][ \"default\" ][ \"totalRoutes\" ]) if minimum <= total_routes <= maximum : result . is_success () else : result . is_failure ( f \"routing-table has { total_routes } routes and not between min ( { minimum } ) and maximum ( { maximum } )\" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"Generic"},{"location":"api/tests.routing.generic/#anta-catalog-for-routing-generic-tests","text":"Generic routing test functions","title":"ANTA catalog for routing-generic tests"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.verify_bfd","text":"Verifies there is no BFD peer in down state (all VRF, IPv4 neighbors). Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if routing-table size is OK TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/generic.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def verify_bfd ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no BFD peer in down state (all VRF, IPv4 neighbors). Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if routing-table size is OK * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show bfd peers\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) has_failed : bool = False for vrf in response [ 0 ][ \"vrfs\" ]: for neighbor in response [ 0 ][ \"vrfs\" ][ vrf ][ \"ipv4Neighbors\" ]: for interface in response [ 0 ][ \"vrfs\" ][ vrf ][ \"ipv4Neighbors\" ][ neighbor ][ \"peerStats\" ]: if ( response [ 0 ][ \"vrfs\" ][ vrf ][ \"ipv4Neighbors\" ][ neighbor ][ \"peerStats\" ][ interface ][ \"status\" ] != \"up\" ): intf_state = response [ 0 ][ \"vrfs\" ][ vrf ][ \"ipv4Neighbors\" ][ neighbor ][ \"peerStats\" ][ interface ][ \"status\" ] intf_name = response [ 0 ][ \"vrfs\" ][ vrf ][ \"ipv4Neighbors\" ][ neighbor ][ \"peerStats\" ][ interface ] has_failed = True result . is_failure ( f \"bfd state on interface { intf_name } is { intf_state } (expected up)\" ) if has_failed is False : result . is_success () except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_bfd()"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.verify_routing_protocol_model","text":"Verifies the configured routing protocol model is the one we expect. And if there is no mismatch between the configured and operating routing protocol model. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required model(str) Expected routing protocol model (multi-agent or ribd). Default is multi-agent required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the test model parameter is missing TestResult result = \u201csuccess\u201d if routing model is well configured TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/generic.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def verify_routing_protocol_model ( device : InventoryDevice , model : str = \"multi-agent\" ) -> TestResult : \"\"\" Verifies the configured routing protocol model is the one we expect. And if there is no mismatch between the configured and operating routing protocol model. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. model(str): Expected routing protocol model (multi-agent or ribd). Default is multi-agent Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the test `model` parameter is missing * result = \"success\" if routing model is well configured * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not model : result . is_skipped ( \"verify_routing_protocol_model was not run as no model was given\" ) return result try : response = device . session . runCmds ( 1 , [{ \"cmd\" : \"show ip route summary\" , \"revision\" : 3 }], \"json\" ) logger . debug ( f 'query result is: { response } ' ) configured_model = response [ 0 ][ \"protoModelStatus\" ][ \"configuredProtoModel\" ] operating_model = response [ 0 ][ \"protoModelStatus\" ][ \"operatingProtoModel\" ] if configured_model == operating_model == model : result . is_success () else : result . is_failure ( f \"routing model is misconfigured: configured: { configured_model } - \" f \"operating: { operating_model } - expected: { model } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_routing_protocol_model()"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.verify_routing_table_size","text":"Verifies the size of the IP routing table (default VRF). Should be between the two provided thresholds. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required minimum(int) Expected minimum routing table (default VRF) size. required maximum(int) Expected maximum routing table (default VRF) size. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the test minimum or maximum parameters are missing TestResult result = \u201csuccess\u201d if routing-table size is correct TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/generic.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def verify_routing_table_size ( device : InventoryDevice , minimum : int , maximum : int ) -> TestResult : \"\"\" Verifies the size of the IP routing table (default VRF). Should be between the two provided thresholds. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. minimum(int): Expected minimum routing table (default VRF) size. maximum(int): Expected maximum routing table (default VRF) size. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the test `minimum` or `maximum` parameters are missing * result = \"success\" if routing-table size is correct * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not minimum or not maximum : result . is_skipped ( \"verify_routing_table_size was not run as no \" \"minimum or maximum were given\" ) return result try : response = device . session . runCmds ( 1 , [{ \"cmd\" : \"show ip route summary\" , \"revision\" : 3 }], \"json\" ) logger . debug ( f 'query result is: { response } ' ) total_routes = int ( response [ 0 ][ \"vrfs\" ][ \"default\" ][ \"totalRoutes\" ]) if minimum <= total_routes <= maximum : result . is_success () else : result . is_failure ( f \"routing-table has { total_routes } routes and not between min ( { minimum } ) and maximum ( { maximum } )\" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_routing_table_size()"},{"location":"api/tests.routing.ospf/","text":"ANTA catalog for routing-ospf tests \u00b6 OSPF test functions verify_ospf_count ( device , number ) \u00b6 Verifies the number of OSPF neighbors in FULL state is the one we expect. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required number int The expected number of OSPF neighbors in FULL state. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipeed\u201d if the number parameter is missing TestResult result = \u201csuccess\u201d if device has correct number of devices TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/ospf.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def verify_ospf_count ( device : InventoryDevice , number : int ) -> TestResult : \"\"\" Verifies the number of OSPF neighbors in FULL state is the one we expect. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. number (int): The expected number of OSPF neighbors in FULL state. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipeed\" if the `number` parameter is missing * result = \"success\" if device has correct number of devices * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not number : result . is_skipped ( \"verify_igmp_snooping_vlans was not run as no number was given\" ) return result try : response = device . session . runCmds ( 1 , [ \"show ip ospf neighbor | exclude Address\" ], \"text\" ) logger . debug ( f 'query result is: { response } ' ) if len ( response [ 0 ][ \"output\" ]) == 0 : result . is_skipped ( 'no OSPF neighbor found' ) return result response_data = response [ 0 ][ \"output\" ] . count ( \"FULL\" ) if response_data . count ( \"FULL\" ) == number : result . is_success () else : result . is_failure ( f 'device has { response_data . count ( \"FULL\" ) } neighbors (expected { number } ' ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result verify_ospf_state ( device ) \u00b6 Verifies all OSPF neighbors are in FULL state. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if all OSPF neighbors are FULL. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/ospf.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def verify_ospf_state ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies all OSPF neighbors are in FULL state. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if all OSPF neighbors are FULL. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show ip ospf neighbor | exclude FULL|Address\" ], \"text\" ) logger . debug ( f 'query result is: { response } ' ) if len ( response [ 0 ][ \"output\" ]) == 0 : result . is_skipped ( 'no OSPF neighbor found' ) return result if response [ 0 ][ \"output\" ] . count ( \" \\n \" ) == 0 : result . is_success () else : result . is_failure ( \"Some neighbors are not correctly configured.\" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"OSPF"},{"location":"api/tests.routing.ospf/#anta-catalog-for-routing-ospf-tests","text":"OSPF test functions","title":"ANTA catalog for routing-ospf tests"},{"location":"api/tests.routing.ospf/#anta.tests.routing.ospf.verify_ospf_count","text":"Verifies the number of OSPF neighbors in FULL state is the one we expect. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required number int The expected number of OSPF neighbors in FULL state. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipeed\u201d if the number parameter is missing TestResult result = \u201csuccess\u201d if device has correct number of devices TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/ospf.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def verify_ospf_count ( device : InventoryDevice , number : int ) -> TestResult : \"\"\" Verifies the number of OSPF neighbors in FULL state is the one we expect. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. number (int): The expected number of OSPF neighbors in FULL state. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipeed\" if the `number` parameter is missing * result = \"success\" if device has correct number of devices * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not number : result . is_skipped ( \"verify_igmp_snooping_vlans was not run as no number was given\" ) return result try : response = device . session . runCmds ( 1 , [ \"show ip ospf neighbor | exclude Address\" ], \"text\" ) logger . debug ( f 'query result is: { response } ' ) if len ( response [ 0 ][ \"output\" ]) == 0 : result . is_skipped ( 'no OSPF neighbor found' ) return result response_data = response [ 0 ][ \"output\" ] . count ( \"FULL\" ) if response_data . count ( \"FULL\" ) == number : result . is_success () else : result . is_failure ( f 'device has { response_data . count ( \"FULL\" ) } neighbors (expected { number } ' ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_ospf_count()"},{"location":"api/tests.routing.ospf/#anta.tests.routing.ospf.verify_ospf_state","text":"Verifies all OSPF neighbors are in FULL state. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if all OSPF neighbors are FULL. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/routing/ospf.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def verify_ospf_state ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies all OSPF neighbors are in FULL state. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if all OSPF neighbors are FULL. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show ip ospf neighbor | exclude FULL|Address\" ], \"text\" ) logger . debug ( f 'query result is: { response } ' ) if len ( response [ 0 ][ \"output\" ]) == 0 : result . is_skipped ( 'no OSPF neighbor found' ) return result if response [ 0 ][ \"output\" ] . count ( \" \\n \" ) == 0 : result . is_success () else : result . is_failure ( \"Some neighbors are not correctly configured.\" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_ospf_state()"},{"location":"api/tests.software/","text":"ANTA catalog for software tests \u00b6 Test functions related to the EOS software verify_eos_extensions ( device ) \u00b6 Verifies all EOS extensions installed on the device are enabled for boot persistence. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if the device has all installed its EOS extensions enabled for boot persistence. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/software.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def verify_eos_extensions ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies all EOS extensions installed on the device are enabled for boot persistence. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if the device has all installed its EOS extensions enabled for boot persistence. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show extensions\" , \"show boot-extensions\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) installed_extensions = [] boot_extensions = [] for extension in response [ 0 ][ \"extensions\" ]: if response [ 0 ][ \"extensions\" ][ extension ][ \"status\" ] == \"installed\" : installed_extensions . append ( extension ) for extension in response [ 1 ][ \"extensions\" ]: extension = extension . strip ( \" \\n \" ) if extension == \"\" : pass else : boot_extensions . append ( extension ) installed_extensions . sort () boot_extensions . sort () if installed_extensions == boot_extensions : result . is_success () else : result . is_failure ( f \"Missing EOS extensions: installed { installed_extensions } / configured: { boot_extensions } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result verify_eos_version ( device , versions = None ) \u00b6 Verifies the device is running one of the allowed EOS version. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required versions list List of allowed EOS versions. None Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the version parameter is missing TestResult result = \u201csuccess\u201d if EOS version is valid against versions TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/software.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def verify_eos_version ( device : InventoryDevice , versions : List [ str ] = None ) -> TestResult : \"\"\" Verifies the device is running one of the allowed EOS version. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. versions (list): List of allowed EOS versions. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the `version` parameter is missing * result = \"success\" if EOS version is valid against versions * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not versions : result . is_skipped ( \"verify_eos_version was not run as no versions were given\" ) return result try : response = device . session . runCmds ( 1 , [ \"show version\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) if response [ 0 ][ \"version\" ] in versions : result . is_success () else : result . is_failure ( f 'device is running version { response [ 0 ][ \"version\" ] } not in expected versions: { versions } ' ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result verify_field_notice_44_resolution ( device ) \u00b6 Verifies the device is using an Aboot version that fix the bug discussed in the field notice 44 (Aboot manages system settings prior to EOS initialization). https://www.arista.com/en/support/advisories-notices/field-notice/8756-field-notice-44 Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if aboot is running valid version TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/software.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 @skip_on_platforms ([ \"cEOSLab\" ]) def verify_field_notice_44_resolution ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the device is using an Aboot version that fix the bug discussed in the field notice 44 (Aboot manages system settings prior to EOS initialization). https://www.arista.com/en/support/advisories-notices/field-notice/8756-field-notice-44 Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if aboot is running valid version * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show version detail\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) devices = [ \"DCS-7010T-48\" , \"DCS-7010T-48-DC\" , \"DCS-7050TX-48\" , \"DCS-7050TX-64\" , \"DCS-7050TX-72\" , \"DCS-7050TX-72Q\" , \"DCS-7050TX-96\" , \"DCS-7050TX2-128\" , \"DCS-7050SX-64\" , \"DCS-7050SX-72\" , \"DCS-7050SX-72Q\" , \"DCS-7050SX2-72Q\" , \"DCS-7050SX-96\" , \"DCS-7050SX2-128\" , \"DCS-7050QX-32S\" , \"DCS-7050QX2-32S\" , \"DCS-7050SX3-48YC12\" , \"DCS-7050CX3-32S\" , \"DCS-7060CX-32S\" , \"DCS-7060CX2-32S\" , \"DCS-7060SX2-48YC6\" , \"DCS-7160-48YC6\" , \"DCS-7160-48TC6\" , \"DCS-7160-32CQ\" , \"DCS-7280SE-64\" , \"DCS-7280SE-68\" , \"DCS-7280SE-72\" , \"DCS-7150SC-24-CLD\" , \"DCS-7150SC-64-CLD\" , \"DCS-7020TR-48\" , \"DCS-7020TRA-48\" , \"DCS-7020SR-24C2\" , \"DCS-7020SRG-24C2\" , \"DCS-7280TR-48C6\" , \"DCS-7280TRA-48C6\" , \"DCS-7280SR-48C6\" , \"DCS-7280SRA-48C6\" , \"DCS-7280SRAM-48C6\" , \"DCS-7280SR2K-48C6-M\" , \"DCS-7280SR2-48YC6\" , \"DCS-7280SR2A-48YC6\" , \"DCS-7280SRM-40CX2\" , \"DCS-7280QR-C36\" , \"DCS-7280QRA-C36S\" , ] variants = [ \"-SSD-F\" , \"-SSD-R\" , \"-M-F\" , \"-M-R\" , \"-F\" , \"-R\" ] model = response [ 0 ][ \"modelName\" ] for variant in variants : model = model . replace ( variant , \"\" ) if model not in devices : result . is_skipped ( \"device is not impacted by FN044\" ) return result for component in response [ 0 ][ \"details\" ][ \"components\" ]: if component [ \"name\" ] == \"Aboot\" : aboot_version = component [ \"version\" ] . split ( \"-\" )[ 2 ] result . is_success () if aboot_version . startswith ( \"4.0.\" ) and int ( aboot_version . split ( \".\" )[ 2 ]) < 7 : result . is_failure ( f \"device is running incorrect version of aboot ( { aboot_version } )\" ) elif aboot_version . startswith ( \"4.1.\" ) and int ( aboot_version . split ( \".\" )[ 2 ]) < 1 : result . is_failure ( f \"device is running incorrect version of aboot ( { aboot_version } )\" ) elif aboot_version . startswith ( \"6.0.\" ) and int ( aboot_version . split ( \".\" )[ 2 ]) < 9 : result . is_failure ( f \"device is running incorrect version of aboot ( { aboot_version } )\" ) elif aboot_version . startswith ( \"6.1.\" ) and int ( aboot_version . split ( \".\" )[ 2 ]) < 7 : result . is_failure ( f \"device is running incorrect version of aboot ( { aboot_version } )\" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result verify_terminattr_version ( device , versions = None ) \u00b6 Verifies the device is running one of the allowed TerminAttr version. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required versions list List of allowed TerminAttr versions. None Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the versions parameter is missing TestResult result = \u201csuccess\u201d if TerminAttr version is valid against versions TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/software.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def verify_terminattr_version ( device : InventoryDevice , versions : List [ str ] = None ) -> TestResult : \"\"\" Verifies the device is running one of the allowed TerminAttr version. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. versions (list): List of allowed TerminAttr versions. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the `versions` parameter is missing * result = \"success\" if TerminAttr version is valid against versions * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not versions : result . is_skipped ( \"verify_terminattr_version was not run as no versions were given\" ) return result try : response = device . session . runCmds ( 1 , [ \"show version detail\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) response_data = response [ 0 ][ \"details\" ][ \"packages\" ][ \"TerminAttr-core\" ][ \"version\" ] if response_data in versions : result . is_success () else : result . is_failure ( f \"device is running TerminAttr version { response_data } and is not in the allowed list: { versions } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result","title":"Software"},{"location":"api/tests.software/#anta-catalog-for-software-tests","text":"Test functions related to the EOS software","title":"ANTA catalog for software tests"},{"location":"api/tests.software/#anta.tests.software.verify_eos_extensions","text":"Verifies all EOS extensions installed on the device are enabled for boot persistence. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if the device has all installed its EOS extensions enabled for boot persistence. TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/software.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def verify_eos_extensions ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies all EOS extensions installed on the device are enabled for boot persistence. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if the device has all installed its EOS extensions enabled for boot persistence. * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show extensions\" , \"show boot-extensions\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) installed_extensions = [] boot_extensions = [] for extension in response [ 0 ][ \"extensions\" ]: if response [ 0 ][ \"extensions\" ][ extension ][ \"status\" ] == \"installed\" : installed_extensions . append ( extension ) for extension in response [ 1 ][ \"extensions\" ]: extension = extension . strip ( \" \\n \" ) if extension == \"\" : pass else : boot_extensions . append ( extension ) installed_extensions . sort () boot_extensions . sort () if installed_extensions == boot_extensions : result . is_success () else : result . is_failure ( f \"Missing EOS extensions: installed { installed_extensions } / configured: { boot_extensions } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result","title":"verify_eos_extensions()"},{"location":"api/tests.software/#anta.tests.software.verify_eos_version","text":"Verifies the device is running one of the allowed EOS version. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required versions list List of allowed EOS versions. None Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the version parameter is missing TestResult result = \u201csuccess\u201d if EOS version is valid against versions TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/software.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def verify_eos_version ( device : InventoryDevice , versions : List [ str ] = None ) -> TestResult : \"\"\" Verifies the device is running one of the allowed EOS version. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. versions (list): List of allowed EOS versions. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the `version` parameter is missing * result = \"success\" if EOS version is valid against versions * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not versions : result . is_skipped ( \"verify_eos_version was not run as no versions were given\" ) return result try : response = device . session . runCmds ( 1 , [ \"show version\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) if response [ 0 ][ \"version\" ] in versions : result . is_success () else : result . is_failure ( f 'device is running version { response [ 0 ][ \"version\" ] } not in expected versions: { versions } ' ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result","title":"verify_eos_version()"},{"location":"api/tests.software/#anta.tests.software.verify_field_notice_44_resolution","text":"Verifies the device is using an Aboot version that fix the bug discussed in the field notice 44 (Aboot manages system settings prior to EOS initialization). https://www.arista.com/en/support/advisories-notices/field-notice/8756-field-notice-44 Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if aboot is running valid version TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/software.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 @skip_on_platforms ([ \"cEOSLab\" ]) def verify_field_notice_44_resolution ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the device is using an Aboot version that fix the bug discussed in the field notice 44 (Aboot manages system settings prior to EOS initialization). https://www.arista.com/en/support/advisories-notices/field-notice/8756-field-notice-44 Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if aboot is running valid version * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show version detail\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) devices = [ \"DCS-7010T-48\" , \"DCS-7010T-48-DC\" , \"DCS-7050TX-48\" , \"DCS-7050TX-64\" , \"DCS-7050TX-72\" , \"DCS-7050TX-72Q\" , \"DCS-7050TX-96\" , \"DCS-7050TX2-128\" , \"DCS-7050SX-64\" , \"DCS-7050SX-72\" , \"DCS-7050SX-72Q\" , \"DCS-7050SX2-72Q\" , \"DCS-7050SX-96\" , \"DCS-7050SX2-128\" , \"DCS-7050QX-32S\" , \"DCS-7050QX2-32S\" , \"DCS-7050SX3-48YC12\" , \"DCS-7050CX3-32S\" , \"DCS-7060CX-32S\" , \"DCS-7060CX2-32S\" , \"DCS-7060SX2-48YC6\" , \"DCS-7160-48YC6\" , \"DCS-7160-48TC6\" , \"DCS-7160-32CQ\" , \"DCS-7280SE-64\" , \"DCS-7280SE-68\" , \"DCS-7280SE-72\" , \"DCS-7150SC-24-CLD\" , \"DCS-7150SC-64-CLD\" , \"DCS-7020TR-48\" , \"DCS-7020TRA-48\" , \"DCS-7020SR-24C2\" , \"DCS-7020SRG-24C2\" , \"DCS-7280TR-48C6\" , \"DCS-7280TRA-48C6\" , \"DCS-7280SR-48C6\" , \"DCS-7280SRA-48C6\" , \"DCS-7280SRAM-48C6\" , \"DCS-7280SR2K-48C6-M\" , \"DCS-7280SR2-48YC6\" , \"DCS-7280SR2A-48YC6\" , \"DCS-7280SRM-40CX2\" , \"DCS-7280QR-C36\" , \"DCS-7280QRA-C36S\" , ] variants = [ \"-SSD-F\" , \"-SSD-R\" , \"-M-F\" , \"-M-R\" , \"-F\" , \"-R\" ] model = response [ 0 ][ \"modelName\" ] for variant in variants : model = model . replace ( variant , \"\" ) if model not in devices : result . is_skipped ( \"device is not impacted by FN044\" ) return result for component in response [ 0 ][ \"details\" ][ \"components\" ]: if component [ \"name\" ] == \"Aboot\" : aboot_version = component [ \"version\" ] . split ( \"-\" )[ 2 ] result . is_success () if aboot_version . startswith ( \"4.0.\" ) and int ( aboot_version . split ( \".\" )[ 2 ]) < 7 : result . is_failure ( f \"device is running incorrect version of aboot ( { aboot_version } )\" ) elif aboot_version . startswith ( \"4.1.\" ) and int ( aboot_version . split ( \".\" )[ 2 ]) < 1 : result . is_failure ( f \"device is running incorrect version of aboot ( { aboot_version } )\" ) elif aboot_version . startswith ( \"6.0.\" ) and int ( aboot_version . split ( \".\" )[ 2 ]) < 9 : result . is_failure ( f \"device is running incorrect version of aboot ( { aboot_version } )\" ) elif aboot_version . startswith ( \"6.1.\" ) and int ( aboot_version . split ( \".\" )[ 2 ]) < 7 : result . is_failure ( f \"device is running incorrect version of aboot ( { aboot_version } )\" ) except ( jsonrpc . AppError , KeyError ) as e : result . is_error ( str ( e )) return result","title":"verify_field_notice_44_resolution()"},{"location":"api/tests.software/#anta.tests.software.verify_terminattr_version","text":"Verifies the device is running one of the allowed TerminAttr version. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required versions list List of allowed TerminAttr versions. None Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the versions parameter is missing TestResult result = \u201csuccess\u201d if TerminAttr version is valid against versions TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/software.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def verify_terminattr_version ( device : InventoryDevice , versions : List [ str ] = None ) -> TestResult : \"\"\" Verifies the device is running one of the allowed TerminAttr version. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. versions (list): List of allowed TerminAttr versions. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the `versions` parameter is missing * result = \"success\" if TerminAttr version is valid against versions * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not versions : result . is_skipped ( \"verify_terminattr_version was not run as no versions were given\" ) return result try : response = device . session . runCmds ( 1 , [ \"show version detail\" ], \"json\" ) logger . debug ( f \"query result is: { response } \" ) response_data = response [ 0 ][ \"details\" ][ \"packages\" ][ \"TerminAttr-core\" ][ \"version\" ] if response_data in versions : result . is_success () else : result . is_failure ( f \"device is running TerminAttr version { response_data } and is not in the allowed list: { versions } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f \"exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } \" ) result . is_error ( str ( e )) return result","title":"verify_terminattr_version()"},{"location":"api/tests.system/","text":"ANTA catalog for system tests \u00b6 Test functions related to system-level features and protocols verify_agent_logs ( device ) \u00b6 Verifies there is no agent crash reported on the device. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if there is no agent crash TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/system.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def verify_agent_logs ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no agent crash reported on the device. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if there is no agent crash * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show agent logs crash\" ], \"text\" ) logger . debug ( f 'query result is: { response } ' ) response_data = response [ 0 ][ \"output\" ] if len ( response_data ) == 0 : result . is_success () else : result . is_failure ( f \"device reported some agent crashes: { response_data } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result verify_coredump ( device ) \u00b6 Verifies there is no core file. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if device has no core-dump TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/system.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def verify_coredump ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no core file. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if device has no core-dump * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : device . assert_enable_password_is_not_none ( \"verify_coredump\" ) response = device . session . runCmds ( 1 , [ { \"cmd\" : \"enable\" , \"input\" : str ( device . enable_password )}, \"bash timeout 10 ls /var/core\" , ], \"text\" , ) logger . debug ( f 'query result is: { response } ' ) response_data = response [ 1 ][ \"output\" ] if len ( response_data ) == 0 : result . is_success () else : result . is_failure ( f \"Core-dump(s) have been found: { response_data } \" ) except ( jsonrpc . AppError , KeyError , ValueError ) as e : result . is_error ( str ( e )) return result verify_cpu_utilization ( device ) \u00b6 Verifies the CPU utilization is less than 75%. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if CPU usage is lower than 75% TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/system.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def verify_cpu_utilization ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the CPU utilization is less than 75%. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if CPU usage is lower than 75% * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show processes top once\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) response_data = response [ 0 ][ \"cpuInfo\" ][ \"%Cpu(s)\" ][ \"idle\" ] if response_data > 25 : result . is_success () else : result . is_failure ( f \"device reported a high CPU utilization ( { response_data } %)\" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result verify_filesystem_utilization ( device ) \u00b6 Verifies each partition on the disk is used less than 75%. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if disk is used less than 75% TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/system.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 def verify_filesystem_utilization ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies each partition on the disk is used less than 75%. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if disk is used less than 75% * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ { \"cmd\" : \"enable\" , \"input\" : device . enable_password }, \"bash timeout 10 df -h\" , ], \"text\" , ) logger . debug ( f 'query result is: { response } ' ) result . is_success () for line in response [ 1 ][ \"output\" ] . split ( \" \\n \" )[ 1 :]: if \"loop\" not in line and len ( line ) > 0 and int ( line . split ()[ 4 ] . replace ( \"%\" , \"\" )) > 75 : result . is_failure ( f 'mount point { line } is higher than 75% (reprted { int ( line . split ()[ 4 ] . replace ( \" % \" , \"\" )) } )' ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result verify_memory_utilization ( device ) \u00b6 Verifies the memory utilization is less than 75%. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if memory usage is lower than 75% TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/system.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 def verify_memory_utilization ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the memory utilization is less than 75%. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if memory usage is lower than 75% * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show version\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) memory_usage = float ( response [ 0 ][ \"memFree\" ]) / \\ float ( response [ 0 ][ \"memTotal\" ]) if memory_usage > 0.25 : result . is_success () else : result . is_failure ( f \"device report a high memory usage: { memory_usage * 100 } %\" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result verify_ntp ( device ) \u00b6 Verifies NTP is synchronised. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if synchronized with NTP server TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/system.py 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def verify_ntp ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies NTP is synchronised. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if synchronized with NTP server * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show ntp status\" ], \"text\" ) logger . debug ( f 'query result is: { response } ' ) if response [ 0 ][ \"output\" ] . split ( \" \\n \" )[ 0 ] . split ( \" \" )[ 0 ] == \"synchronised\" : result . is_success () else : data = response [ 0 ][ \"output\" ] . split ( \" \\n \" )[ 0 ] result . is_failure ( f \"not sync with NTP server ( { data } )\" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result verify_reload_cause ( device ) \u00b6 Verifies the last reload of the device was requested by a user. Test considers the following messages as normal and will return success. Failure is for other messages * Reload requested by the user. * Reload requested after FPGA upgrade Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if reload cause is standard TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/system.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def verify_reload_cause ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the last reload of the device was requested by a user. Test considers the following messages as normal and will return success. Failure is for other messages * Reload requested by the user. * Reload requested after FPGA upgrade Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if reload cause is standard * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show reload cause\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) if 'resetCauses' not in response [ 0 ] . keys () or len ( response [ 0 ][ 'resetCauses' ]) == 0 : result . is_error ( \"no reload cause available\" ) return result response_data = response [ 0 ] . get ( \"resetCauses\" )[ 0 ] . get ( \"description\" ) if response_data in [ \"Reload requested by the user.\" , \"Reload requested after FPGA upgrade\" , ]: result . is_success () else : result . is_failure ( f \"Reload cause is { response_data } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { e . __class__ . __name__ } - { str ( e ) } ' ) result . is_error ( str ( e )) return result verify_syslog ( device ) \u00b6 Verifies the device had no syslog message with a severity of warning (or a more severe message) during the last 7 days. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if syslog has no WARNING message TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/system.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def verify_syslog ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the device had no syslog message with a severity of warning (or a more severe message) during the last 7 days. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if syslog has no WARNING message * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show logging last 7 days threshold warnings\" ], \"text\" ) logger . debug ( f 'query result is: { response } ' ) response_data = response [ 0 ][ \"output\" ] if len ( response_data ) == 0 : result . is_success () else : result . is_failure ( \"Device has some log messages with a severity WARNING or higher\" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result verify_uptime ( device , minimum = None ) \u00b6 Verifies the device uptime is higher than a value. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required minimum int Minimum uptime in seconds. None Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the minimum parameter is missing TestResult result = \u201csuccess\u201d if uptime is greater than minimun TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/system.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def verify_uptime ( device : InventoryDevice , minimum : int = None ) -> TestResult : \"\"\" Verifies the device uptime is higher than a value. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. minimum (int): Minimum uptime in seconds. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the `minimum` parameter is missing * result = \"success\" if uptime is greater than minimun * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not minimum : result . is_skipped ( \"verify_uptime was not run as no minimum were given\" ) return result try : response = device . session . runCmds ( 1 , [ \"show uptime\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) response_data = response [ 0 ][ \"upTime\" ] if response [ 0 ][ \"upTime\" ] > minimum : result . is_success () else : result . is_failure ( f \"Uptime is { response_data } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"System"},{"location":"api/tests.system/#anta-catalog-for-system-tests","text":"Test functions related to system-level features and protocols","title":"ANTA catalog for system tests"},{"location":"api/tests.system/#anta.tests.system.verify_agent_logs","text":"Verifies there is no agent crash reported on the device. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if there is no agent crash TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/system.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def verify_agent_logs ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no agent crash reported on the device. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if there is no agent crash * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show agent logs crash\" ], \"text\" ) logger . debug ( f 'query result is: { response } ' ) response_data = response [ 0 ][ \"output\" ] if len ( response_data ) == 0 : result . is_success () else : result . is_failure ( f \"device reported some agent crashes: { response_data } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_agent_logs()"},{"location":"api/tests.system/#anta.tests.system.verify_coredump","text":"Verifies there is no core file. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if device has no core-dump TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/system.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def verify_coredump ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies there is no core file. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if device has no core-dump * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : device . assert_enable_password_is_not_none ( \"verify_coredump\" ) response = device . session . runCmds ( 1 , [ { \"cmd\" : \"enable\" , \"input\" : str ( device . enable_password )}, \"bash timeout 10 ls /var/core\" , ], \"text\" , ) logger . debug ( f 'query result is: { response } ' ) response_data = response [ 1 ][ \"output\" ] if len ( response_data ) == 0 : result . is_success () else : result . is_failure ( f \"Core-dump(s) have been found: { response_data } \" ) except ( jsonrpc . AppError , KeyError , ValueError ) as e : result . is_error ( str ( e )) return result","title":"verify_coredump()"},{"location":"api/tests.system/#anta.tests.system.verify_cpu_utilization","text":"Verifies the CPU utilization is less than 75%. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if CPU usage is lower than 75% TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/system.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def verify_cpu_utilization ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the CPU utilization is less than 75%. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if CPU usage is lower than 75% * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show processes top once\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) response_data = response [ 0 ][ \"cpuInfo\" ][ \"%Cpu(s)\" ][ \"idle\" ] if response_data > 25 : result . is_success () else : result . is_failure ( f \"device reported a high CPU utilization ( { response_data } %)\" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_cpu_utilization()"},{"location":"api/tests.system/#anta.tests.system.verify_filesystem_utilization","text":"Verifies each partition on the disk is used less than 75%. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if disk is used less than 75% TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/system.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 def verify_filesystem_utilization ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies each partition on the disk is used less than 75%. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if disk is used less than 75% * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ { \"cmd\" : \"enable\" , \"input\" : device . enable_password }, \"bash timeout 10 df -h\" , ], \"text\" , ) logger . debug ( f 'query result is: { response } ' ) result . is_success () for line in response [ 1 ][ \"output\" ] . split ( \" \\n \" )[ 1 :]: if \"loop\" not in line and len ( line ) > 0 and int ( line . split ()[ 4 ] . replace ( \"%\" , \"\" )) > 75 : result . is_failure ( f 'mount point { line } is higher than 75% (reprted { int ( line . split ()[ 4 ] . replace ( \" % \" , \"\" )) } )' ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_filesystem_utilization()"},{"location":"api/tests.system/#anta.tests.system.verify_memory_utilization","text":"Verifies the memory utilization is less than 75%. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if memory usage is lower than 75% TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/system.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 def verify_memory_utilization ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the memory utilization is less than 75%. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if memory usage is lower than 75% * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show version\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) memory_usage = float ( response [ 0 ][ \"memFree\" ]) / \\ float ( response [ 0 ][ \"memTotal\" ]) if memory_usage > 0.25 : result . is_success () else : result . is_failure ( f \"device report a high memory usage: { memory_usage * 100 } %\" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_memory_utilization()"},{"location":"api/tests.system/#anta.tests.system.verify_ntp","text":"Verifies NTP is synchronised. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if synchronized with NTP server TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/system.py 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def verify_ntp ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies NTP is synchronised. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if synchronized with NTP server * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show ntp status\" ], \"text\" ) logger . debug ( f 'query result is: { response } ' ) if response [ 0 ][ \"output\" ] . split ( \" \\n \" )[ 0 ] . split ( \" \" )[ 0 ] == \"synchronised\" : result . is_success () else : data = response [ 0 ][ \"output\" ] . split ( \" \\n \" )[ 0 ] result . is_failure ( f \"not sync with NTP server ( { data } )\" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_ntp()"},{"location":"api/tests.system/#anta.tests.system.verify_reload_cause","text":"Verifies the last reload of the device was requested by a user. Test considers the following messages as normal and will return success. Failure is for other messages * Reload requested by the user. * Reload requested after FPGA upgrade Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if reload cause is standard TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/system.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def verify_reload_cause ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the last reload of the device was requested by a user. Test considers the following messages as normal and will return success. Failure is for other messages * Reload requested by the user. * Reload requested after FPGA upgrade Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if reload cause is standard * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show reload cause\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) if 'resetCauses' not in response [ 0 ] . keys () or len ( response [ 0 ][ 'resetCauses' ]) == 0 : result . is_error ( \"no reload cause available\" ) return result response_data = response [ 0 ] . get ( \"resetCauses\" )[ 0 ] . get ( \"description\" ) if response_data in [ \"Reload requested by the user.\" , \"Reload requested after FPGA upgrade\" , ]: result . is_success () else : result . is_failure ( f \"Reload cause is { response_data } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { e . __class__ . __name__ } - { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_reload_cause()"},{"location":"api/tests.system/#anta.tests.system.verify_syslog","text":"Verifies the device had no syslog message with a severity of warning (or a more severe message) during the last 7 days. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201csuccess\u201d if syslog has no WARNING message TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/system.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def verify_syslog ( device : InventoryDevice ) -> TestResult : \"\"\" Verifies the device had no syslog message with a severity of warning (or a more severe message) during the last 7 days. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"success\" if syslog has no WARNING message * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) try : response = device . session . runCmds ( 1 , [ \"show logging last 7 days threshold warnings\" ], \"text\" ) logger . debug ( f 'query result is: { response } ' ) response_data = response [ 0 ][ \"output\" ] if len ( response_data ) == 0 : result . is_success () else : result . is_failure ( \"Device has some log messages with a severity WARNING or higher\" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_syslog()"},{"location":"api/tests.system/#anta.tests.system.verify_uptime","text":"Verifies the device uptime is higher than a value. Parameters: Name Type Description Default device InventoryDevice InventoryDevice instance containing all devices information. required minimum int Minimum uptime in seconds. None Returns: Type Description TestResult TestResult instance with TestResult result = \u201cunset\u201d if the test has not been executed TestResult result = \u201cskipped\u201d if the minimum parameter is missing TestResult result = \u201csuccess\u201d if uptime is greater than minimun TestResult result = \u201cfailure\u201d otherwise. TestResult result = \u201cerror\u201d if any exception is caught Source code in anta/tests/system.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def verify_uptime ( device : InventoryDevice , minimum : int = None ) -> TestResult : \"\"\" Verifies the device uptime is higher than a value. Args: device (InventoryDevice): InventoryDevice instance containing all devices information. minimum (int): Minimum uptime in seconds. Returns: TestResult instance with * result = \"unset\" if the test has not been executed * result = \"skipped\" if the `minimum` parameter is missing * result = \"success\" if uptime is greater than minimun * result = \"failure\" otherwise. * result = \"error\" if any exception is caught \"\"\" function_name = inspect . stack ()[ 0 ][ 3 ] logger . debug ( f \"Start { function_name } check for host { device . host } \" ) result = TestResult ( host = str ( device . host ), test = function_name ) if not minimum : result . is_skipped ( \"verify_uptime was not run as no minimum were given\" ) return result try : response = device . session . runCmds ( 1 , [ \"show uptime\" ], \"json\" ) logger . debug ( f 'query result is: { response } ' ) response_data = response [ 0 ][ \"upTime\" ] if response [ 0 ][ \"upTime\" ] > minimum : result . is_success () else : result . is_failure ( f \"Uptime is { response_data } \" ) except ( jsonrpc . AppError , KeyError , socket . timeout ) as e : logger . error ( f 'exception raised for { inspect . stack ()[ 0 ][ 3 ] } - { device . host } : { str ( e ) } ' ) result . is_error ( str ( e )) return result","title":"verify_uptime()"}]}