{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ANTA Documentation \u00b6 This section provides generic documentation related to the Arista Network Test Automation framework (ANTA) User documentation \u00b6 requirements-and-installation.md : This file provides instructions about the requirements and installation procedure. usage.md : Command usages demo.md : This file content full output of commands provided by ANTA package. Automated documentation \u00b6 ANTA documentation overview : It is an overview of the ANTA Python package documentation in markdown format. It is generated by the script generate-functions-documentation.py and the docstrings in the python package ANTA . api/tests.md : It is the ANTA Python package detailled documentation in markdown format. It is generated by the script generate-functions-documentation.py and the docstrings in the python package ANTA . generate-functions-documentation.py : The functions to test EOS devices are coded in the python package ANTA . These functions have docstrings. These docstrings are used by the script generate-functions-documentation.py to generate the functions documentation in markdown format in the directory api . This requires the installation of the python package lazydocs that is indicated in the file requirements-dev.txt","title":"Home"},{"location":"#anta-documentation","text":"This section provides generic documentation related to the Arista Network Test Automation framework (ANTA)","title":"ANTA Documentation"},{"location":"#user-documentation","text":"requirements-and-installation.md : This file provides instructions about the requirements and installation procedure. usage.md : Command usages demo.md : This file content full output of commands provided by ANTA package.","title":"User documentation"},{"location":"#automated-documentation","text":"ANTA documentation overview : It is an overview of the ANTA Python package documentation in markdown format. It is generated by the script generate-functions-documentation.py and the docstrings in the python package ANTA . api/tests.md : It is the ANTA Python package detailled documentation in markdown format. It is generated by the script generate-functions-documentation.py and the docstrings in the python package ANTA . generate-functions-documentation.py : The functions to test EOS devices are coded in the python package ANTA . These functions have docstrings. These docstrings are used by the script generate-functions-documentation.py to generate the functions documentation in markdown format in the directory api . This requires the installation of the python package lazydocs that is indicated in the file requirements-dev.txt","title":"Automated documentation"},{"location":"demo/","text":"Devices testing demo \u00b6 To test devices, once you are done with the installation, you simply need: A text file with your devices hostname or IP address. Here\u2019s an example . A YAML file with the tests you would like to run. Some tests require an argument. Here\u2019s an example . Then you can run the Python script check-devices.py : ./check-devices.py --help usage: check-devices.py [-h] -i INVENTORY_FILE -u USERNAME -t TEST_CATALOG -o OUTPUT_FILE EOS devices health checks optional arguments: -h, --help show this help message and exit -i INVENTORY_FILE Text file containing a list of switches, one per line -u USERNAME Devices username -t TEST_CATALOG Text file containing the tests -o OUTPUT_FILE Output file ./check-devices.py -u arista -i devices.txt -o output.txt -t tests.yaml Device password: Enable password (if any): Testing devices .... please be patient ... Can not connect to device 2.2.2.2 Running tests on device 10.73.1.101 ... Running tests on device 10.73.1.102 ... Running tests on device 10.73.1.106 ... Test results are saved on output.txt Then you can check the tests result in the output file: $ cat output.txt Mon Apr 11 19:12:58 2022 devices inventory file was devices.txt devices username was arista list of unreachable devices is 2.2.2.2 tests file was tests.yaml ***** Results ***** +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ | devices | 01.01 | 01.02 | 01.03 | 01.04 | 02.01 | 02.02 | 02.03 | 02.04 | 02.05 | 02.06 | 02.07 | +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ | 10.73.1.101 | Fail | Pass | Pass | Pass | Pass | Skip | Pass | Fail | Fail | Pass | Pass | | 10.73.1.102 | Fail | Pass | Pass | Pass | Pass | Skip | Pass | Pass | Fail | Pass | Pass | | 10.73.1.106 | Fail | Pass | Pass | Pass | Pass | Skip | Pass | Pass | Fail | Pass | Pass | +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ | devices | 02.08 | 03.01 | 03.02 | 03.03 | 03.04 | 03.05 | 04.01 | 04.02 | 05.01 | 05.02 | 06.01 | +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ | 10.73.1.101 | Pass | Skip | Fail | Pass | Fail | Skip | Pass | Fail | Skip | Skip | Skip | | 10.73.1.102 | Pass | Skip | Fail | Pass | Fail | Skip | Pass | Fail | Skip | Skip | Skip | | 10.73.1.106 | Pass | Skip | Fail | Pass | Fail | Skip | Pass | Fail | Skip | Skip | Skip | +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ | devices | 07.01 | 08.01 | 08.02 | 08.03 | 08.04 | 08.05 | 08.06 | 09.01 | 09.02 | 09.03 | 09.04 | +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ | 10.73.1.101 | Pass | Pass | Pass | Pass | Pass | Pass | Skip | Skip | Skip | Skip | Skip | | 10.73.1.102 | Pass | Pass | Pass | Pass | Pass | Pass | Skip | Skip | Skip | Skip | Skip | | 10.73.1.106 | Pass | Pass | Pass | Pass | Pass | Pass | Skip | Fail | Pass | Pass | Fail | +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ | devices | 09.05 | 10.01 | 11.01 | 11.02 | 12.01 | 13.01 | 14.01 | 14.02 | 15.01 | 16.01 | 16.02 | +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ | 10.73.1.101 | Skip | Fail | Fail | Skip | Pass | Pass | Pass | Fail | Pass | Pass | Fail | | 10.73.1.102 | Skip | Fail | Fail | Skip | Pass | Pass | Pass | Fail | Pass | Pass | Fail | | 10.73.1.106 | Skip | Fail | Pass | Fail | Pass | Pass | Pass | Fail | Pass | Pass | Fail | +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ | devices | 16.03 | 16.04 | 16.05 | 16.06 | 16.07 | 17.01 | 17.02 | 18.01 | 18.02 | +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ | 10.73.1.101 | Pass | Pass | Fail | Skip | Skip | Pass | Fail | Skip | Pass | | 10.73.1.102 | Pass | Pass | Fail | Skip | Skip | Pass | Fail | Skip | Pass | | 10.73.1.106 | Pass | Pass | Pass | Skip | Skip | Pass | Fail | Skip | Pass | +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ ***** Tests ***** 01.01 {\"name\": \"verify_eos_version\", \"versions\": [\"4.25.4M\", \"4.26.1F\"]} 01.02 {\"name\": \"verify_terminattr_version\", \"versions\": [\"v1.13.6\", \"v1.8.0\"]} 01.03 {\"name\": \"verify_eos_extensions\"} 01.04 {\"name\": \"verify_field_notice_44_resolution\"} 02.01 {\"name\": \"verify_uptime\", \"minimum\": 86400} 02.02 {\"name\": \"verify_reload_cause\"} 02.03 {\"name\": \"verify_coredump\"} 02.04 {\"name\": \"verify_agent_logs\"} 02.05 {\"name\": \"verify_syslog\"} 02.06 {\"name\": \"verify_cpu_utilization\"} 02.07 {\"name\": \"verify_memory_utilization\"} 02.08 {\"name\": \"verify_filesystem_utilization\"} 03.01 {\"name\": \"verify_transceivers_manufacturers\", \"manufacturers\": [\"Not Present\", \"Arista Networks\", \"Arastra, Inc.\"]} 03.02 {\"name\": \"verify_system_temperature\"} 03.03 {\"name\": \"verify_transceiver_temperature\"} 03.04 {\"name\": \"verify_environment_cooling\"} 03.05 {\"name\": \"verify_environment_power\"} 04.01 {\"name\": \"verify_zerotouch\"} 04.02 {\"name\": \"verify_running_config_diffs\"} 05.01 {\"name\": \"verify_unified_forwarding_table_mode\", \"mode\": 3} 05.02 {\"name\": \"verify_tcam_profile\", \"profile\": \"vxlan-routing\"} 06.01 {\"name\": \"verify_adverse_drops\"} 07.01 {\"name\": \"verify_ntp\"} 08.01 {\"name\": \"verify_interface_utilization\"} 08.02 {\"name\": \"verify_interface_errors\"} 08.03 {\"name\": \"verify_interface_discards\"} 08.04 {\"name\": \"verify_interface_errdisabled\"} 08.05 {\"name\": \"verify_interfaces_status\", \"minimum\": 4} 08.06 {\"name\": \"verify_storm_control_drops\"} 09.01 {\"name\": \"verify_portchannels\"} 09.02 {\"name\": \"verify_illegal_lacp\"} 09.03 {\"name\": \"verify_mlag_status\"} 09.04 {\"name\": \"verify_mlag_interfaces\"} 09.05 {\"name\": \"verify_mlag_config_sanity\"} 10.01 {\"name\": \"verify_loopback_count\", \"number\": 3} 11.01 {\"name\": \"verify_vxlan\"} 11.02 {\"name\": \"verify_vxlan_config_sanity\"} 12.01 {\"name\": \"verify_svi\"} 13.01 {\"name\": \"verify_spanning_tree_blocked_ports\"} 14.01 {\"name\": \"verify_routing_protocol_model\", \"model\": \"multi-agent\"} 14.02 {\"name\": \"verify_routing_table_size\", \"minimum\": 2, \"maximum\": 20} 15.01 {\"name\": \"verify_bfd\"} 16.01 {\"name\": \"verify_bgp_ipv4_unicast_state\"} 16.02 {\"name\": \"verify_bgp_ipv4_unicast_count\", \"number\": 2, \"vrf\": \"default\"} 16.03 {\"name\": \"verify_bgp_ipv6_unicast_state\"} 16.04 {\"name\": \"verify_bgp_evpn_state\"} 16.05 {\"name\": \"verify_bgp_evpn_count\", \"number\": 2} 16.06 {\"name\": \"verify_bgp_rtc_state\"} 16.07 {\"name\": \"verify_bgp_rtc_count\", \"number\": 2} 17.01 {\"name\": \"verify_ospf_state\"} 17.02 {\"name\": \"verify_ospf_count\", \"number\": 3} 18.01 {\"name\": \"verify_igmp_snooping_vlans\", \"configuration\": \"disabled\", \"vlans\": [10, 12]} 18.02 {\"name\": \"verify_igmp_snooping_global\", \"configuration\": \"enabled\"}","title":"Devices testing demo"},{"location":"demo/#devices-testing-demo","text":"To test devices, once you are done with the installation, you simply need: A text file with your devices hostname or IP address. Here\u2019s an example . A YAML file with the tests you would like to run. Some tests require an argument. Here\u2019s an example . Then you can run the Python script check-devices.py : ./check-devices.py --help usage: check-devices.py [-h] -i INVENTORY_FILE -u USERNAME -t TEST_CATALOG -o OUTPUT_FILE EOS devices health checks optional arguments: -h, --help show this help message and exit -i INVENTORY_FILE Text file containing a list of switches, one per line -u USERNAME Devices username -t TEST_CATALOG Text file containing the tests -o OUTPUT_FILE Output file ./check-devices.py -u arista -i devices.txt -o output.txt -t tests.yaml Device password: Enable password (if any): Testing devices .... please be patient ... Can not connect to device 2.2.2.2 Running tests on device 10.73.1.101 ... Running tests on device 10.73.1.102 ... Running tests on device 10.73.1.106 ... Test results are saved on output.txt Then you can check the tests result in the output file: $ cat output.txt Mon Apr 11 19:12:58 2022 devices inventory file was devices.txt devices username was arista list of unreachable devices is 2.2.2.2 tests file was tests.yaml ***** Results ***** +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ | devices | 01.01 | 01.02 | 01.03 | 01.04 | 02.01 | 02.02 | 02.03 | 02.04 | 02.05 | 02.06 | 02.07 | +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ | 10.73.1.101 | Fail | Pass | Pass | Pass | Pass | Skip | Pass | Fail | Fail | Pass | Pass | | 10.73.1.102 | Fail | Pass | Pass | Pass | Pass | Skip | Pass | Pass | Fail | Pass | Pass | | 10.73.1.106 | Fail | Pass | Pass | Pass | Pass | Skip | Pass | Pass | Fail | Pass | Pass | +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ | devices | 02.08 | 03.01 | 03.02 | 03.03 | 03.04 | 03.05 | 04.01 | 04.02 | 05.01 | 05.02 | 06.01 | +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ | 10.73.1.101 | Pass | Skip | Fail | Pass | Fail | Skip | Pass | Fail | Skip | Skip | Skip | | 10.73.1.102 | Pass | Skip | Fail | Pass | Fail | Skip | Pass | Fail | Skip | Skip | Skip | | 10.73.1.106 | Pass | Skip | Fail | Pass | Fail | Skip | Pass | Fail | Skip | Skip | Skip | +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ | devices | 07.01 | 08.01 | 08.02 | 08.03 | 08.04 | 08.05 | 08.06 | 09.01 | 09.02 | 09.03 | 09.04 | +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ | 10.73.1.101 | Pass | Pass | Pass | Pass | Pass | Pass | Skip | Skip | Skip | Skip | Skip | | 10.73.1.102 | Pass | Pass | Pass | Pass | Pass | Pass | Skip | Skip | Skip | Skip | Skip | | 10.73.1.106 | Pass | Pass | Pass | Pass | Pass | Pass | Skip | Fail | Pass | Pass | Fail | +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ | devices | 09.05 | 10.01 | 11.01 | 11.02 | 12.01 | 13.01 | 14.01 | 14.02 | 15.01 | 16.01 | 16.02 | +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ | 10.73.1.101 | Skip | Fail | Fail | Skip | Pass | Pass | Pass | Fail | Pass | Pass | Fail | | 10.73.1.102 | Skip | Fail | Fail | Skip | Pass | Pass | Pass | Fail | Pass | Pass | Fail | | 10.73.1.106 | Skip | Fail | Pass | Fail | Pass | Pass | Pass | Fail | Pass | Pass | Fail | +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ | devices | 16.03 | 16.04 | 16.05 | 16.06 | 16.07 | 17.01 | 17.02 | 18.01 | 18.02 | +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ | 10.73.1.101 | Pass | Pass | Fail | Skip | Skip | Pass | Fail | Skip | Pass | | 10.73.1.102 | Pass | Pass | Fail | Skip | Skip | Pass | Fail | Skip | Pass | | 10.73.1.106 | Pass | Pass | Pass | Skip | Skip | Pass | Fail | Skip | Pass | +---------------+---------+---------+---------+---------+---------+---------+---------+---------+---------+ ***** Tests ***** 01.01 {\"name\": \"verify_eos_version\", \"versions\": [\"4.25.4M\", \"4.26.1F\"]} 01.02 {\"name\": \"verify_terminattr_version\", \"versions\": [\"v1.13.6\", \"v1.8.0\"]} 01.03 {\"name\": \"verify_eos_extensions\"} 01.04 {\"name\": \"verify_field_notice_44_resolution\"} 02.01 {\"name\": \"verify_uptime\", \"minimum\": 86400} 02.02 {\"name\": \"verify_reload_cause\"} 02.03 {\"name\": \"verify_coredump\"} 02.04 {\"name\": \"verify_agent_logs\"} 02.05 {\"name\": \"verify_syslog\"} 02.06 {\"name\": \"verify_cpu_utilization\"} 02.07 {\"name\": \"verify_memory_utilization\"} 02.08 {\"name\": \"verify_filesystem_utilization\"} 03.01 {\"name\": \"verify_transceivers_manufacturers\", \"manufacturers\": [\"Not Present\", \"Arista Networks\", \"Arastra, Inc.\"]} 03.02 {\"name\": \"verify_system_temperature\"} 03.03 {\"name\": \"verify_transceiver_temperature\"} 03.04 {\"name\": \"verify_environment_cooling\"} 03.05 {\"name\": \"verify_environment_power\"} 04.01 {\"name\": \"verify_zerotouch\"} 04.02 {\"name\": \"verify_running_config_diffs\"} 05.01 {\"name\": \"verify_unified_forwarding_table_mode\", \"mode\": 3} 05.02 {\"name\": \"verify_tcam_profile\", \"profile\": \"vxlan-routing\"} 06.01 {\"name\": \"verify_adverse_drops\"} 07.01 {\"name\": \"verify_ntp\"} 08.01 {\"name\": \"verify_interface_utilization\"} 08.02 {\"name\": \"verify_interface_errors\"} 08.03 {\"name\": \"verify_interface_discards\"} 08.04 {\"name\": \"verify_interface_errdisabled\"} 08.05 {\"name\": \"verify_interfaces_status\", \"minimum\": 4} 08.06 {\"name\": \"verify_storm_control_drops\"} 09.01 {\"name\": \"verify_portchannels\"} 09.02 {\"name\": \"verify_illegal_lacp\"} 09.03 {\"name\": \"verify_mlag_status\"} 09.04 {\"name\": \"verify_mlag_interfaces\"} 09.05 {\"name\": \"verify_mlag_config_sanity\"} 10.01 {\"name\": \"verify_loopback_count\", \"number\": 3} 11.01 {\"name\": \"verify_vxlan\"} 11.02 {\"name\": \"verify_vxlan_config_sanity\"} 12.01 {\"name\": \"verify_svi\"} 13.01 {\"name\": \"verify_spanning_tree_blocked_ports\"} 14.01 {\"name\": \"verify_routing_protocol_model\", \"model\": \"multi-agent\"} 14.02 {\"name\": \"verify_routing_table_size\", \"minimum\": 2, \"maximum\": 20} 15.01 {\"name\": \"verify_bfd\"} 16.01 {\"name\": \"verify_bgp_ipv4_unicast_state\"} 16.02 {\"name\": \"verify_bgp_ipv4_unicast_count\", \"number\": 2, \"vrf\": \"default\"} 16.03 {\"name\": \"verify_bgp_ipv6_unicast_state\"} 16.04 {\"name\": \"verify_bgp_evpn_state\"} 16.05 {\"name\": \"verify_bgp_evpn_count\", \"number\": 2} 16.06 {\"name\": \"verify_bgp_rtc_state\"} 16.07 {\"name\": \"verify_bgp_rtc_count\", \"number\": 2} 17.01 {\"name\": \"verify_ospf_state\"} 17.02 {\"name\": \"verify_ospf_count\", \"number\": 3} 18.01 {\"name\": \"verify_igmp_snooping_vlans\", \"configuration\": \"disabled\", \"vlans\": [10, 12]} 18.02 {\"name\": \"verify_igmp_snooping_global\", \"configuration\": \"enabled\"}","title":"Devices testing demo"},{"location":"requirements-and-installation/","text":"Table of Contents Requirements on your laptop Install the package ANTA and the scripts and the requirements Use the pip install command with the Git URL Clone the repository and install the package Using the pip install . command Using python setup.py commands Clone the repository and install the package in editable mode Clone the repository and use the pip install -r requirements.txt command Update your PATH environment variable if it is required Requirements on the switches Quick checks Requirements on your laptop \u00b6 Python 3 (at least 3.3) is required: python -V Install the package ANTA and the scripts and the requirements \u00b6 ANTA and these scripts require some packages that are not part of the Python standard library. They are indicated in the requirements.txt file There are several ways to installt the ANTA and the scripts and the requirements . This is described below. Use the pip install command with the Git URL \u00b6 Run this command to install: The package ANTA and its dependencies These scripts and the packages they required pip install git+https://github.com/arista-netdevops-community/network-test-automation.git You can even specify the commit you would like to install. Run these commands to verify: pip list check-devices-reachability.py --help which check-devices-reachability.py To update, run this command: pip install -U git+https://github.com/arista-netdevops-community/network-test-automation.git Clone the repository and install the package \u00b6 Run these commands to clone the repository and to move to the new folder: git clone https://github.com/arista-netdevops-community/network-test-automation.git cd network-test-automation Using the pip install . command \u00b6 Run this command to install: The package ANTA and its dependencies These scripts and the packages they required pip install . Run these commands to verify: pip list check-devices-reachability.py --help which check-devices-reachability.py Using python setup.py commands \u00b6 Run this command to build the package ANTA : python setup.py build Run this command to install: The package ANTA and its dependencies These scripts and the packages they required python setup.py install Run these commands to verify: pip list check-devices-reachability.py --help which check-devices-reachability.py Clone the repository and install the package in editable mode \u00b6 python setup.py install is used to install packages that you\u2019re not going to modify yourself. If you want to install the package and then be able to edit the code without having to re-install the package every time for the changes take effect, you can use python setup.py develop you can also use pip install -e . The . refers to the current working directory (the directory where is the setup.py file). The -e flag specifies that we want to install in editable mode, which means that when we edit the files in our package we do not need to re-install the package before the changes come into effect. You will need to reload the package though! Run these commands to install: The package ANTA and its dependencies These scripts and the packages they required git clone https://github.com/arista-netdevops-community/network-test-automation.git cd network-test-automation python setup.py develop or pip install -e . Run these commands to verify: pip list check-devices-reachability.py --help which check-devices-reachability.py Clone the repository and use the pip install -r requirements.txt command \u00b6 Run these commands to install the packages indicated in the requirements.txt file. git clone https://github.com/arista-netdevops-community/network-test-automation.git cd network-test-automation pip install -r requirements.txt These packages are required by: These scripts The package ANTA But this will not install: The ANTA package These scripts Run this command to verify: pip list Update your PATH environment variable if it is required \u00b6 If the path where the scripts are installed is not yet include in your PATH environment variable, please update it. Here\u2019s an example if the scripts are installed here: ls -l /home/arista/.local/bin/ Run this command to update path to update your PATH environment variable: echo $HOME echo $PATH export PATH = \" $HOME /.local/bin: $PATH \" echo $PATH Requirements on the switches \u00b6 configure interface Management1 description oob_management vrf MGMT ip address 10.73.1.105/24 end Enable eAPI on the MGMT vrf: configure management api http-commands protocol https port 443 no shutdown vrf MGMT no shutdown end Now the swicth accepts on port 443 in the MGMT VRF HTTPS requests containing a list of CLI commands. Run these EOS commands to verify: switch1#show management http-server switch1#show management api http-commands Quick checks \u00b6 Execute this python script to validate: You can import the jsonrpclib library The device reachability using eAPI Use your device credentials and IP address. import ssl from jsonrpclib import Server ssl . _create_default_https_context = ssl . _create_unverified_context USERNAME = \"arista\" PASSWORD = \"aristatwfn\" ENABLE_PASSWORD = \"aristatwfn\" IP = \"192.168.0.12\" URL = f 'https:// { USERNAME } : { PASSWORD } @ { IP } /command-api' switch = Server ( URL ) result = switch . runCmds ( 1 ,[ 'show version' ], 'json' ) print ( result [ 0 ][ 'uptime' ]) Run these python commands to validate you can import and use the ANTA package from anta.tests import * dir () help ( verify_bgp_ipv4_unicast_state ) verify_bgp_ipv4_unicast_state ( switch , ENABLE_PASSWORD ) exit ()","title":"Requirements and installation"},{"location":"requirements-and-installation/#requirements-on-your-laptop","text":"Python 3 (at least 3.3) is required: python -V","title":"Requirements on your laptop"},{"location":"requirements-and-installation/#install-the-package-anta-and-the-scripts-and-the-requirements","text":"ANTA and these scripts require some packages that are not part of the Python standard library. They are indicated in the requirements.txt file There are several ways to installt the ANTA and the scripts and the requirements . This is described below.","title":"Install the package ANTA and the scripts and the requirements"},{"location":"requirements-and-installation/#use-the-pip-install-command-with-the-git-url","text":"Run this command to install: The package ANTA and its dependencies These scripts and the packages they required pip install git+https://github.com/arista-netdevops-community/network-test-automation.git You can even specify the commit you would like to install. Run these commands to verify: pip list check-devices-reachability.py --help which check-devices-reachability.py To update, run this command: pip install -U git+https://github.com/arista-netdevops-community/network-test-automation.git","title":"Use the pip install command with the Git URL"},{"location":"requirements-and-installation/#clone-the-repository-and-install-the-package","text":"Run these commands to clone the repository and to move to the new folder: git clone https://github.com/arista-netdevops-community/network-test-automation.git cd network-test-automation","title":"Clone the repository and install the package"},{"location":"requirements-and-installation/#using-the-pip-install-command","text":"Run this command to install: The package ANTA and its dependencies These scripts and the packages they required pip install . Run these commands to verify: pip list check-devices-reachability.py --help which check-devices-reachability.py","title":"Using the pip install . command"},{"location":"requirements-and-installation/#using-python-setuppy-commands","text":"Run this command to build the package ANTA : python setup.py build Run this command to install: The package ANTA and its dependencies These scripts and the packages they required python setup.py install Run these commands to verify: pip list check-devices-reachability.py --help which check-devices-reachability.py","title":"Using python setup.py commands"},{"location":"requirements-and-installation/#clone-the-repository-and-install-the-package-in-editable-mode","text":"python setup.py install is used to install packages that you\u2019re not going to modify yourself. If you want to install the package and then be able to edit the code without having to re-install the package every time for the changes take effect, you can use python setup.py develop you can also use pip install -e . The . refers to the current working directory (the directory where is the setup.py file). The -e flag specifies that we want to install in editable mode, which means that when we edit the files in our package we do not need to re-install the package before the changes come into effect. You will need to reload the package though! Run these commands to install: The package ANTA and its dependencies These scripts and the packages they required git clone https://github.com/arista-netdevops-community/network-test-automation.git cd network-test-automation python setup.py develop or pip install -e . Run these commands to verify: pip list check-devices-reachability.py --help which check-devices-reachability.py","title":"Clone the repository and install the package in editable mode"},{"location":"requirements-and-installation/#clone-the-repository-and-use-the-pip-install-r-requirementstxt-command","text":"Run these commands to install the packages indicated in the requirements.txt file. git clone https://github.com/arista-netdevops-community/network-test-automation.git cd network-test-automation pip install -r requirements.txt These packages are required by: These scripts The package ANTA But this will not install: The ANTA package These scripts Run this command to verify: pip list","title":"Clone the repository and use the pip install -r requirements.txt command"},{"location":"requirements-and-installation/#update-your-path-environment-variable-if-it-is-required","text":"If the path where the scripts are installed is not yet include in your PATH environment variable, please update it. Here\u2019s an example if the scripts are installed here: ls -l /home/arista/.local/bin/ Run this command to update path to update your PATH environment variable: echo $HOME echo $PATH export PATH = \" $HOME /.local/bin: $PATH \" echo $PATH","title":"Update your PATH environment variable if it is required"},{"location":"requirements-and-installation/#requirements-on-the-switches","text":"configure interface Management1 description oob_management vrf MGMT ip address 10.73.1.105/24 end Enable eAPI on the MGMT vrf: configure management api http-commands protocol https port 443 no shutdown vrf MGMT no shutdown end Now the swicth accepts on port 443 in the MGMT VRF HTTPS requests containing a list of CLI commands. Run these EOS commands to verify: switch1#show management http-server switch1#show management api http-commands","title":"Requirements on the switches"},{"location":"requirements-and-installation/#quick-checks","text":"Execute this python script to validate: You can import the jsonrpclib library The device reachability using eAPI Use your device credentials and IP address. import ssl from jsonrpclib import Server ssl . _create_default_https_context = ssl . _create_unverified_context USERNAME = \"arista\" PASSWORD = \"aristatwfn\" ENABLE_PASSWORD = \"aristatwfn\" IP = \"192.168.0.12\" URL = f 'https:// { USERNAME } : { PASSWORD } @ { IP } /command-api' switch = Server ( URL ) result = switch . runCmds ( 1 ,[ 'show version' ], 'json' ) print ( result [ 0 ][ 'uptime' ]) Run these python commands to validate you can import and use the ANTA package from anta.tests import * dir () help ( verify_bgp_ipv4_unicast_state ) verify_bgp_ipv4_unicast_state ( switch , ENABLE_PASSWORD ) exit ()","title":"Quick checks"},{"location":"usage/","text":"Repository usage \u00b6 Once you are done with the installation, you can use the ANTA package and the scripts . How to use the ANTA package \u00b6 Have a quick look to the package documentation: The overview.md file is an overview of the package documentation The tests.md file is a detailled documentation of the package Instantiate the class Server of jsonrpclib for an EOS device: >>> import ssl >>> from jsonrpclib import Server >>> ssl . _create_default_https_context = ssl . _create_unverified_context >>> USERNAME = \"arista\" >>> PASSWORD = \"aristatwfn\" >>> ENABLE_PASSWORD = \"aristatwfn\" >>> IP = \"192.168.0.12\" >>> URL = f 'https:// { USERNAME } : { PASSWORD } @ { IP } /command-api' >>> switch = Server ( URL ) Here\u2019s how we can import and use the functions of the ANTA package: >>> from anta.tests import * >>> dir () >>> help ( verify_eos_version ) >>> help ( verify_bgp_evpn_state ) >>> help ( verify_interface_discards ) >>> verify_eos_version ( switch , ENABLE_PASSWORD , [ \"4.22.1F\" ]) >>> verify_bgp_ipv4_unicast_state ( switch , ENABLE_PASSWORD ) >>> exit () How to use the scripts \u00b6 How to create an inventory from CVP \u00b6 The python script create-devices-inventory-from-cvp.py create an inventory text file using CVP. Run these commands to get an inventory with all devices IP address. ./create-devices-inventory-from-cvp.py --help ./create-devices-inventory-from-cvp.py -cvp 192 .168.0.5 -u arista -o inventory cat inventory/all.text Run these commands to get an inventory with the IP address of the devices under the container Spine ./create-devices-inventory-from-cvp.py --help ./create-devices-inventory-from-cvp.py -cvp 192 .168.0.5 -u arista -o inventory -c Spine cat inventory/Spine.text How to check devices state \u00b6 The python script check-devices.py uses the python functions defined in the package ANTA to test devices: Update the devices inventory with the devices IP address or hostname Update the file tests.yaml to indicate the tests you would like to run. Some tests require an argument. In that case, provide it using the same YAML file Execute the script check-devices.py Check the tests result in the output file vi devices.txt vi tests.yaml ./check-devices.py --help ./check-devices.py -i devices.txt -t tests.yaml -o output.txt -u username cat output.txt How to test devices reachability \u00b6 The python script check-devices-reachability.py checks the devices reachability using eAPI: Update the devices inventory with the devices IP address or hostname Run the python script check-devices-reachability.py Check the result in the console vi devices.txt ./check-devices-reachability.py --help ./check-devices-reachability.py -i devices.txt -u username How to collect commands output \u00b6 The python script collect-eos-commands.py runs show commands on devices and collects the output: Update the devices inventory with the devices IP address or hostname Update the EOS commands list you would like to collect from the devices in text or JSON format Run the python script collect-eos-commands.py The commands output is saved in the output directory vi devices-list.text vi eos-commands.yaml ./collect-eos-commands.py --help ./collect-eos-commands.py -i devices.txt -c eos-commands.yaml -o outdir -u username ls outdir How to collect the scheduled show tech-support files \u00b6 The python script collect-sheduled-show-tech.py collects the scheduled show tech-support files: Update the devices inventory with the devices IP address or hostname Run the python script collect-sheduled-show-tech.py The files are saved in the output directory vi devices-list.text ./collect-sheduled-show-tech.py --help ./collect-sheduled-show-tech.py -i devices.txt -u username -o outdir ls outdir How to clear counters \u00b6 The python script clear-counters.py clears counters: Update the devices inventory with the devices IP address or hostname Run the python script clear-counters.py vi devices-list.text ./clear-counters.py --help ./clear-counters.py -i devices.txt -u username How to clear the MAC addresses which are blacklisted in EVPN \u00b6 The python script evpn-blacklist-recovery.py clears the MAC addresses which are blacklisted in EVPN: Update the devices inventory with the devices IP address or hostname Run the python script evpn-blacklist-recovery.py vi devices-list.text ./evpn-blacklist-recovery.py --help ./evpn-blacklist-recovery.py -i devices.txt -u username","title":"Repository usage"},{"location":"usage/#repository-usage","text":"Once you are done with the installation, you can use the ANTA package and the scripts .","title":"Repository usage"},{"location":"usage/#how-to-use-the-anta-package","text":"Have a quick look to the package documentation: The overview.md file is an overview of the package documentation The tests.md file is a detailled documentation of the package Instantiate the class Server of jsonrpclib for an EOS device: >>> import ssl >>> from jsonrpclib import Server >>> ssl . _create_default_https_context = ssl . _create_unverified_context >>> USERNAME = \"arista\" >>> PASSWORD = \"aristatwfn\" >>> ENABLE_PASSWORD = \"aristatwfn\" >>> IP = \"192.168.0.12\" >>> URL = f 'https:// { USERNAME } : { PASSWORD } @ { IP } /command-api' >>> switch = Server ( URL ) Here\u2019s how we can import and use the functions of the ANTA package: >>> from anta.tests import * >>> dir () >>> help ( verify_eos_version ) >>> help ( verify_bgp_evpn_state ) >>> help ( verify_interface_discards ) >>> verify_eos_version ( switch , ENABLE_PASSWORD , [ \"4.22.1F\" ]) >>> verify_bgp_ipv4_unicast_state ( switch , ENABLE_PASSWORD ) >>> exit ()","title":"How to use the ANTA package"},{"location":"usage/#how-to-use-the-scripts","text":"","title":"How to use the scripts"},{"location":"usage/#how-to-create-an-inventory-from-cvp","text":"The python script create-devices-inventory-from-cvp.py create an inventory text file using CVP. Run these commands to get an inventory with all devices IP address. ./create-devices-inventory-from-cvp.py --help ./create-devices-inventory-from-cvp.py -cvp 192 .168.0.5 -u arista -o inventory cat inventory/all.text Run these commands to get an inventory with the IP address of the devices under the container Spine ./create-devices-inventory-from-cvp.py --help ./create-devices-inventory-from-cvp.py -cvp 192 .168.0.5 -u arista -o inventory -c Spine cat inventory/Spine.text","title":"How to create an inventory from CVP"},{"location":"usage/#how-to-check-devices-state","text":"The python script check-devices.py uses the python functions defined in the package ANTA to test devices: Update the devices inventory with the devices IP address or hostname Update the file tests.yaml to indicate the tests you would like to run. Some tests require an argument. In that case, provide it using the same YAML file Execute the script check-devices.py Check the tests result in the output file vi devices.txt vi tests.yaml ./check-devices.py --help ./check-devices.py -i devices.txt -t tests.yaml -o output.txt -u username cat output.txt","title":"How to check devices state"},{"location":"usage/#how-to-test-devices-reachability","text":"The python script check-devices-reachability.py checks the devices reachability using eAPI: Update the devices inventory with the devices IP address or hostname Run the python script check-devices-reachability.py Check the result in the console vi devices.txt ./check-devices-reachability.py --help ./check-devices-reachability.py -i devices.txt -u username","title":"How to test devices reachability"},{"location":"usage/#how-to-collect-commands-output","text":"The python script collect-eos-commands.py runs show commands on devices and collects the output: Update the devices inventory with the devices IP address or hostname Update the EOS commands list you would like to collect from the devices in text or JSON format Run the python script collect-eos-commands.py The commands output is saved in the output directory vi devices-list.text vi eos-commands.yaml ./collect-eos-commands.py --help ./collect-eos-commands.py -i devices.txt -c eos-commands.yaml -o outdir -u username ls outdir","title":"How to collect commands output"},{"location":"usage/#how-to-collect-the-scheduled-show-tech-support-files","text":"The python script collect-sheduled-show-tech.py collects the scheduled show tech-support files: Update the devices inventory with the devices IP address or hostname Run the python script collect-sheduled-show-tech.py The files are saved in the output directory vi devices-list.text ./collect-sheduled-show-tech.py --help ./collect-sheduled-show-tech.py -i devices.txt -u username -o outdir ls outdir","title":"How to collect the scheduled show tech-support files"},{"location":"usage/#how-to-clear-counters","text":"The python script clear-counters.py clears counters: Update the devices inventory with the devices IP address or hostname Run the python script clear-counters.py vi devices-list.text ./clear-counters.py --help ./clear-counters.py -i devices.txt -u username","title":"How to clear counters"},{"location":"usage/#how-to-clear-the-mac-addresses-which-are-blacklisted-in-evpn","text":"The python script evpn-blacklist-recovery.py clears the MAC addresses which are blacklisted in EVPN: Update the devices inventory with the devices IP address or hostname Run the python script evpn-blacklist-recovery.py vi devices-list.text ./evpn-blacklist-recovery.py --help ./evpn-blacklist-recovery.py -i devices.txt -u username","title":"How to clear the MAC addresses which are blacklisted in EVPN"},{"location":"api/inventory/","text":"ANTA Inventory module \u00b6 Inventory Abstraction for ANTA framework. Attributes: Name Type Description timeout(float) Connection to device timeout. INVENTORY_ROOT_KEY(str, Optional head of the YAML inventory. Default is anta_inventory EAPI_SESSION_TPL(str, Optional Template for eAPI URL builder INVENTORY_OUTPUT_FORMAT List [ str ], Optional List of supported output format. Default [\u2018native\u2019, \u2018json\u2019] HW_MODEL_KEY str , Optional Name of the key in Arista eAPI JSON provided by device. Examples: Inventory file input print ( inventory . yml ) anta_inventory : hosts : - hosts : 1 . 1 . 1 . 1 - host : 2 . 2 . 2 . 2 networks : - network : 10 . 0 . 0 . 0 / 8 - network : 192 . 168 . 0 . 0 / 16 ranges : - start : 10 . 0 . 0 . 1 end : 10 . 0 . 0 . 11 Inventory result: test = AntaInventory ( ... inventory_file = ' examples / inventory . yml ' , ... username = ' ansible ' , ... password = ' ansible ' , ... auto_connect = True ) test . get_inventory () [ \"InventoryDevice(host=IPv4Address('192.168.0.17')\" , \"username='ansible'\" , \"password='ansible'\" , \"session=<ServerProxy for ansible:ansible@192.168.0.17/command-api>\" , \"url='https://ansible:ansible@192.168.0.17/command-api'\" , \"established=True\" , \"is_online=True\" , \"hw_model=cEOS-LAB\" , ... \"InventoryDevice(host=IPv4Address('192.168.0.2')\" , \"username='ansible'\" , \"password='ansible'\" , \"session=None\" , \"url='https://ansible:ansible@192.168.0.2/command-api'\" , \"established=False\" \"is_online=False\" , \"hw_model=unset\" , ] Raises: Type Description InventoryRootKeyErrors Root key of inventory is missing. InventoryIncorrectSchema Inventory file is not following AntaInventory Schema. InventoryUnknownFormat Output format is not supported. Source code in anta/inventory/__init__.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 class AntaInventory (): \"\"\" Inventory Abstraction for ANTA framework. Attributes: timeout(float): Connection to device timeout. INVENTORY_ROOT_KEY(str, Optional): head of the YAML inventory. Default is anta_inventory EAPI_SESSION_TPL(str, Optional): Template for eAPI URL builder INVENTORY_OUTPUT_FORMAT (List[str],Optional): List of supported output format. Default ['native', 'json'] HW_MODEL_KEY (str,Optional): Name of the key in Arista eAPI JSON provided by device. Examples: Inventory file input print(inventory.yml) anta_inventory: hosts: - hosts: 1.1.1.1 - host: 2.2.2.2 networks: - network: 10.0.0.0/8 - network: 192.168.0.0/16 ranges: - start: 10.0.0.1 end: 10.0.0.11 Inventory result: test = AntaInventory( ... inventory_file='examples/inventory.yml', ... username='ansible', ... password='ansible', ... auto_connect=True) test.get_inventory() [ \"InventoryDevice(host=IPv4Address('192.168.0.17')\", \"username='ansible'\", \"password='ansible'\", \"session=<ServerProxy for ansible:ansible@192.168.0.17/command-api>\", \"url='https://ansible:ansible@192.168.0.17/command-api'\", \"established=True\", \"is_online=True\", \"hw_model=cEOS-LAB\", ... \"InventoryDevice(host=IPv4Address('192.168.0.2')\", \"username='ansible'\", \"password='ansible'\", \"session=None\", \"url='https://ansible:ansible@192.168.0.2/command-api'\", \"established=False\" \"is_online=False\", \"hw_model=unset\", ] Raises: InventoryRootKeyErrors: Root key of inventory is missing. InventoryIncorrectSchema: Inventory file is not following AntaInventory Schema. InventoryUnknownFormat: Output format is not supported. \"\"\" # Root key of inventory part of the inventory file INVENTORY_ROOT_KEY = 'anta_inventory' # Template to build eAPI connection URL EAPI_SESSION_TPL = 'https://{{device_username}}:{{device_password}}@{{device}}/command-api' # Supported Output format INVENTORY_OUTPUT_FORMAT = [ 'native' , 'json' ] # HW model definition in show version HW_MODEL_KEY = 'modelName' # pylint: disable=R0913 def __init__ ( self , inventory_file : str , username : str , password : str , enable_password : str = None , auto_connect : bool = True , timeout : float = 5 ) -> None : \"\"\"Class constructor. Args: inventory_file (str): Path to inventory YAML file where user has described his inputs username (str): Username to use to connect to devices password (str): Password to use to connect to devices auto_connect (bool, optional): Automatically build eAPI context for every devices. Defaults to True. timeout (float, optional): Timeout in second to wait before marking device down. Defaults to 5sec. \"\"\" self . set_credentials ( username , password , enable_password ) self . timeout = timeout self . _inventory = InventoryDevices () # Max number of thread to launch for discovery self . max_multiprocessing_thread = cpu_count () + 30 with open ( inventory_file , 'r' , encoding = 'utf8' ) as f : data = yaml . load ( f , Loader = SafeLoader ) # Load data using Pydantic try : self . _read_inventory = AntaInventoryInput ( ** data [ self . INVENTORY_ROOT_KEY ] ) except KeyError as exc : logger . error ( f 'Inventory root key is missing: { self . INVENTORY_ROOT_KEY } ' ) raise InventoryRootKeyErrors ( f 'Inventory root key ( { self . INVENTORY_ROOT_KEY } ) is not defined in your inventory' ) from exc except ValidationError as exc : logger . error ( 'Inventory data are not compliant with inventory models' ) raise InventoryIncorrectSchema ( 'Inventory is not following schema' ) from exc # Read data from input if self . _read_inventory . dict ()[ 'hosts' ] is not None : self . _inventory_read_hosts () if self . _read_inventory . dict ()[ 'networks' ] is not None : self . _inventory_read_networks () if self . _read_inventory . dict ()[ 'ranges' ] is not None : self . _inventory_read_ranges () # Create RPC connection for all devices if auto_connect : self . connect_inventory () ########################################################################### ### Boolean methods ########################################################################### def _is_ip_exist ( self , ip : str ) -> bool : \"\"\"Check if an IP is part of the current inventory. Args: ip (str): IP address to search in our inventory Returns: bool: True if device is in our inventory, False if not \"\"\" logger . debug ( f 'Checking if device { ip } is in ourr inventory' ) return len ([ str ( dev . host ) for dev in self . _inventory if str ( ip ) == str ( dev . host )]) == 1 def _is_device_online ( self , device : InventoryDevice , timeout : float = 5 ) -> bool : \"\"\" _is_device_online Check if device is online. Execute an eAPI call to check if device is online and has eAPI working as expected If device is ready to serve request, method returns True, else return False. Args: device (InventoryDevice): InventoryDevice structure to test timeout (float, optional): Request timeout. Defaults to 5. Returns: bool: True if device ready, False by default. \"\"\" logger . debug ( f 'Checking if device { device . host } is online' ) connection = Server ( device . url ) # Check connectivity try : setdefaulttimeout ( timeout ) connection . runCmds ( 1 ,[ 'show version' ]) # pylint: disable=W0703 except Exception : logger . warning ( f 'Service not running on device { device . host } ' ) return False else : return True ########################################################################### ### Internal methods ########################################################################### def _read_device_hw ( self , device : InventoryDevice , timeout : float = 5 ) -> str : \"\"\" _read_device_hw Read HW model from the device and update entry with correct value. It returns HW model name from show version or None if device is not reachable or if it cannot find the modelName key Args: device (InventoryDevice): Device to update timeout (float, optional): Connection timeout. Defaults to 5. Returns: str: HW value read from the device using show version. \"\"\" logger . debug ( f 'Reading HW information for { device . host } ' ) connection = Server ( device . url ) try : setdefaulttimeout ( timeout ) response = connection . runCmds ( 1 , [ 'show version' ]) # pylint: disable=W0703 except Exception : logger . warning ( f 'Service not running on device { device . host } ' ) return None else : return response [ 0 ][ self . HW_MODEL_KEY ] if self . HW_MODEL_KEY in response [ 0 ] else None def _get_from_device ( self , device : InventoryDevice ) -> InventoryDevice : \"\"\" _get_from_device Update online flag for InventoryDevice. It updates following keys: - is_online - hw_model Args: device (InventoryDevice): Device to check using InventoryDevice structure. Returns: InventoryDevice: Updated structure with devices information (is_online, HW model) \"\"\" logger . debug ( f 'Refreshing is_online flag for device { device . host } ' ) device . is_online = self . _is_device_online ( device = device , timeout = self . timeout ) if device . is_online : device . hw_model = self . _read_device_hw ( device = device , timeout = self . timeout ) return device def _build_device_session_path ( self , host : str , username : str , password : str ) -> str : \"\"\"Construct URL to reach device using eAPI. Jinja2 render to build URL to use for eAPI session. Args: host (str): IP Address of the device to target in the eAPI session username (str): Username for authentication password (str): Password for authentication Returns: str: String to use to create eAPI session \"\"\" session_template = Template ( self . EAPI_SESSION_TPL ) return session_template . render ( device = host , device_username = username , device_password = password ) def _build_device_session ( self , device : InventoryDevice , timeout : float = 5 ) -> InventoryDevice : \"\"\"Create eAPI RPC session to Arista EOS devices. Args: device (InventoryDevice): Device information based on InventoryDevice structure timeout (int, optional): Device timeout to declare host as down. Defaults to 5. Returns: InventoryDevice: Updated device structure with its RPC connection \"\"\" connection = Server ( device . url ) # Check connectivity try : setdefaulttimeout ( timeout ) connection . runCmds ( 1 , [ 'show version' ]) # pylint: disable=W0703 except Exception : logger . warning ( f 'Service not running on device { device . host } ' ) device . session = None else : device . established = True device . session = connection return device def _add_device_to_inventory ( self , host_ip ) -> None : \"\"\"Add a InventoryDevice to final inventory. Create InventoryDevice and append to existing inventory Args: host_ip (str): IP address of the host \"\"\" device = InventoryDevice ( host = host_ip , username = self . _username , password = self . _password , enable_password = self . _enable_password , url = self . _build_device_session_path ( host = host_ip , username = self . _username , password = self . _password ) ) self . _inventory . append ( device ) def _inventory_read_hosts ( self ) -> None : \"\"\"Read input data from hosts section and create inventory structure. Build InventoryDevice structure for all hosts under hosts section \"\"\" for host in self . _read_inventory . hosts : self . _add_device_to_inventory ( host_ip = host . host ) def _inventory_read_networks ( self ) -> None : \"\"\"Read input data from networks section and create inventory structure. Build InventoryDevice structure for all IPs available in each declared subnet \"\"\" for network in self . _read_inventory . networks : for host_ip in IPNetwork ( str ( network . network )): self . _add_device_to_inventory ( host_ip = host_ip ) def _inventory_read_ranges ( self ) -> None : \"\"\"Read input data from ranges section and create inventory structure. Build InventoryDevice structure for all IPs available in each declared range \"\"\" for range_def in self . _read_inventory . ranges : range_increment = IPAddress ( str ( range_def . start )) range_stop = IPAddress ( str ( range_def . end )) while range_increment <= range_stop : self . _add_device_to_inventory ( host_ip = str ( range_increment )) range_increment += 1 def _inventory_rebuild ( self , list_devices : List [ InventoryDevice ]) -> InventoryDevices : \"\"\" _inventory_rebuild Transform a list of InventoryDevice into a InventoryDevices object. Args: list_devices (List[InventoryDevice]): List of devices to add into InventoryDevices Returns: InventoryDevices: An object with all the devices. \"\"\" logger . debug ( f 'Create a new version of InventoryDevices' ) inventory = InventoryDevices () for device in list_devices : inventory . append ( device ) return inventory def _filtered_inventory ( self , established_only : bool = False ) -> InventoryDevices : \"\"\" _filtered_inventory Generate a temporary inventory filtered. Args: established_only (bool, optional): Do we have to include non-established devices. Defaults to False. Returns: InventoryDevices: A inventory with concerned devices \"\"\" inventory = InventoryDevices () if established_only is False : return self . _inventory for device in self . _inventory : if device . established : inventory . append ( device ) return inventory ########################################################################### ### Public methods ########################################################################### ########################################################################### ### GET methods def get_inventory ( self , format_out : str = 'native' , established_only : bool = True ) -> InventoryDevices : \"\"\"get_inventory Expose device inventory. Provides inventory has a list of InventoryDevice objects. If requried, it can be exposed in JSON format. Also, by default expose only active devices. Args: format (str, optional): Format output, can be native, list or JSON. Defaults to 'native'. established_only (bool, optional): Allow to expose also unreachable devices. Defaults to True. Returns: InventoryDevices: List of InventoryDevice \"\"\" if format_out not in [ 'native' , 'json' , 'list' ]: raise InventoryUnknownFormat ( f 'Unsupported inventory format: { format_out } . Only supported format are: { self . INVENTORY_OUTPUT_FORMAT } ' ) inventory = self . _filtered_inventory ( established_only ) if format_out == 'list' : # pylint: disable=R1721 return [ dev for dev in inventory ] if format_out == 'json' : return inventory . json () return inventory def get_device ( self , host_ip ) -> InventoryDevice : \"\"\"Get device information from a given IP. Args: host_ip (str): IP address of the device Returns: InventoryDevice: Device information \"\"\" if self . _is_ip_exist ( host_ip ): return [ dev for dev in self . _inventory if str ( dev . host ) == str ( host_ip )][ 0 ] return None def get_device_session ( self , host_ip : str ) -> Server : \"\"\"Expose RPC session of a given host from our inventory. Provide RPC session if the session exists, if not, it returns None Args: host_ip (str): IP address of the host to match Returns: jsonrpclib.Server: Instance to the device. None if session does not exist \"\"\" device = self . get_device ( host_ip = host_ip ) if device is None : return None return device . session ########################################################################### ### CREATE methods def create_all_sessions ( self , refresh_online_first : bool = False ) -> None : \"\"\"Helper to build RPC sessions to all devices. Args: refresh_online_first (bool): Run a refresh of is_online flag for all devices. \"\"\" if refresh_online_first : logger . debug ( f 'Running a refresh for devices online' ) self . refresh_device_facts () for device in self . _inventory : self . create_device_session ( host_ip = device . host ) def create_device_session ( self , host_ip : str ) -> bool : \"\"\"Get session of a device. If device has already a session, function only returns active session, if not, try to build a new session Args: host_ip (str): IP address of the device Returns: bool: True if update succeed, False if not \"\"\" logger . debug ( f 'Searching for device { host_ip } in { [ str ( dev . host ) for dev in self . _inventory ] } ' ) if len ([ dev for dev in self . _inventory if str ( dev . host ) == str ( host_ip )]) > 0 : device = [ dev for dev in self . _inventory if str ( dev . host ) == str ( host_ip )][ 0 ] logger . debug ( f 'Search result is: { device } ' ) if device . is_online and not device . established and self . _is_ip_exist ( host_ip ): logger . debug ( f 'Trying to connect to device { str ( device . host ) } ' ) device = self . _build_device_session ( device = device , timeout = self . timeout ) # pylint: disable=W0104 [ device if dev . host == device . host else dev for dev in self . _inventory ] return True return False ########################################################################### ### MISC methods def set_credentials ( self , username : str = None , password : str = None , enable_password : str = None ): self . _username = username self . _password = password self . _enable_password = enable_password def connect_inventory ( self ): \"\"\"connect_inventory Helper to prepare inventory with network data.\"\"\" # Check if devices are online & update is_online flag self . refresh_device_facts () # Create eAPI session for all online devices self . create_all_sessions () def refresh_device_facts ( self ) -> None : \"\"\" refresh_online_flag_inventory Update is_online flag for all devices. Execute in parallel a call to _refresh_online_flag_device to test device connectivity. \"\"\" logger . debug ( f 'Refreshing facts for current inventory' ) with Pool ( processes = self . max_multiprocessing_thread ) as pool : logger . debug ( f 'Check devices using multiprocessing' ) results_map = pool . map ( self . _get_from_device , self . _inventory ) logger . debug ( f 'Update inventory with updated data' ) self . _inventory = self . _inventory_rebuild ( results_map ) __init__ ( inventory_file , username , password , enable_password = None , auto_connect = True , timeout = 5 ) \u00b6 Class constructor. Parameters: Name Type Description Default inventory_file str Path to inventory YAML file where user has described his inputs required username str Username to use to connect to devices required password str Password to use to connect to devices required auto_connect bool Automatically build eAPI context for every devices. Defaults to True. True timeout float Timeout in second to wait before marking device down. Defaults to 5sec. 5 Source code in anta/inventory/__init__.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def __init__ ( self , inventory_file : str , username : str , password : str , enable_password : str = None , auto_connect : bool = True , timeout : float = 5 ) -> None : \"\"\"Class constructor. Args: inventory_file (str): Path to inventory YAML file where user has described his inputs username (str): Username to use to connect to devices password (str): Password to use to connect to devices auto_connect (bool, optional): Automatically build eAPI context for every devices. Defaults to True. timeout (float, optional): Timeout in second to wait before marking device down. Defaults to 5sec. \"\"\" self . set_credentials ( username , password , enable_password ) self . timeout = timeout self . _inventory = InventoryDevices () # Max number of thread to launch for discovery self . max_multiprocessing_thread = cpu_count () + 30 with open ( inventory_file , 'r' , encoding = 'utf8' ) as f : data = yaml . load ( f , Loader = SafeLoader ) # Load data using Pydantic try : self . _read_inventory = AntaInventoryInput ( ** data [ self . INVENTORY_ROOT_KEY ] ) except KeyError as exc : logger . error ( f 'Inventory root key is missing: { self . INVENTORY_ROOT_KEY } ' ) raise InventoryRootKeyErrors ( f 'Inventory root key ( { self . INVENTORY_ROOT_KEY } ) is not defined in your inventory' ) from exc except ValidationError as exc : logger . error ( 'Inventory data are not compliant with inventory models' ) raise InventoryIncorrectSchema ( 'Inventory is not following schema' ) from exc # Read data from input if self . _read_inventory . dict ()[ 'hosts' ] is not None : self . _inventory_read_hosts () if self . _read_inventory . dict ()[ 'networks' ] is not None : self . _inventory_read_networks () if self . _read_inventory . dict ()[ 'ranges' ] is not None : self . _inventory_read_ranges () # Create RPC connection for all devices if auto_connect : self . connect_inventory () connect_inventory () \u00b6 connect_inventory Helper to prepare inventory with network data. Source code in anta/inventory/__init__.py 486 487 488 489 490 491 492 def connect_inventory ( self ): \"\"\"connect_inventory Helper to prepare inventory with network data.\"\"\" # Check if devices are online & update is_online flag self . refresh_device_facts () # Create eAPI session for all online devices self . create_all_sessions () create_all_sessions ( refresh_online_first = False ) \u00b6 Helper to build RPC sessions to all devices. Parameters: Name Type Description Default refresh_online_first bool Run a refresh of is_online flag for all devices. False Source code in anta/inventory/__init__.py 439 440 441 442 443 444 445 446 447 448 449 450 def create_all_sessions ( self , refresh_online_first : bool = False ) -> None : \"\"\"Helper to build RPC sessions to all devices. Args: refresh_online_first (bool): Run a refresh of is_online flag for all devices. \"\"\" if refresh_online_first : logger . debug ( f 'Running a refresh for devices online' ) self . refresh_device_facts () for device in self . _inventory : self . create_device_session ( host_ip = device . host ) create_device_session ( host_ip ) \u00b6 Get session of a device. If device has already a session, function only returns active session, if not, try to build a new session Parameters: Name Type Description Default host_ip str IP address of the device required Returns: Name Type Description bool bool True if update succeed, False if not Source code in anta/inventory/__init__.py 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 def create_device_session ( self , host_ip : str ) -> bool : \"\"\"Get session of a device. If device has already a session, function only returns active session, if not, try to build a new session Args: host_ip (str): IP address of the device Returns: bool: True if update succeed, False if not \"\"\" logger . debug ( f 'Searching for device { host_ip } in { [ str ( dev . host ) for dev in self . _inventory ] } ' ) if len ([ dev for dev in self . _inventory if str ( dev . host ) == str ( host_ip )]) > 0 : device = [ dev for dev in self . _inventory if str ( dev . host ) == str ( host_ip )][ 0 ] logger . debug ( f 'Search result is: { device } ' ) if device . is_online and not device . established and self . _is_ip_exist ( host_ip ): logger . debug ( f 'Trying to connect to device { str ( device . host ) } ' ) device = self . _build_device_session ( device = device , timeout = self . timeout ) # pylint: disable=W0104 [ device if dev . host == device . host else dev for dev in self . _inventory ] return True return False get_device ( host_ip ) \u00b6 Get device information from a given IP. Parameters: Name Type Description Default host_ip str IP address of the device required Returns: Name Type Description InventoryDevice InventoryDevice Device information Source code in anta/inventory/__init__.py 407 408 409 410 411 412 413 414 415 416 417 418 def get_device ( self , host_ip ) -> InventoryDevice : \"\"\"Get device information from a given IP. Args: host_ip (str): IP address of the device Returns: InventoryDevice: Device information \"\"\" if self . _is_ip_exist ( host_ip ): return [ dev for dev in self . _inventory if str ( dev . host ) == str ( host_ip )][ 0 ] return None get_device_session ( host_ip ) \u00b6 Expose RPC session of a given host from our inventory. Provide RPC session if the session exists, if not, it returns None Parameters: Name Type Description Default host_ip str IP address of the host to match required Returns: Type Description Server jsonrpclib.Server: Instance to the device. None if session does not exist Source code in anta/inventory/__init__.py 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 def get_device_session ( self , host_ip : str ) -> Server : \"\"\"Expose RPC session of a given host from our inventory. Provide RPC session if the session exists, if not, it returns None Args: host_ip (str): IP address of the host to match Returns: jsonrpclib.Server: Instance to the device. None if session does not exist \"\"\" device = self . get_device ( host_ip = host_ip ) if device is None : return None return device . session get_inventory ( format_out = 'native' , established_only = True ) \u00b6 get_inventory Expose device inventory. Provides inventory has a list of InventoryDevice objects. If requried, it can be exposed in JSON format. Also, by default expose only active devices. Parameters: Name Type Description Default format str Format output, can be native, list or JSON. Defaults to \u2018native\u2019. required established_only bool Allow to expose also unreachable devices. Defaults to True. True Returns: Name Type Description InventoryDevices InventoryDevices List of InventoryDevice Source code in anta/inventory/__init__.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 def get_inventory ( self , format_out : str = 'native' , established_only : bool = True ) -> InventoryDevices : \"\"\"get_inventory Expose device inventory. Provides inventory has a list of InventoryDevice objects. If requried, it can be exposed in JSON format. Also, by default expose only active devices. Args: format (str, optional): Format output, can be native, list or JSON. Defaults to 'native'. established_only (bool, optional): Allow to expose also unreachable devices. Defaults to True. Returns: InventoryDevices: List of InventoryDevice \"\"\" if format_out not in [ 'native' , 'json' , 'list' ]: raise InventoryUnknownFormat ( f 'Unsupported inventory format: { format_out } . Only supported format are: { self . INVENTORY_OUTPUT_FORMAT } ' ) inventory = self . _filtered_inventory ( established_only ) if format_out == 'list' : # pylint: disable=R1721 return [ dev for dev in inventory ] if format_out == 'json' : return inventory . json () return inventory refresh_device_facts () \u00b6 refresh_online_flag_inventory Update is_online flag for all devices. Execute in parallel a call to _refresh_online_flag_device to test device connectivity. Source code in anta/inventory/__init__.py 495 496 497 498 499 500 501 502 503 504 505 506 507 def refresh_device_facts ( self ) -> None : \"\"\" refresh_online_flag_inventory Update is_online flag for all devices. Execute in parallel a call to _refresh_online_flag_device to test device connectivity. \"\"\" logger . debug ( f 'Refreshing facts for current inventory' ) with Pool ( processes = self . max_multiprocessing_thread ) as pool : logger . debug ( f 'Check devices using multiprocessing' ) results_map = pool . map ( self . _get_from_device , self . _inventory ) logger . debug ( f 'Update inventory with updated data' ) self . _inventory = self . _inventory_rebuild ( results_map ) Exceptions \u00b6 Manage Exception in Inventory module. InventoryIncorrectSchema \u00b6 Bases: Exception Error when user data does not follow ANTA schema. Source code in anta/inventory/exceptions.py 10 11 class InventoryIncorrectSchema ( Exception ): \"\"\"Error when user data does not follow ANTA schema.\"\"\" InventoryRootKeyErrors \u00b6 Bases: Exception Error raised when inventory root key is not found. Source code in anta/inventory/exceptions.py 7 8 class InventoryRootKeyErrors ( Exception ): \"\"\"Error raised when inventory root key is not found.\"\"\" InventoryUnknownFormat \u00b6 Bases: Exception Error when inventory format output is not a supported one. Source code in anta/inventory/exceptions.py 13 14 class InventoryUnknownFormat ( Exception ): \"\"\"Error when inventory format output is not a supported one.\"\"\"","title":"Inventory module"},{"location":"api/inventory/#anta-inventory-module","text":"Inventory Abstraction for ANTA framework. Attributes: Name Type Description timeout(float) Connection to device timeout. INVENTORY_ROOT_KEY(str, Optional head of the YAML inventory. Default is anta_inventory EAPI_SESSION_TPL(str, Optional Template for eAPI URL builder INVENTORY_OUTPUT_FORMAT List [ str ], Optional List of supported output format. Default [\u2018native\u2019, \u2018json\u2019] HW_MODEL_KEY str , Optional Name of the key in Arista eAPI JSON provided by device. Examples: Inventory file input print ( inventory . yml ) anta_inventory : hosts : - hosts : 1 . 1 . 1 . 1 - host : 2 . 2 . 2 . 2 networks : - network : 10 . 0 . 0 . 0 / 8 - network : 192 . 168 . 0 . 0 / 16 ranges : - start : 10 . 0 . 0 . 1 end : 10 . 0 . 0 . 11 Inventory result: test = AntaInventory ( ... inventory_file = ' examples / inventory . yml ' , ... username = ' ansible ' , ... password = ' ansible ' , ... auto_connect = True ) test . get_inventory () [ \"InventoryDevice(host=IPv4Address('192.168.0.17')\" , \"username='ansible'\" , \"password='ansible'\" , \"session=<ServerProxy for ansible:ansible@192.168.0.17/command-api>\" , \"url='https://ansible:ansible@192.168.0.17/command-api'\" , \"established=True\" , \"is_online=True\" , \"hw_model=cEOS-LAB\" , ... \"InventoryDevice(host=IPv4Address('192.168.0.2')\" , \"username='ansible'\" , \"password='ansible'\" , \"session=None\" , \"url='https://ansible:ansible@192.168.0.2/command-api'\" , \"established=False\" \"is_online=False\" , \"hw_model=unset\" , ] Raises: Type Description InventoryRootKeyErrors Root key of inventory is missing. InventoryIncorrectSchema Inventory file is not following AntaInventory Schema. InventoryUnknownFormat Output format is not supported. Source code in anta/inventory/__init__.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 class AntaInventory (): \"\"\" Inventory Abstraction for ANTA framework. Attributes: timeout(float): Connection to device timeout. INVENTORY_ROOT_KEY(str, Optional): head of the YAML inventory. Default is anta_inventory EAPI_SESSION_TPL(str, Optional): Template for eAPI URL builder INVENTORY_OUTPUT_FORMAT (List[str],Optional): List of supported output format. Default ['native', 'json'] HW_MODEL_KEY (str,Optional): Name of the key in Arista eAPI JSON provided by device. Examples: Inventory file input print(inventory.yml) anta_inventory: hosts: - hosts: 1.1.1.1 - host: 2.2.2.2 networks: - network: 10.0.0.0/8 - network: 192.168.0.0/16 ranges: - start: 10.0.0.1 end: 10.0.0.11 Inventory result: test = AntaInventory( ... inventory_file='examples/inventory.yml', ... username='ansible', ... password='ansible', ... auto_connect=True) test.get_inventory() [ \"InventoryDevice(host=IPv4Address('192.168.0.17')\", \"username='ansible'\", \"password='ansible'\", \"session=<ServerProxy for ansible:ansible@192.168.0.17/command-api>\", \"url='https://ansible:ansible@192.168.0.17/command-api'\", \"established=True\", \"is_online=True\", \"hw_model=cEOS-LAB\", ... \"InventoryDevice(host=IPv4Address('192.168.0.2')\", \"username='ansible'\", \"password='ansible'\", \"session=None\", \"url='https://ansible:ansible@192.168.0.2/command-api'\", \"established=False\" \"is_online=False\", \"hw_model=unset\", ] Raises: InventoryRootKeyErrors: Root key of inventory is missing. InventoryIncorrectSchema: Inventory file is not following AntaInventory Schema. InventoryUnknownFormat: Output format is not supported. \"\"\" # Root key of inventory part of the inventory file INVENTORY_ROOT_KEY = 'anta_inventory' # Template to build eAPI connection URL EAPI_SESSION_TPL = 'https://{{device_username}}:{{device_password}}@{{device}}/command-api' # Supported Output format INVENTORY_OUTPUT_FORMAT = [ 'native' , 'json' ] # HW model definition in show version HW_MODEL_KEY = 'modelName' # pylint: disable=R0913 def __init__ ( self , inventory_file : str , username : str , password : str , enable_password : str = None , auto_connect : bool = True , timeout : float = 5 ) -> None : \"\"\"Class constructor. Args: inventory_file (str): Path to inventory YAML file where user has described his inputs username (str): Username to use to connect to devices password (str): Password to use to connect to devices auto_connect (bool, optional): Automatically build eAPI context for every devices. Defaults to True. timeout (float, optional): Timeout in second to wait before marking device down. Defaults to 5sec. \"\"\" self . set_credentials ( username , password , enable_password ) self . timeout = timeout self . _inventory = InventoryDevices () # Max number of thread to launch for discovery self . max_multiprocessing_thread = cpu_count () + 30 with open ( inventory_file , 'r' , encoding = 'utf8' ) as f : data = yaml . load ( f , Loader = SafeLoader ) # Load data using Pydantic try : self . _read_inventory = AntaInventoryInput ( ** data [ self . INVENTORY_ROOT_KEY ] ) except KeyError as exc : logger . error ( f 'Inventory root key is missing: { self . INVENTORY_ROOT_KEY } ' ) raise InventoryRootKeyErrors ( f 'Inventory root key ( { self . INVENTORY_ROOT_KEY } ) is not defined in your inventory' ) from exc except ValidationError as exc : logger . error ( 'Inventory data are not compliant with inventory models' ) raise InventoryIncorrectSchema ( 'Inventory is not following schema' ) from exc # Read data from input if self . _read_inventory . dict ()[ 'hosts' ] is not None : self . _inventory_read_hosts () if self . _read_inventory . dict ()[ 'networks' ] is not None : self . _inventory_read_networks () if self . _read_inventory . dict ()[ 'ranges' ] is not None : self . _inventory_read_ranges () # Create RPC connection for all devices if auto_connect : self . connect_inventory () ########################################################################### ### Boolean methods ########################################################################### def _is_ip_exist ( self , ip : str ) -> bool : \"\"\"Check if an IP is part of the current inventory. Args: ip (str): IP address to search in our inventory Returns: bool: True if device is in our inventory, False if not \"\"\" logger . debug ( f 'Checking if device { ip } is in ourr inventory' ) return len ([ str ( dev . host ) for dev in self . _inventory if str ( ip ) == str ( dev . host )]) == 1 def _is_device_online ( self , device : InventoryDevice , timeout : float = 5 ) -> bool : \"\"\" _is_device_online Check if device is online. Execute an eAPI call to check if device is online and has eAPI working as expected If device is ready to serve request, method returns True, else return False. Args: device (InventoryDevice): InventoryDevice structure to test timeout (float, optional): Request timeout. Defaults to 5. Returns: bool: True if device ready, False by default. \"\"\" logger . debug ( f 'Checking if device { device . host } is online' ) connection = Server ( device . url ) # Check connectivity try : setdefaulttimeout ( timeout ) connection . runCmds ( 1 ,[ 'show version' ]) # pylint: disable=W0703 except Exception : logger . warning ( f 'Service not running on device { device . host } ' ) return False else : return True ########################################################################### ### Internal methods ########################################################################### def _read_device_hw ( self , device : InventoryDevice , timeout : float = 5 ) -> str : \"\"\" _read_device_hw Read HW model from the device and update entry with correct value. It returns HW model name from show version or None if device is not reachable or if it cannot find the modelName key Args: device (InventoryDevice): Device to update timeout (float, optional): Connection timeout. Defaults to 5. Returns: str: HW value read from the device using show version. \"\"\" logger . debug ( f 'Reading HW information for { device . host } ' ) connection = Server ( device . url ) try : setdefaulttimeout ( timeout ) response = connection . runCmds ( 1 , [ 'show version' ]) # pylint: disable=W0703 except Exception : logger . warning ( f 'Service not running on device { device . host } ' ) return None else : return response [ 0 ][ self . HW_MODEL_KEY ] if self . HW_MODEL_KEY in response [ 0 ] else None def _get_from_device ( self , device : InventoryDevice ) -> InventoryDevice : \"\"\" _get_from_device Update online flag for InventoryDevice. It updates following keys: - is_online - hw_model Args: device (InventoryDevice): Device to check using InventoryDevice structure. Returns: InventoryDevice: Updated structure with devices information (is_online, HW model) \"\"\" logger . debug ( f 'Refreshing is_online flag for device { device . host } ' ) device . is_online = self . _is_device_online ( device = device , timeout = self . timeout ) if device . is_online : device . hw_model = self . _read_device_hw ( device = device , timeout = self . timeout ) return device def _build_device_session_path ( self , host : str , username : str , password : str ) -> str : \"\"\"Construct URL to reach device using eAPI. Jinja2 render to build URL to use for eAPI session. Args: host (str): IP Address of the device to target in the eAPI session username (str): Username for authentication password (str): Password for authentication Returns: str: String to use to create eAPI session \"\"\" session_template = Template ( self . EAPI_SESSION_TPL ) return session_template . render ( device = host , device_username = username , device_password = password ) def _build_device_session ( self , device : InventoryDevice , timeout : float = 5 ) -> InventoryDevice : \"\"\"Create eAPI RPC session to Arista EOS devices. Args: device (InventoryDevice): Device information based on InventoryDevice structure timeout (int, optional): Device timeout to declare host as down. Defaults to 5. Returns: InventoryDevice: Updated device structure with its RPC connection \"\"\" connection = Server ( device . url ) # Check connectivity try : setdefaulttimeout ( timeout ) connection . runCmds ( 1 , [ 'show version' ]) # pylint: disable=W0703 except Exception : logger . warning ( f 'Service not running on device { device . host } ' ) device . session = None else : device . established = True device . session = connection return device def _add_device_to_inventory ( self , host_ip ) -> None : \"\"\"Add a InventoryDevice to final inventory. Create InventoryDevice and append to existing inventory Args: host_ip (str): IP address of the host \"\"\" device = InventoryDevice ( host = host_ip , username = self . _username , password = self . _password , enable_password = self . _enable_password , url = self . _build_device_session_path ( host = host_ip , username = self . _username , password = self . _password ) ) self . _inventory . append ( device ) def _inventory_read_hosts ( self ) -> None : \"\"\"Read input data from hosts section and create inventory structure. Build InventoryDevice structure for all hosts under hosts section \"\"\" for host in self . _read_inventory . hosts : self . _add_device_to_inventory ( host_ip = host . host ) def _inventory_read_networks ( self ) -> None : \"\"\"Read input data from networks section and create inventory structure. Build InventoryDevice structure for all IPs available in each declared subnet \"\"\" for network in self . _read_inventory . networks : for host_ip in IPNetwork ( str ( network . network )): self . _add_device_to_inventory ( host_ip = host_ip ) def _inventory_read_ranges ( self ) -> None : \"\"\"Read input data from ranges section and create inventory structure. Build InventoryDevice structure for all IPs available in each declared range \"\"\" for range_def in self . _read_inventory . ranges : range_increment = IPAddress ( str ( range_def . start )) range_stop = IPAddress ( str ( range_def . end )) while range_increment <= range_stop : self . _add_device_to_inventory ( host_ip = str ( range_increment )) range_increment += 1 def _inventory_rebuild ( self , list_devices : List [ InventoryDevice ]) -> InventoryDevices : \"\"\" _inventory_rebuild Transform a list of InventoryDevice into a InventoryDevices object. Args: list_devices (List[InventoryDevice]): List of devices to add into InventoryDevices Returns: InventoryDevices: An object with all the devices. \"\"\" logger . debug ( f 'Create a new version of InventoryDevices' ) inventory = InventoryDevices () for device in list_devices : inventory . append ( device ) return inventory def _filtered_inventory ( self , established_only : bool = False ) -> InventoryDevices : \"\"\" _filtered_inventory Generate a temporary inventory filtered. Args: established_only (bool, optional): Do we have to include non-established devices. Defaults to False. Returns: InventoryDevices: A inventory with concerned devices \"\"\" inventory = InventoryDevices () if established_only is False : return self . _inventory for device in self . _inventory : if device . established : inventory . append ( device ) return inventory ########################################################################### ### Public methods ########################################################################### ########################################################################### ### GET methods def get_inventory ( self , format_out : str = 'native' , established_only : bool = True ) -> InventoryDevices : \"\"\"get_inventory Expose device inventory. Provides inventory has a list of InventoryDevice objects. If requried, it can be exposed in JSON format. Also, by default expose only active devices. Args: format (str, optional): Format output, can be native, list or JSON. Defaults to 'native'. established_only (bool, optional): Allow to expose also unreachable devices. Defaults to True. Returns: InventoryDevices: List of InventoryDevice \"\"\" if format_out not in [ 'native' , 'json' , 'list' ]: raise InventoryUnknownFormat ( f 'Unsupported inventory format: { format_out } . Only supported format are: { self . INVENTORY_OUTPUT_FORMAT } ' ) inventory = self . _filtered_inventory ( established_only ) if format_out == 'list' : # pylint: disable=R1721 return [ dev for dev in inventory ] if format_out == 'json' : return inventory . json () return inventory def get_device ( self , host_ip ) -> InventoryDevice : \"\"\"Get device information from a given IP. Args: host_ip (str): IP address of the device Returns: InventoryDevice: Device information \"\"\" if self . _is_ip_exist ( host_ip ): return [ dev for dev in self . _inventory if str ( dev . host ) == str ( host_ip )][ 0 ] return None def get_device_session ( self , host_ip : str ) -> Server : \"\"\"Expose RPC session of a given host from our inventory. Provide RPC session if the session exists, if not, it returns None Args: host_ip (str): IP address of the host to match Returns: jsonrpclib.Server: Instance to the device. None if session does not exist \"\"\" device = self . get_device ( host_ip = host_ip ) if device is None : return None return device . session ########################################################################### ### CREATE methods def create_all_sessions ( self , refresh_online_first : bool = False ) -> None : \"\"\"Helper to build RPC sessions to all devices. Args: refresh_online_first (bool): Run a refresh of is_online flag for all devices. \"\"\" if refresh_online_first : logger . debug ( f 'Running a refresh for devices online' ) self . refresh_device_facts () for device in self . _inventory : self . create_device_session ( host_ip = device . host ) def create_device_session ( self , host_ip : str ) -> bool : \"\"\"Get session of a device. If device has already a session, function only returns active session, if not, try to build a new session Args: host_ip (str): IP address of the device Returns: bool: True if update succeed, False if not \"\"\" logger . debug ( f 'Searching for device { host_ip } in { [ str ( dev . host ) for dev in self . _inventory ] } ' ) if len ([ dev for dev in self . _inventory if str ( dev . host ) == str ( host_ip )]) > 0 : device = [ dev for dev in self . _inventory if str ( dev . host ) == str ( host_ip )][ 0 ] logger . debug ( f 'Search result is: { device } ' ) if device . is_online and not device . established and self . _is_ip_exist ( host_ip ): logger . debug ( f 'Trying to connect to device { str ( device . host ) } ' ) device = self . _build_device_session ( device = device , timeout = self . timeout ) # pylint: disable=W0104 [ device if dev . host == device . host else dev for dev in self . _inventory ] return True return False ########################################################################### ### MISC methods def set_credentials ( self , username : str = None , password : str = None , enable_password : str = None ): self . _username = username self . _password = password self . _enable_password = enable_password def connect_inventory ( self ): \"\"\"connect_inventory Helper to prepare inventory with network data.\"\"\" # Check if devices are online & update is_online flag self . refresh_device_facts () # Create eAPI session for all online devices self . create_all_sessions () def refresh_device_facts ( self ) -> None : \"\"\" refresh_online_flag_inventory Update is_online flag for all devices. Execute in parallel a call to _refresh_online_flag_device to test device connectivity. \"\"\" logger . debug ( f 'Refreshing facts for current inventory' ) with Pool ( processes = self . max_multiprocessing_thread ) as pool : logger . debug ( f 'Check devices using multiprocessing' ) results_map = pool . map ( self . _get_from_device , self . _inventory ) logger . debug ( f 'Update inventory with updated data' ) self . _inventory = self . _inventory_rebuild ( results_map )","title":"ANTA Inventory module"},{"location":"api/inventory/#anta.inventory.AntaInventory.__init__","text":"Class constructor. Parameters: Name Type Description Default inventory_file str Path to inventory YAML file where user has described his inputs required username str Username to use to connect to devices required password str Password to use to connect to devices required auto_connect bool Automatically build eAPI context for every devices. Defaults to True. True timeout float Timeout in second to wait before marking device down. Defaults to 5sec. 5 Source code in anta/inventory/__init__.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def __init__ ( self , inventory_file : str , username : str , password : str , enable_password : str = None , auto_connect : bool = True , timeout : float = 5 ) -> None : \"\"\"Class constructor. Args: inventory_file (str): Path to inventory YAML file where user has described his inputs username (str): Username to use to connect to devices password (str): Password to use to connect to devices auto_connect (bool, optional): Automatically build eAPI context for every devices. Defaults to True. timeout (float, optional): Timeout in second to wait before marking device down. Defaults to 5sec. \"\"\" self . set_credentials ( username , password , enable_password ) self . timeout = timeout self . _inventory = InventoryDevices () # Max number of thread to launch for discovery self . max_multiprocessing_thread = cpu_count () + 30 with open ( inventory_file , 'r' , encoding = 'utf8' ) as f : data = yaml . load ( f , Loader = SafeLoader ) # Load data using Pydantic try : self . _read_inventory = AntaInventoryInput ( ** data [ self . INVENTORY_ROOT_KEY ] ) except KeyError as exc : logger . error ( f 'Inventory root key is missing: { self . INVENTORY_ROOT_KEY } ' ) raise InventoryRootKeyErrors ( f 'Inventory root key ( { self . INVENTORY_ROOT_KEY } ) is not defined in your inventory' ) from exc except ValidationError as exc : logger . error ( 'Inventory data are not compliant with inventory models' ) raise InventoryIncorrectSchema ( 'Inventory is not following schema' ) from exc # Read data from input if self . _read_inventory . dict ()[ 'hosts' ] is not None : self . _inventory_read_hosts () if self . _read_inventory . dict ()[ 'networks' ] is not None : self . _inventory_read_networks () if self . _read_inventory . dict ()[ 'ranges' ] is not None : self . _inventory_read_ranges () # Create RPC connection for all devices if auto_connect : self . connect_inventory ()","title":"__init__()"},{"location":"api/inventory/#anta.inventory.AntaInventory.connect_inventory","text":"connect_inventory Helper to prepare inventory with network data. Source code in anta/inventory/__init__.py 486 487 488 489 490 491 492 def connect_inventory ( self ): \"\"\"connect_inventory Helper to prepare inventory with network data.\"\"\" # Check if devices are online & update is_online flag self . refresh_device_facts () # Create eAPI session for all online devices self . create_all_sessions ()","title":"connect_inventory()"},{"location":"api/inventory/#anta.inventory.AntaInventory.create_all_sessions","text":"Helper to build RPC sessions to all devices. Parameters: Name Type Description Default refresh_online_first bool Run a refresh of is_online flag for all devices. False Source code in anta/inventory/__init__.py 439 440 441 442 443 444 445 446 447 448 449 450 def create_all_sessions ( self , refresh_online_first : bool = False ) -> None : \"\"\"Helper to build RPC sessions to all devices. Args: refresh_online_first (bool): Run a refresh of is_online flag for all devices. \"\"\" if refresh_online_first : logger . debug ( f 'Running a refresh for devices online' ) self . refresh_device_facts () for device in self . _inventory : self . create_device_session ( host_ip = device . host )","title":"create_all_sessions()"},{"location":"api/inventory/#anta.inventory.AntaInventory.create_device_session","text":"Get session of a device. If device has already a session, function only returns active session, if not, try to build a new session Parameters: Name Type Description Default host_ip str IP address of the device required Returns: Name Type Description bool bool True if update succeed, False if not Source code in anta/inventory/__init__.py 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 def create_device_session ( self , host_ip : str ) -> bool : \"\"\"Get session of a device. If device has already a session, function only returns active session, if not, try to build a new session Args: host_ip (str): IP address of the device Returns: bool: True if update succeed, False if not \"\"\" logger . debug ( f 'Searching for device { host_ip } in { [ str ( dev . host ) for dev in self . _inventory ] } ' ) if len ([ dev for dev in self . _inventory if str ( dev . host ) == str ( host_ip )]) > 0 : device = [ dev for dev in self . _inventory if str ( dev . host ) == str ( host_ip )][ 0 ] logger . debug ( f 'Search result is: { device } ' ) if device . is_online and not device . established and self . _is_ip_exist ( host_ip ): logger . debug ( f 'Trying to connect to device { str ( device . host ) } ' ) device = self . _build_device_session ( device = device , timeout = self . timeout ) # pylint: disable=W0104 [ device if dev . host == device . host else dev for dev in self . _inventory ] return True return False","title":"create_device_session()"},{"location":"api/inventory/#anta.inventory.AntaInventory.get_device","text":"Get device information from a given IP. Parameters: Name Type Description Default host_ip str IP address of the device required Returns: Name Type Description InventoryDevice InventoryDevice Device information Source code in anta/inventory/__init__.py 407 408 409 410 411 412 413 414 415 416 417 418 def get_device ( self , host_ip ) -> InventoryDevice : \"\"\"Get device information from a given IP. Args: host_ip (str): IP address of the device Returns: InventoryDevice: Device information \"\"\" if self . _is_ip_exist ( host_ip ): return [ dev for dev in self . _inventory if str ( dev . host ) == str ( host_ip )][ 0 ] return None","title":"get_device()"},{"location":"api/inventory/#anta.inventory.AntaInventory.get_device_session","text":"Expose RPC session of a given host from our inventory. Provide RPC session if the session exists, if not, it returns None Parameters: Name Type Description Default host_ip str IP address of the host to match required Returns: Type Description Server jsonrpclib.Server: Instance to the device. None if session does not exist Source code in anta/inventory/__init__.py 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 def get_device_session ( self , host_ip : str ) -> Server : \"\"\"Expose RPC session of a given host from our inventory. Provide RPC session if the session exists, if not, it returns None Args: host_ip (str): IP address of the host to match Returns: jsonrpclib.Server: Instance to the device. None if session does not exist \"\"\" device = self . get_device ( host_ip = host_ip ) if device is None : return None return device . session","title":"get_device_session()"},{"location":"api/inventory/#anta.inventory.AntaInventory.get_inventory","text":"get_inventory Expose device inventory. Provides inventory has a list of InventoryDevice objects. If requried, it can be exposed in JSON format. Also, by default expose only active devices. Parameters: Name Type Description Default format str Format output, can be native, list or JSON. Defaults to \u2018native\u2019. required established_only bool Allow to expose also unreachable devices. Defaults to True. True Returns: Name Type Description InventoryDevices InventoryDevices List of InventoryDevice Source code in anta/inventory/__init__.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 def get_inventory ( self , format_out : str = 'native' , established_only : bool = True ) -> InventoryDevices : \"\"\"get_inventory Expose device inventory. Provides inventory has a list of InventoryDevice objects. If requried, it can be exposed in JSON format. Also, by default expose only active devices. Args: format (str, optional): Format output, can be native, list or JSON. Defaults to 'native'. established_only (bool, optional): Allow to expose also unreachable devices. Defaults to True. Returns: InventoryDevices: List of InventoryDevice \"\"\" if format_out not in [ 'native' , 'json' , 'list' ]: raise InventoryUnknownFormat ( f 'Unsupported inventory format: { format_out } . Only supported format are: { self . INVENTORY_OUTPUT_FORMAT } ' ) inventory = self . _filtered_inventory ( established_only ) if format_out == 'list' : # pylint: disable=R1721 return [ dev for dev in inventory ] if format_out == 'json' : return inventory . json () return inventory","title":"get_inventory()"},{"location":"api/inventory/#anta.inventory.AntaInventory.refresh_device_facts","text":"refresh_online_flag_inventory Update is_online flag for all devices. Execute in parallel a call to _refresh_online_flag_device to test device connectivity. Source code in anta/inventory/__init__.py 495 496 497 498 499 500 501 502 503 504 505 506 507 def refresh_device_facts ( self ) -> None : \"\"\" refresh_online_flag_inventory Update is_online flag for all devices. Execute in parallel a call to _refresh_online_flag_device to test device connectivity. \"\"\" logger . debug ( f 'Refreshing facts for current inventory' ) with Pool ( processes = self . max_multiprocessing_thread ) as pool : logger . debug ( f 'Check devices using multiprocessing' ) results_map = pool . map ( self . _get_from_device , self . _inventory ) logger . debug ( f 'Update inventory with updated data' ) self . _inventory = self . _inventory_rebuild ( results_map )","title":"refresh_device_facts()"},{"location":"api/inventory/#exceptions","text":"Manage Exception in Inventory module.","title":"Exceptions"},{"location":"api/inventory/#anta.inventory.exceptions.InventoryIncorrectSchema","text":"Bases: Exception Error when user data does not follow ANTA schema. Source code in anta/inventory/exceptions.py 10 11 class InventoryIncorrectSchema ( Exception ): \"\"\"Error when user data does not follow ANTA schema.\"\"\"","title":"InventoryIncorrectSchema"},{"location":"api/inventory/#anta.inventory.exceptions.InventoryRootKeyErrors","text":"Bases: Exception Error raised when inventory root key is not found. Source code in anta/inventory/exceptions.py 7 8 class InventoryRootKeyErrors ( Exception ): \"\"\"Error raised when inventory root key is not found.\"\"\"","title":"InventoryRootKeyErrors"},{"location":"api/inventory/#anta.inventory.exceptions.InventoryUnknownFormat","text":"Bases: Exception Error when inventory format output is not a supported one. Source code in anta/inventory/exceptions.py 13 14 class InventoryUnknownFormat ( Exception ): \"\"\"Error when inventory format output is not a supported one.\"\"\"","title":"InventoryUnknownFormat"},{"location":"api/inventory.models.input/","text":"Data models for anta.inventory \u00b6 Bases: BaseModel User\u2019s inventory model. Attributes: Name Type Description netwrks(List[AntaInventoryNetwork],Optional) List of AntaInventoryNetwork objects for networks. hosts(List[AntaInventoryHost],Optional) List of AntaInventoryHost objects for hosts. range(List[AntaInventoryRange],Optional) List of AntaInventoryRange objects for ranges. Source code in anta/inventory/models.py 42 43 44 45 46 47 48 49 50 51 52 53 class AntaInventoryInput ( BaseModel ): \"\"\" User's inventory model. Attributes: netwrks(List[AntaInventoryNetwork],Optional): List of AntaInventoryNetwork objects for networks. hosts(List[AntaInventoryHost],Optional): List of AntaInventoryHost objects for hosts. range(List[AntaInventoryRange],Optional): List of AntaInventoryRange objects for ranges. \"\"\" networks : Optional [ List [ AntaInventoryNetwork ]] hosts : Optional [ List [ AntaInventoryHost ]] ranges : Optional [ List [ AntaInventoryRange ]] User inventory components \u00b6 Bases: BaseModel Host definition for user\u2019s inventory. Attributes: Name Type Description host(IPvAnyAddress) IPv4 or IPv6 address of the device Source code in anta/inventory/models.py 13 14 15 16 17 18 19 20 class AntaInventoryHost ( BaseModel ): \"\"\" Host definition for user's inventory. Attributes: host(IPvAnyAddress): IPv4 or IPv6 address of the device \"\"\" host : IPvAnyAddress Bases: BaseModel Network definition for user\u2019s inventory. Attributes: Name Type Description network(IPvAnyNetwork) Subnet to use for testing. Source code in anta/inventory/models.py 22 23 24 25 26 27 28 29 class AntaInventoryNetwork ( BaseModel ): \"\"\" Network definition for user's inventory. Attributes: network(IPvAnyNetwork): Subnet to use for testing. \"\"\" network : IPvAnyNetwork Bases: BaseModel IP Range definition for user\u2019s inventory. Attributes: Name Type Description start(IPvAnyAddress) IPv4 or IPv6 address for the begining of the range. stop(IPvAnyAddress) IPv4 or IPv6 address for the end of the range. Source code in anta/inventory/models.py 31 32 33 34 35 36 37 38 39 40 class AntaInventoryRange ( BaseModel ): \"\"\" IP Range definition for user's inventory. Attributes: start(IPvAnyAddress): IPv4 or IPv6 address for the begining of the range. stop(IPvAnyAddress): IPv4 or IPv6 address for the end of the range. \"\"\" start : IPvAnyAddress end : IPvAnyAddress","title":"User Inventory data model"},{"location":"api/inventory.models.input/#data-models-for-antainventory","text":"Bases: BaseModel User\u2019s inventory model. Attributes: Name Type Description netwrks(List[AntaInventoryNetwork],Optional) List of AntaInventoryNetwork objects for networks. hosts(List[AntaInventoryHost],Optional) List of AntaInventoryHost objects for hosts. range(List[AntaInventoryRange],Optional) List of AntaInventoryRange objects for ranges. Source code in anta/inventory/models.py 42 43 44 45 46 47 48 49 50 51 52 53 class AntaInventoryInput ( BaseModel ): \"\"\" User's inventory model. Attributes: netwrks(List[AntaInventoryNetwork],Optional): List of AntaInventoryNetwork objects for networks. hosts(List[AntaInventoryHost],Optional): List of AntaInventoryHost objects for hosts. range(List[AntaInventoryRange],Optional): List of AntaInventoryRange objects for ranges. \"\"\" networks : Optional [ List [ AntaInventoryNetwork ]] hosts : Optional [ List [ AntaInventoryHost ]] ranges : Optional [ List [ AntaInventoryRange ]]","title":"Data models for anta.inventory"},{"location":"api/inventory.models.input/#user-inventory-components","text":"Bases: BaseModel Host definition for user\u2019s inventory. Attributes: Name Type Description host(IPvAnyAddress) IPv4 or IPv6 address of the device Source code in anta/inventory/models.py 13 14 15 16 17 18 19 20 class AntaInventoryHost ( BaseModel ): \"\"\" Host definition for user's inventory. Attributes: host(IPvAnyAddress): IPv4 or IPv6 address of the device \"\"\" host : IPvAnyAddress Bases: BaseModel Network definition for user\u2019s inventory. Attributes: Name Type Description network(IPvAnyNetwork) Subnet to use for testing. Source code in anta/inventory/models.py 22 23 24 25 26 27 28 29 class AntaInventoryNetwork ( BaseModel ): \"\"\" Network definition for user's inventory. Attributes: network(IPvAnyNetwork): Subnet to use for testing. \"\"\" network : IPvAnyNetwork Bases: BaseModel IP Range definition for user\u2019s inventory. Attributes: Name Type Description start(IPvAnyAddress) IPv4 or IPv6 address for the begining of the range. stop(IPvAnyAddress) IPv4 or IPv6 address for the end of the range. Source code in anta/inventory/models.py 31 32 33 34 35 36 37 38 39 40 class AntaInventoryRange ( BaseModel ): \"\"\" IP Range definition for user's inventory. Attributes: start(IPvAnyAddress): IPv4 or IPv6 address for the begining of the range. stop(IPvAnyAddress): IPv4 or IPv6 address for the end of the range. \"\"\" start : IPvAnyAddress end : IPvAnyAddress","title":"User inventory components"},{"location":"api/inventory.models/","text":"Inventory Entry \u00b6 Bases: BaseModel Inventory model exposed by Inventory class. Attributes: Name Type Description host(IPvAnyAddress) IPv4 or IPv6 address of the device. username(str) Username to use for connection. password(password) Password to use for connection. session(Any) JSONRPC session. established(bool) Flag to mark if connection is established (True) or not (False). Default: False. is_online(bool) Flag to mark if host is alive (True) or not (False). Default: False. hw_model(str) HW name gathered during device discovery. url(str) eAPI URL to use to build session. Source code in anta/inventory/models.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class InventoryDevice ( BaseModel ): \"\"\" Inventory model exposed by Inventory class. Attributes: host(IPvAnyAddress): IPv4 or IPv6 address of the device. username(str): Username to use for connection. password(password): Password to use for connection. session(Any): JSONRPC session. established(bool): Flag to mark if connection is established (True) or not (False). Default: False. is_online(bool): Flag to mark if host is alive (True) or not (False). Default: False. hw_model(str): HW name gathered during device discovery. url(str): eAPI URL to use to build session. \"\"\" host : IPvAnyAddress username : str password : str enable_password : Optional [ str ] session : Any established = False is_online = False hw_model : str = 'unset' url : str Inventory \u00b6 Bases: BaseModel Inventory model to list all InventoryDevice entries. Attributes: Name Type Description __root__(List[InventoryDevice]) A list of InventoryDevice objects. Source code in anta/inventory/models.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class InventoryDevices ( BaseModel ): \"\"\" Inventory model to list all InventoryDevice entries. Attributes: __root__(List[InventoryDevice]): A list of InventoryDevice objects. \"\"\" __root__ = [] def append ( self , value ) -> None : \"\"\"Add support for append method.\"\"\" self . __root__ . append ( value ) super () . __init__ ( __root__ = self . __root__ ) def __iter__ ( self ): \"\"\"Use custom iter method.\"\"\" return iter ( self . __root__ ) def __getitem__ ( self , item ): \"\"\"Use custom getitem method.\"\"\" return self . __root__ [ item ] def __len__ ( self ): \"\"\"Support for length of __root__\"\"\" return len ( self . __root__ ) __getitem__ ( item ) \u00b6 Use custom getitem method. Source code in anta/inventory/models.py 99 100 101 def __getitem__ ( self , item ): \"\"\"Use custom getitem method.\"\"\" return self . __root__ [ item ] __iter__ () \u00b6 Use custom iter method. Source code in anta/inventory/models.py 95 96 97 def __iter__ ( self ): \"\"\"Use custom iter method.\"\"\" return iter ( self . __root__ ) __len__ () \u00b6 Support for length of root Source code in anta/inventory/models.py 103 104 105 def __len__ ( self ): \"\"\"Support for length of __root__\"\"\" return len ( self . __root__ ) append ( value ) \u00b6 Add support for append method. Source code in anta/inventory/models.py 90 91 92 93 def append ( self , value ) -> None : \"\"\"Add support for append method.\"\"\" self . __root__ . append ( value ) super () . __init__ ( __root__ = self . __root__ )","title":"Generated Inventory data model"},{"location":"api/inventory.models/#inventory-entry","text":"Bases: BaseModel Inventory model exposed by Inventory class. Attributes: Name Type Description host(IPvAnyAddress) IPv4 or IPv6 address of the device. username(str) Username to use for connection. password(password) Password to use for connection. session(Any) JSONRPC session. established(bool) Flag to mark if connection is established (True) or not (False). Default: False. is_online(bool) Flag to mark if host is alive (True) or not (False). Default: False. hw_model(str) HW name gathered during device discovery. url(str) eAPI URL to use to build session. Source code in anta/inventory/models.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class InventoryDevice ( BaseModel ): \"\"\" Inventory model exposed by Inventory class. Attributes: host(IPvAnyAddress): IPv4 or IPv6 address of the device. username(str): Username to use for connection. password(password): Password to use for connection. session(Any): JSONRPC session. established(bool): Flag to mark if connection is established (True) or not (False). Default: False. is_online(bool): Flag to mark if host is alive (True) or not (False). Default: False. hw_model(str): HW name gathered during device discovery. url(str): eAPI URL to use to build session. \"\"\" host : IPvAnyAddress username : str password : str enable_password : Optional [ str ] session : Any established = False is_online = False hw_model : str = 'unset' url : str","title":"Inventory Entry"},{"location":"api/inventory.models/#inventory","text":"Bases: BaseModel Inventory model to list all InventoryDevice entries. Attributes: Name Type Description __root__(List[InventoryDevice]) A list of InventoryDevice objects. Source code in anta/inventory/models.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class InventoryDevices ( BaseModel ): \"\"\" Inventory model to list all InventoryDevice entries. Attributes: __root__(List[InventoryDevice]): A list of InventoryDevice objects. \"\"\" __root__ = [] def append ( self , value ) -> None : \"\"\"Add support for append method.\"\"\" self . __root__ . append ( value ) super () . __init__ ( __root__ = self . __root__ ) def __iter__ ( self ): \"\"\"Use custom iter method.\"\"\" return iter ( self . __root__ ) def __getitem__ ( self , item ): \"\"\"Use custom getitem method.\"\"\" return self . __root__ [ item ] def __len__ ( self ): \"\"\"Support for length of __root__\"\"\" return len ( self . __root__ )","title":"Inventory"},{"location":"api/inventory.models/#anta.inventory.models.InventoryDevices.__getitem__","text":"Use custom getitem method. Source code in anta/inventory/models.py 99 100 101 def __getitem__ ( self , item ): \"\"\"Use custom getitem method.\"\"\" return self . __root__ [ item ]","title":"__getitem__()"},{"location":"api/inventory.models/#anta.inventory.models.InventoryDevices.__iter__","text":"Use custom iter method. Source code in anta/inventory/models.py 95 96 97 def __iter__ ( self ): \"\"\"Use custom iter method.\"\"\" return iter ( self . __root__ )","title":"__iter__()"},{"location":"api/inventory.models/#anta.inventory.models.InventoryDevices.__len__","text":"Support for length of root Source code in anta/inventory/models.py 103 104 105 def __len__ ( self ): \"\"\"Support for length of __root__\"\"\" return len ( self . __root__ )","title":"__len__()"},{"location":"api/inventory.models/#anta.inventory.models.InventoryDevices.append","text":"Add support for append method. Source code in anta/inventory/models.py 90 91 92 93 def append ( self , value ) -> None : \"\"\"Add support for append method.\"\"\" self . __root__ . append ( value ) super () . __init__ ( __root__ = self . __root__ )","title":"append()"},{"location":"api/result_manager/","text":"ANTA ResultManager module \u00b6 Helper to manage Test Results and generate reports. Examples: Create Inventory: inventory_anta = AntaInventory( inventory_file='examples/inventory.yml', username='ansible', password='ansible', timeout=0.5, auto_connect=True ) Create Result Manager: manager = ResultManager() Run tests for all connected devices: for device in inventory_anta . get_inventory () : manager . add_test_result ( verify_eos_version ( device = device , versions = [ ' 4.28.0F ' ] ) ) manager . add_test_result ( verify_uptime ( device = device , minimum = 1 ) ) Print result in native format: manager.get_results() [ TestResult( host=IPv4Address('192.168.0.10'), test='verify_eos_version', result='failure', message=\"device is running version 4.27.3F-26379303.4273F (engineering build) and test expect ['4.28.0F']\" ), TestResult( host=IPv4Address('192.168.0.10'), test='verify_eos_version', result='success', message=None ), ] Source code in anta/result_manager/__init__.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 class ResultManager (): \"\"\" Helper to manage Test Results and generate reports. Examples: Create Inventory: inventory_anta = AntaInventory( inventory_file='examples/inventory.yml', username='ansible', password='ansible', timeout=0.5, auto_connect=True ) Create Result Manager: manager = ResultManager() Run tests for all connected devices: for device in inventory_anta.get_inventory(): manager.add_test_result( verify_eos_version( device=device, versions=['4.28.0F'] ) ) manager.add_test_result( verify_uptime( device=device, minimum=1 ) ) Print result in native format: manager.get_results() [ TestResult( host=IPv4Address('192.168.0.10'), test='verify_eos_version', result='failure', message=\"device is running version 4.27.3F-26379303.4273F (engineering build) and test expect ['4.28.0F']\" ), TestResult( host=IPv4Address('192.168.0.10'), test='verify_eos_version', result='success', message=None ), ] \"\"\" def __init__ ( self ) -> None : \"\"\" Class constructor.\"\"\" self . _result_entries = ListResult () def add_test_result ( self , entry : TestResult ) -> None : \"\"\" Add a result to the list Args: entry (TestResult): TestResult data to add to the report \"\"\" self . _result_entries . append ( entry ) def get_results ( self , output_format : str = 'native' ) -> any : \"\"\" Expose list of all test results in different format Support multiple format: - native: ListResults format - list: a list of TestResult - json: a native JSON format Args: output_format (str, optional): format selector. Can be either native/list/json. Defaults to 'native'. Returns: any: List of results. \"\"\" if output_format == 'list' : return list ( self . _result_entries ) if output_format == 'json' : return json . loads ([ result . json () for result in self . _result_entries ]) # Default return for native format. return self . _result_entries def get_result_by_test ( self , test_name : str , output_format : str = 'native' ) -> Any : \"\"\" Get list of test result for a given test. Args: test_name (str): Test name to use to filter results output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'. Returns: list[TestResult]: List of results related to the test. \"\"\" if output_format == 'list' : return [ result for result in self . _result_entries if str ( result . test ) == test_name ] result_manager_filtered = ListResult () for result in self . _result_entries : if result . test == test_name : result_manager_filtered . append ( result ) return result_manager_filtered def get_result_by_host ( self , host_ip : str , output_format : str = 'native' ) -> Any : \"\"\" Get list of test result for a given host. Args: host_ip (str): IP Address of the host to use to filter results. output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'. Returns: Any: List of results related to the host. \"\"\" if output_format == 'list' : return [ result for result in self . _result_entries if str ( result . host ) == host_ip ] result_manager_filtered = ListResult () for result in self . _result_entries : if result . host == host_ip : result_manager_filtered . append ( result ) return result_manager_filtered def table_report ( self , sort_by : str = 'host' , reverse : bool = False , colors : bool = True ) -> tabulate : \"\"\" Build a table report of all tests Args: sort_by (str, optional): Key to use to filter result. Can be either host/test/result. Defaults to 'host'. reverse (bool, optional): Enable reverse sorting. Defaults to False. colors (bool, optional): Select if tests results are colored or not. Defaults to True. Returns: tabulate: A Tabulate str that can be printed. \"\"\" report = TableReport () report . add_content ( results = self . get_results ( output_format = 'list' ), ) return report . get ( sort_by = sort_by , reverse = reverse , enable_colors = colors ) __init__ () \u00b6 Class constructor. Source code in anta/result_manager/__init__.py 70 71 72 def __init__ ( self ) -> None : \"\"\" Class constructor.\"\"\" self . _result_entries = ListResult () add_test_result ( entry ) \u00b6 Add a result to the list Parameters: Name Type Description Default entry TestResult TestResult data to add to the report required Source code in anta/result_manager/__init__.py 74 75 76 77 78 79 80 def add_test_result ( self , entry : TestResult ) -> None : \"\"\" Add a result to the list Args: entry (TestResult): TestResult data to add to the report \"\"\" self . _result_entries . append ( entry ) get_result_by_host ( host_ip , output_format = 'native' ) \u00b6 Get list of test result for a given host. Parameters: Name Type Description Default host_ip str IP Address of the host to use to filter results. required output_format str format selector. Can be either native/list. Defaults to \u2018native\u2019. 'native' Returns: Name Type Description Any Any List of results related to the host. Source code in anta/result_manager/__init__.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def get_result_by_host ( self , host_ip : str , output_format : str = 'native' ) -> Any : \"\"\" Get list of test result for a given host. Args: host_ip (str): IP Address of the host to use to filter results. output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'. Returns: Any: List of results related to the host. \"\"\" if output_format == 'list' : return [ result for result in self . _result_entries if str ( result . host ) == host_ip ] result_manager_filtered = ListResult () for result in self . _result_entries : if result . host == host_ip : result_manager_filtered . append ( result ) return result_manager_filtered get_result_by_test ( test_name , output_format = 'native' ) \u00b6 Get list of test result for a given test. Parameters: Name Type Description Default test_name str Test name to use to filter results required output_format str format selector. Can be either native/list. Defaults to \u2018native\u2019. 'native' Returns: Type Description Any list[TestResult]: List of results related to the test. Source code in anta/result_manager/__init__.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def get_result_by_test ( self , test_name : str , output_format : str = 'native' ) -> Any : \"\"\" Get list of test result for a given test. Args: test_name (str): Test name to use to filter results output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'. Returns: list[TestResult]: List of results related to the test. \"\"\" if output_format == 'list' : return [ result for result in self . _result_entries if str ( result . test ) == test_name ] result_manager_filtered = ListResult () for result in self . _result_entries : if result . test == test_name : result_manager_filtered . append ( result ) return result_manager_filtered get_results ( output_format = 'native' ) \u00b6 Expose list of all test results in different format Support multiple format: - native: ListResults format - list: a list of TestResult - json: a native JSON format Parameters: Name Type Description Default output_format str format selector. Can be either native/list/json. Defaults to \u2018native\u2019. 'native' Returns: Name Type Description any any List of results. Source code in anta/result_manager/__init__.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def get_results ( self , output_format : str = 'native' ) -> any : \"\"\" Expose list of all test results in different format Support multiple format: - native: ListResults format - list: a list of TestResult - json: a native JSON format Args: output_format (str, optional): format selector. Can be either native/list/json. Defaults to 'native'. Returns: any: List of results. \"\"\" if output_format == 'list' : return list ( self . _result_entries ) if output_format == 'json' : return json . loads ([ result . json () for result in self . _result_entries ]) # Default return for native format. return self . _result_entries table_report ( sort_by = 'host' , reverse = False , colors = True ) \u00b6 Build a table report of all tests Parameters: Name Type Description Default sort_by str Key to use to filter result. Can be either host/test/result. Defaults to \u2018host\u2019. 'host' reverse bool Enable reverse sorting. Defaults to False. False colors bool Select if tests results are colored or not. Defaults to True. True Returns: Name Type Description tabulate tabulate A Tabulate str that can be printed. Source code in anta/result_manager/__init__.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def table_report ( self , sort_by : str = 'host' , reverse : bool = False , colors : bool = True ) -> tabulate : \"\"\" Build a table report of all tests Args: sort_by (str, optional): Key to use to filter result. Can be either host/test/result. Defaults to 'host'. reverse (bool, optional): Enable reverse sorting. Defaults to False. colors (bool, optional): Select if tests results are colored or not. Defaults to True. Returns: tabulate: A Tabulate str that can be printed. \"\"\" report = TableReport () report . add_content ( results = self . get_results ( output_format = 'list' ), ) return report . get ( sort_by = sort_by , reverse = reverse , enable_colors = colors )","title":"Result Manager module"},{"location":"api/result_manager/#anta-resultmanager-module","text":"Helper to manage Test Results and generate reports. Examples: Create Inventory: inventory_anta = AntaInventory( inventory_file='examples/inventory.yml', username='ansible', password='ansible', timeout=0.5, auto_connect=True ) Create Result Manager: manager = ResultManager() Run tests for all connected devices: for device in inventory_anta . get_inventory () : manager . add_test_result ( verify_eos_version ( device = device , versions = [ ' 4.28.0F ' ] ) ) manager . add_test_result ( verify_uptime ( device = device , minimum = 1 ) ) Print result in native format: manager.get_results() [ TestResult( host=IPv4Address('192.168.0.10'), test='verify_eos_version', result='failure', message=\"device is running version 4.27.3F-26379303.4273F (engineering build) and test expect ['4.28.0F']\" ), TestResult( host=IPv4Address('192.168.0.10'), test='verify_eos_version', result='success', message=None ), ] Source code in anta/result_manager/__init__.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 class ResultManager (): \"\"\" Helper to manage Test Results and generate reports. Examples: Create Inventory: inventory_anta = AntaInventory( inventory_file='examples/inventory.yml', username='ansible', password='ansible', timeout=0.5, auto_connect=True ) Create Result Manager: manager = ResultManager() Run tests for all connected devices: for device in inventory_anta.get_inventory(): manager.add_test_result( verify_eos_version( device=device, versions=['4.28.0F'] ) ) manager.add_test_result( verify_uptime( device=device, minimum=1 ) ) Print result in native format: manager.get_results() [ TestResult( host=IPv4Address('192.168.0.10'), test='verify_eos_version', result='failure', message=\"device is running version 4.27.3F-26379303.4273F (engineering build) and test expect ['4.28.0F']\" ), TestResult( host=IPv4Address('192.168.0.10'), test='verify_eos_version', result='success', message=None ), ] \"\"\" def __init__ ( self ) -> None : \"\"\" Class constructor.\"\"\" self . _result_entries = ListResult () def add_test_result ( self , entry : TestResult ) -> None : \"\"\" Add a result to the list Args: entry (TestResult): TestResult data to add to the report \"\"\" self . _result_entries . append ( entry ) def get_results ( self , output_format : str = 'native' ) -> any : \"\"\" Expose list of all test results in different format Support multiple format: - native: ListResults format - list: a list of TestResult - json: a native JSON format Args: output_format (str, optional): format selector. Can be either native/list/json. Defaults to 'native'. Returns: any: List of results. \"\"\" if output_format == 'list' : return list ( self . _result_entries ) if output_format == 'json' : return json . loads ([ result . json () for result in self . _result_entries ]) # Default return for native format. return self . _result_entries def get_result_by_test ( self , test_name : str , output_format : str = 'native' ) -> Any : \"\"\" Get list of test result for a given test. Args: test_name (str): Test name to use to filter results output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'. Returns: list[TestResult]: List of results related to the test. \"\"\" if output_format == 'list' : return [ result for result in self . _result_entries if str ( result . test ) == test_name ] result_manager_filtered = ListResult () for result in self . _result_entries : if result . test == test_name : result_manager_filtered . append ( result ) return result_manager_filtered def get_result_by_host ( self , host_ip : str , output_format : str = 'native' ) -> Any : \"\"\" Get list of test result for a given host. Args: host_ip (str): IP Address of the host to use to filter results. output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'. Returns: Any: List of results related to the host. \"\"\" if output_format == 'list' : return [ result for result in self . _result_entries if str ( result . host ) == host_ip ] result_manager_filtered = ListResult () for result in self . _result_entries : if result . host == host_ip : result_manager_filtered . append ( result ) return result_manager_filtered def table_report ( self , sort_by : str = 'host' , reverse : bool = False , colors : bool = True ) -> tabulate : \"\"\" Build a table report of all tests Args: sort_by (str, optional): Key to use to filter result. Can be either host/test/result. Defaults to 'host'. reverse (bool, optional): Enable reverse sorting. Defaults to False. colors (bool, optional): Select if tests results are colored or not. Defaults to True. Returns: tabulate: A Tabulate str that can be printed. \"\"\" report = TableReport () report . add_content ( results = self . get_results ( output_format = 'list' ), ) return report . get ( sort_by = sort_by , reverse = reverse , enable_colors = colors )","title":"ANTA ResultManager module"},{"location":"api/result_manager/#anta.result_manager.ResultManager.__init__","text":"Class constructor. Source code in anta/result_manager/__init__.py 70 71 72 def __init__ ( self ) -> None : \"\"\" Class constructor.\"\"\" self . _result_entries = ListResult ()","title":"__init__()"},{"location":"api/result_manager/#anta.result_manager.ResultManager.add_test_result","text":"Add a result to the list Parameters: Name Type Description Default entry TestResult TestResult data to add to the report required Source code in anta/result_manager/__init__.py 74 75 76 77 78 79 80 def add_test_result ( self , entry : TestResult ) -> None : \"\"\" Add a result to the list Args: entry (TestResult): TestResult data to add to the report \"\"\" self . _result_entries . append ( entry )","title":"add_test_result()"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_result_by_host","text":"Get list of test result for a given host. Parameters: Name Type Description Default host_ip str IP Address of the host to use to filter results. required output_format str format selector. Can be either native/list. Defaults to \u2018native\u2019. 'native' Returns: Name Type Description Any Any List of results related to the host. Source code in anta/result_manager/__init__.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def get_result_by_host ( self , host_ip : str , output_format : str = 'native' ) -> Any : \"\"\" Get list of test result for a given host. Args: host_ip (str): IP Address of the host to use to filter results. output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'. Returns: Any: List of results related to the host. \"\"\" if output_format == 'list' : return [ result for result in self . _result_entries if str ( result . host ) == host_ip ] result_manager_filtered = ListResult () for result in self . _result_entries : if result . host == host_ip : result_manager_filtered . append ( result ) return result_manager_filtered","title":"get_result_by_host()"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_result_by_test","text":"Get list of test result for a given test. Parameters: Name Type Description Default test_name str Test name to use to filter results required output_format str format selector. Can be either native/list. Defaults to \u2018native\u2019. 'native' Returns: Type Description Any list[TestResult]: List of results related to the test. Source code in anta/result_manager/__init__.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def get_result_by_test ( self , test_name : str , output_format : str = 'native' ) -> Any : \"\"\" Get list of test result for a given test. Args: test_name (str): Test name to use to filter results output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'. Returns: list[TestResult]: List of results related to the test. \"\"\" if output_format == 'list' : return [ result for result in self . _result_entries if str ( result . test ) == test_name ] result_manager_filtered = ListResult () for result in self . _result_entries : if result . test == test_name : result_manager_filtered . append ( result ) return result_manager_filtered","title":"get_result_by_test()"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_results","text":"Expose list of all test results in different format Support multiple format: - native: ListResults format - list: a list of TestResult - json: a native JSON format Parameters: Name Type Description Default output_format str format selector. Can be either native/list/json. Defaults to \u2018native\u2019. 'native' Returns: Name Type Description any any List of results. Source code in anta/result_manager/__init__.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def get_results ( self , output_format : str = 'native' ) -> any : \"\"\" Expose list of all test results in different format Support multiple format: - native: ListResults format - list: a list of TestResult - json: a native JSON format Args: output_format (str, optional): format selector. Can be either native/list/json. Defaults to 'native'. Returns: any: List of results. \"\"\" if output_format == 'list' : return list ( self . _result_entries ) if output_format == 'json' : return json . loads ([ result . json () for result in self . _result_entries ]) # Default return for native format. return self . _result_entries","title":"get_results()"},{"location":"api/result_manager/#anta.result_manager.ResultManager.table_report","text":"Build a table report of all tests Parameters: Name Type Description Default sort_by str Key to use to filter result. Can be either host/test/result. Defaults to \u2018host\u2019. 'host' reverse bool Enable reverse sorting. Defaults to False. False colors bool Select if tests results are colored or not. Defaults to True. True Returns: Name Type Description tabulate tabulate A Tabulate str that can be printed. Source code in anta/result_manager/__init__.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def table_report ( self , sort_by : str = 'host' , reverse : bool = False , colors : bool = True ) -> tabulate : \"\"\" Build a table report of all tests Args: sort_by (str, optional): Key to use to filter result. Can be either host/test/result. Defaults to 'host'. reverse (bool, optional): Enable reverse sorting. Defaults to False. colors (bool, optional): Select if tests results are colored or not. Defaults to True. Returns: tabulate: A Tabulate str that can be printed. \"\"\" report = TableReport () report . add_content ( results = self . get_results ( output_format = 'list' ), ) return report . get ( sort_by = sort_by , reverse = reverse , enable_colors = colors )","title":"table_report()"},{"location":"api/result_manager.models/","text":"module result_manager.models \u00b6 Models related to anta.result_manager module. Global Variables \u00b6 RESULT_OPTIONS class TestResult \u00b6 Describe result of a test from a single device. Attributes: host (IPvAnyAddress): IPv4 or IPv6 address of the device where the test has run. test (str): Test name runs on the device. results (str): Result of the test. Can be one of unset / failure / success. message (str, optional): Message to report after the test. classmethod TestResult.name_must_be_in \u00b6 name_must_be_in ( v ) class ListResult \u00b6 List result for all tests on all devices. Attributes: __root__ (List[TestResult]): A list of TestResult objects. method ListResult.append \u00b6 append ( value ) \u2192 None Add support for append method. This file was automatically generated via lazydocs .","title":"Result Manager models"},{"location":"api/result_manager.models/#module-result_managermodels","text":"Models related to anta.result_manager module.","title":"module result_manager.models"},{"location":"api/result_manager.models/#global-variables","text":"RESULT_OPTIONS","title":"Global Variables"},{"location":"api/result_manager.models/#class-testresult","text":"Describe result of a test from a single device. Attributes: host (IPvAnyAddress): IPv4 or IPv6 address of the device where the test has run. test (str): Test name runs on the device. results (str): Result of the test. Can be one of unset / failure / success. message (str, optional): Message to report after the test.","title":"class TestResult"},{"location":"api/result_manager.models/#classmethod-testresultname_must_be_in","text":"name_must_be_in ( v )","title":"classmethod TestResult.name_must_be_in"},{"location":"api/result_manager.models/#class-listresult","text":"List result for all tests on all devices. Attributes: __root__ (List[TestResult]): A list of TestResult objects.","title":"class ListResult"},{"location":"api/result_manager.models/#method-listresultappend","text":"append ( value ) \u2192 None Add support for append method. This file was automatically generated via lazydocs .","title":"method ListResult.append"},{"location":"api/tests.configuration/","text":"ANTA catalog for configuration tests \u00b6 Test functions related to the device configuration verify_running_config_diffs ( device , enable_password ) \u00b6 Verifies there is no difference between the running-config and the startup-config. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if there is no difference between the running-config and the startup-config. False otherwise. Source code in anta/tests/configuration.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def verify_running_config_diffs ( device , enable_password ): \"\"\" Verifies there is no difference between the running-config and the startup-config. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if there is no difference between the running-config and the startup-config. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , \\ [{ \"cmd\" : \"enable\" , \"input\" : enable_password }, 'show running-config diffs' ], 'text' ) except jsonrpc . AppError : return None try : if len ( response [ 1 ][ 'output' ]) == 0 : return True return False except KeyError : return None verify_zerotouch ( device , enable_password ) \u00b6 Verifies ZeroTouch is disabled. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if ZeroTouch is disabled. False otherwise. Source code in anta/tests/configuration.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def verify_zerotouch ( device , enable_password ): \"\"\" Verifies ZeroTouch is disabled. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if ZeroTouch is disabled. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show zerotouch' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'mode' ] == 'disabled' : return True return False except KeyError : return None","title":"Configuration"},{"location":"api/tests.configuration/#anta-catalog-for-configuration-tests","text":"Test functions related to the device configuration","title":"ANTA catalog for configuration tests"},{"location":"api/tests.configuration/#anta.tests.configuration.verify_running_config_diffs","text":"Verifies there is no difference between the running-config and the startup-config. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if there is no difference between the running-config and the startup-config. False otherwise. Source code in anta/tests/configuration.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def verify_running_config_diffs ( device , enable_password ): \"\"\" Verifies there is no difference between the running-config and the startup-config. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if there is no difference between the running-config and the startup-config. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , \\ [{ \"cmd\" : \"enable\" , \"input\" : enable_password }, 'show running-config diffs' ], 'text' ) except jsonrpc . AppError : return None try : if len ( response [ 1 ][ 'output' ]) == 0 : return True return False except KeyError : return None","title":"verify_running_config_diffs()"},{"location":"api/tests.configuration/#anta.tests.configuration.verify_zerotouch","text":"Verifies ZeroTouch is disabled. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if ZeroTouch is disabled. False otherwise. Source code in anta/tests/configuration.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def verify_zerotouch ( device , enable_password ): \"\"\" Verifies ZeroTouch is disabled. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if ZeroTouch is disabled. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show zerotouch' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'mode' ] == 'disabled' : return True return False except KeyError : return None","title":"verify_zerotouch()"},{"location":"api/tests.hardware/","text":"ANTA catalog for hardware tests \u00b6 Test functions related to the hardware or environement verify_adverse_drops ( device , enable_password ) \u00b6 Verifies there is no adverse drops on DCS-7280E and DCS-7500E switches. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device (DCS-7280E and DCS-7500E) doesnt reports adverse drops. False if the device (DCS-7280E and DCS-7500E) report adverse drops. Source code in anta/tests/hardware.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def verify_adverse_drops ( device , enable_password ): \"\"\" Verifies there is no adverse drops on DCS-7280E and DCS-7500E switches. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device (DCS-7280E and DCS-7500E) doesnt reports adverse drops. `False` if the device (DCS-7280E and DCS-7500E) report adverse drops. \"\"\" try : response = device . runCmds ( 1 , [ 'show hardware counter drop' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'totalAdverseDrops' ] == 0 : return True return False except KeyError : return None verify_environment_cooling ( device , enable_password ) \u00b6 Verifies the fans status is OK. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the if the fans status is OK. False otherwise. Source code in anta/tests/hardware.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def verify_environment_cooling ( device , enable_password ): \"\"\" Verifies the fans status is OK. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the if the fans status is OK. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show system environment cooling' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'systemStatus' ] != 'coolingOk' : return False return True except KeyError : return None verify_environment_power ( device , enable_password ) \u00b6 Verifies the power supplies status is OK. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the power supplies is OK. False otherwise. Source code in anta/tests/hardware.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def verify_environment_power ( device , enable_password ): \"\"\" Verifies the power supplies status is OK. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the power supplies is OK. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show system environment power' ], 'json' ) except jsonrpc . AppError : return None try : for powersupply in response [ 0 ][ 'powerSupplies' ]: if response [ 0 ][ 'powerSupplies' ][ powersupply ][ 'state' ] != 'ok' : return False return True except KeyError : return None verify_system_temperature ( device , enable_password ) \u00b6 Verifies the device temperature is currently OK and the device did not report any temperature alarm in the past. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device temperature is OK. False otherwise. Source code in anta/tests/hardware.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def verify_system_temperature ( device , enable_password ): \"\"\" Verifies the device temperature is currently OK and the device did not report any temperature alarm in the past. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device temperature is OK. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show system environment temperature' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'systemStatus' ] != 'temperatureOk' : return False return True except KeyError : return None verify_transceiver_temperature ( device , enable_password ) \u00b6 Verifies the transceivers temperature is currently OK and the device did not report any alarm in the past for its transceivers temperature. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the transceivers temperature of the device is currently OK and if the device did not report any alarm in the past for its transceivers temperature. False otherwise. Source code in anta/tests/hardware.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def verify_transceiver_temperature ( device , enable_password ): \"\"\" Verifies the transceivers temperature is currently OK and the device did not report any alarm in the past for its transceivers temperature. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the transceivers temperature of the device is currently OK and if the device did not report any alarm in the past for its transceivers temperature. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show system environment temperature transceiver' ], 'json' ) except jsonrpc . AppError : return None try : for sensor in response [ 0 ][ 'tempSensors' ]: if sensor [ 'hwStatus' ] != 'ok' or sensor [ 'alertCount' ] != 0 : return False return True except KeyError : return None verify_transceivers_manufacturers ( device , enable_password , manufacturers = None ) \u00b6 Verifies the device is only using transceivers from supported manufacturers. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required manufacturers list List of allowed transceivers manufacturers. None Returns: Name Type Description bool True if the device is only using transceivers from supported manufacturers. False otherwise. Source code in anta/tests/hardware.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def verify_transceivers_manufacturers ( device , enable_password , manufacturers = None ): \"\"\" Verifies the device is only using transceivers from supported manufacturers. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. manufacturers (list): List of allowed transceivers manufacturers. Returns: bool: `True` if the device is only using transceivers from supported manufacturers. `False` otherwise. \"\"\" if not manufacturers : return None try : response = device . runCmds ( 1 , [ 'show inventory' ], 'json' ) except jsonrpc . AppError : return None try : for interface in response [ 0 ][ 'xcvrSlots' ]: if response [ 0 ][ 'xcvrSlots' ][ interface ][ 'mfgName' ] not in manufacturers : return False return True except KeyError : return None","title":"Hardware"},{"location":"api/tests.hardware/#anta-catalog-for-hardware-tests","text":"Test functions related to the hardware or environement","title":"ANTA catalog for hardware tests"},{"location":"api/tests.hardware/#anta.tests.hardware.verify_adverse_drops","text":"Verifies there is no adverse drops on DCS-7280E and DCS-7500E switches. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device (DCS-7280E and DCS-7500E) doesnt reports adverse drops. False if the device (DCS-7280E and DCS-7500E) report adverse drops. Source code in anta/tests/hardware.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def verify_adverse_drops ( device , enable_password ): \"\"\" Verifies there is no adverse drops on DCS-7280E and DCS-7500E switches. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device (DCS-7280E and DCS-7500E) doesnt reports adverse drops. `False` if the device (DCS-7280E and DCS-7500E) report adverse drops. \"\"\" try : response = device . runCmds ( 1 , [ 'show hardware counter drop' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'totalAdverseDrops' ] == 0 : return True return False except KeyError : return None","title":"verify_adverse_drops()"},{"location":"api/tests.hardware/#anta.tests.hardware.verify_environment_cooling","text":"Verifies the fans status is OK. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the if the fans status is OK. False otherwise. Source code in anta/tests/hardware.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def verify_environment_cooling ( device , enable_password ): \"\"\" Verifies the fans status is OK. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the if the fans status is OK. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show system environment cooling' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'systemStatus' ] != 'coolingOk' : return False return True except KeyError : return None","title":"verify_environment_cooling()"},{"location":"api/tests.hardware/#anta.tests.hardware.verify_environment_power","text":"Verifies the power supplies status is OK. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the power supplies is OK. False otherwise. Source code in anta/tests/hardware.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def verify_environment_power ( device , enable_password ): \"\"\" Verifies the power supplies status is OK. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the power supplies is OK. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show system environment power' ], 'json' ) except jsonrpc . AppError : return None try : for powersupply in response [ 0 ][ 'powerSupplies' ]: if response [ 0 ][ 'powerSupplies' ][ powersupply ][ 'state' ] != 'ok' : return False return True except KeyError : return None","title":"verify_environment_power()"},{"location":"api/tests.hardware/#anta.tests.hardware.verify_system_temperature","text":"Verifies the device temperature is currently OK and the device did not report any temperature alarm in the past. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device temperature is OK. False otherwise. Source code in anta/tests/hardware.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def verify_system_temperature ( device , enable_password ): \"\"\" Verifies the device temperature is currently OK and the device did not report any temperature alarm in the past. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device temperature is OK. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show system environment temperature' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'systemStatus' ] != 'temperatureOk' : return False return True except KeyError : return None","title":"verify_system_temperature()"},{"location":"api/tests.hardware/#anta.tests.hardware.verify_transceiver_temperature","text":"Verifies the transceivers temperature is currently OK and the device did not report any alarm in the past for its transceivers temperature. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the transceivers temperature of the device is currently OK and if the device did not report any alarm in the past for its transceivers temperature. False otherwise. Source code in anta/tests/hardware.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def verify_transceiver_temperature ( device , enable_password ): \"\"\" Verifies the transceivers temperature is currently OK and the device did not report any alarm in the past for its transceivers temperature. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the transceivers temperature of the device is currently OK and if the device did not report any alarm in the past for its transceivers temperature. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show system environment temperature transceiver' ], 'json' ) except jsonrpc . AppError : return None try : for sensor in response [ 0 ][ 'tempSensors' ]: if sensor [ 'hwStatus' ] != 'ok' or sensor [ 'alertCount' ] != 0 : return False return True except KeyError : return None","title":"verify_transceiver_temperature()"},{"location":"api/tests.hardware/#anta.tests.hardware.verify_transceivers_manufacturers","text":"Verifies the device is only using transceivers from supported manufacturers. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required manufacturers list List of allowed transceivers manufacturers. None Returns: Name Type Description bool True if the device is only using transceivers from supported manufacturers. False otherwise. Source code in anta/tests/hardware.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def verify_transceivers_manufacturers ( device , enable_password , manufacturers = None ): \"\"\" Verifies the device is only using transceivers from supported manufacturers. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. manufacturers (list): List of allowed transceivers manufacturers. Returns: bool: `True` if the device is only using transceivers from supported manufacturers. `False` otherwise. \"\"\" if not manufacturers : return None try : response = device . runCmds ( 1 , [ 'show inventory' ], 'json' ) except jsonrpc . AppError : return None try : for interface in response [ 0 ][ 'xcvrSlots' ]: if response [ 0 ][ 'xcvrSlots' ][ interface ][ 'mfgName' ] not in manufacturers : return False return True except KeyError : return None","title":"verify_transceivers_manufacturers()"},{"location":"api/tests.interfaces/","text":"ANTA catalog for interfaces tests \u00b6 Test functions related to the device interfaces verify_illegal_lacp ( device , enable_password ) \u00b6 Verifies there is no illegal LACP packets received. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if there is no illegal LACP packets received. False otherwise. Source code in anta/tests/interfaces.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def verify_illegal_lacp ( device , enable_password ): \"\"\" Verifies there is no illegal LACP packets received. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if there is no illegal LACP packets received. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show lacp counters all-ports' ], 'json' ) except jsonrpc . AppError : return None try : if len ( response [ 0 ][ 'portChannels' ]) == 0 : return None for portchannel in response [ 0 ][ 'portChannels' ]: for interface in response [ 0 ][ 'portChannels' ][ portchannel ][ 'interfaces' ]: if response [ 0 ][ 'portChannels' ][ portchannel ][ 'interfaces' ][ interface ][ 'illegalRxCount' ] != 0 : return False return True except KeyError : return None verify_interface_discards ( device , enable_password ) \u00b6 Verifies interfaces packet discard counters are equal to zero. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the interfaces packet discard counters are equal to zero. False otherwise. Source code in anta/tests/interfaces.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def verify_interface_discards ( device , enable_password ): \"\"\" Verifies interfaces packet discard counters are equal to zero. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the interfaces packet discard counters are equal to zero. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show interfaces counters discards' ], 'json' ) except jsonrpc . AppError : return None try : for interface in response [ 0 ][ 'interfaces' ]: for counter in response [ 0 ][ 'interfaces' ][ interface ]: if response [ 0 ][ 'interfaces' ][ interface ][ counter ] != 0 : return False return True except KeyError : return None verify_interface_errdisabled ( device , enable_password ) \u00b6 Verifies there is no interface in error disable state. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if there is no interface in error disable state.. False otherwise. Source code in anta/tests/interfaces.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def verify_interface_errdisabled ( device , enable_password ): \"\"\" Verifies there is no interface in error disable state. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if there is no interface in error disable state.. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show interfaces status' ], 'json' ) except jsonrpc . AppError : return None try : for interface in response [ 0 ][ 'interfaceStatuses' ]: if response [ 0 ][ 'interfaceStatuses' ][ interface ][ 'linkStatus' ] == 'errdisabled' : return False return True except KeyError : return None verify_interface_errors ( device , enable_password ) \u00b6 Verifies interfaces error counters are equal to zero. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the interfaces error counters are equal to zero. False otherwise. Source code in anta/tests/interfaces.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def verify_interface_errors ( device , enable_password ): \"\"\" Verifies interfaces error counters are equal to zero. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the interfaces error counters are equal to zero. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show interfaces counters errors' ], 'json' ) except jsonrpc . AppError : return None try : for interface in response [ 0 ][ 'interfaceErrorCounters' ]: for counter in response [ 0 ][ 'interfaceErrorCounters' ][ interface ]: if response [ 0 ][ 'interfaceErrorCounters' ][ interface ][ counter ] != 0 : return False return True except KeyError : return None verify_interface_utilization ( device , enable_password ) \u00b6 Verifies interfaces utilization is below 75%. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if interfaces utilization is below 75%. False otherwise. Source code in anta/tests/interfaces.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def verify_interface_utilization ( device , enable_password ): \"\"\" Verifies interfaces utilization is below 75%. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if interfaces utilization is below 75%. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show interfaces counters rates' ], 'text' ) except jsonrpc . AppError : return None try : for line in response [ 0 ][ 'output' ] . split ( ' \\n ' )[ 1 :]: if len ( line ) > 0 : if line . split ()[ - 5 ] == '-' or line . split ()[ - 2 ] == '-' : pass elif float ( line . split ()[ - 5 ] . replace ( '%' , '' )) > 75.0 : return False elif float ( line . split ()[ - 2 ] . replace ( '%' , '' )) > 75.0 : return False return True except KeyError : return None verify_interfaces_status ( device , enable_password , minimum = None ) \u00b6 Verifies the number of Ethernet interfaces up/up on the device is higher or equal than a value. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required minimum int Expected minimum number of Ethernet interfaces up/up None Returns: Name Type Description bool True if the number of Ethernet interfaces up/up on the device is higher or equal than the provided value. False otherwise. Source code in anta/tests/interfaces.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def verify_interfaces_status ( device , enable_password , minimum = None ): \"\"\" Verifies the number of Ethernet interfaces up/up on the device is higher or equal than a value. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. minimum (int): Expected minimum number of Ethernet interfaces up/up Returns: bool: `True` if the number of Ethernet interfaces up/up on the device is higher or equal than the provided value. `False` otherwise. \"\"\" if not minimum : return None try : response = device . runCmds ( 1 , [ 'show interfaces description' ], 'json' ) except jsonrpc . AppError : return None nbr = 0 try : for item in response [ 0 ][ 'interfaceDescriptions' ]: if ( 'Ethernet' in item ) \\ and ( response [ 0 ][ 'interfaceDescriptions' ][ item ][ 'lineProtocolStatus' ] == 'up' ) \\ and ( response [ 0 ][ 'interfaceDescriptions' ][ item ][ 'interfaceStatus' ] == 'up' ): nbr = nbr + 1 if nbr >= minimum : return True return False except KeyError : return None verify_loopback_count ( device , enable_password , number = None ) \u00b6 Verifies the number of loopback interfaces on the device is the one we expect. And if none of the loopback is down. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required number int Expected number of loopback interfaces. None Returns: Name Type Description bool True if the device is running an allowed EOS version. False otherwise. Source code in anta/tests/interfaces.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def verify_loopback_count ( device , enable_password , number = None ): \"\"\" Verifies the number of loopback interfaces on the device is the one we expect. And if none of the loopback is down. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. number (int): Expected number of loopback interfaces. Returns: bool: `True` if the device is running an allowed EOS version. `False` otherwise. \"\"\" if not number : return None try : response = device . runCmds ( 1 , [ 'show ip interface brief | include Loopback' ], 'text' ) except jsonrpc . AppError : return None try : if ( response [ 0 ][ 'output' ] . count ( ' \\n ' ) == number ) and ( response [ 0 ][ 'output' ] . count ( 'down' ) == 0 ) : return True return False except KeyError : return None verify_portchannels ( device , enable_password ) \u00b6 Verifies there is no inactive port in port channels. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if there is no inactive port in port channels. False otherwise. Source code in anta/tests/interfaces.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def verify_portchannels ( device , enable_password ): \"\"\" Verifies there is no inactive port in port channels. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if there is no inactive port in port channels. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show port-channel' ], 'json' ) except jsonrpc . AppError : return None try : if len ( response [ 0 ][ 'portChannels' ]) == 0 : return None for portchannel in response [ 0 ][ 'portChannels' ]: if len ( response [ 0 ][ 'portChannels' ][ portchannel ][ 'inactivePorts' ]) != 0 : return False return True except KeyError : return None verify_spanning_tree_blocked_ports ( device , enable_password ) \u00b6 Verifies there is no spanning-tree blocked ports. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True there is no spanning-tree blocked ports. False otherwise. Source code in anta/tests/interfaces.py 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def verify_spanning_tree_blocked_ports ( device , enable_password ): \"\"\" Verifies there is no spanning-tree blocked ports. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` there is no spanning-tree blocked ports. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show spanning-tree blockedports' ], 'json' ) except jsonrpc . AppError : return None try : if len ( response [ 0 ][ 'spanningTreeInstances' ]) == 0 : return True return False except KeyError : return None verify_storm_control_drops ( device , enable_password ) \u00b6 Verifies the device did not drop packets due its to storm-control configuration. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device did not drop packet due to its storm-control configuration. False otherwise. Source code in anta/tests/interfaces.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def verify_storm_control_drops ( device , enable_password ): \"\"\" Verifies the device did not drop packets due its to storm-control configuration. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device did not drop packet due to its storm-control configuration. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show storm-control' ], 'json' ) except jsonrpc . AppError : return None try : for interface in response [ 0 ][ 'interfaces' ]: for traffic_type in [ 'all' , 'unknown-unicast' , 'multicast' , 'broadcast' ]: if traffic_type in response [ 0 ][ 'interfaces' ][ interface ][ \"trafficTypes\" ]: if 'drop' in response [ 0 ][ 'interfaces' ][ interface ][ \"trafficTypes\" ][ traffic_type ] \\ and response [ 0 ][ 'interfaces' ][ interface ][ \"trafficTypes\" ][ traffic_type ][ 'drop' ] != 0 : return False return True except KeyError : return None verify_svi ( device , enable_password ) \u00b6 Verifies there is no interface vlan down. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if there is no interface vlan down. False otherwise. Source code in anta/tests/interfaces.py 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 def verify_svi ( device , enable_password ): \"\"\" Verifies there is no interface vlan down. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if there is no interface vlan down. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show ip interface brief | include Vl' ], 'text' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'output' ] . count ( 'down' ) == 0 : return True return False except KeyError : return None","title":"Interfaces"},{"location":"api/tests.interfaces/#anta-catalog-for-interfaces-tests","text":"Test functions related to the device interfaces","title":"ANTA catalog for interfaces tests"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_illegal_lacp","text":"Verifies there is no illegal LACP packets received. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if there is no illegal LACP packets received. False otherwise. Source code in anta/tests/interfaces.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def verify_illegal_lacp ( device , enable_password ): \"\"\" Verifies there is no illegal LACP packets received. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if there is no illegal LACP packets received. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show lacp counters all-ports' ], 'json' ) except jsonrpc . AppError : return None try : if len ( response [ 0 ][ 'portChannels' ]) == 0 : return None for portchannel in response [ 0 ][ 'portChannels' ]: for interface in response [ 0 ][ 'portChannels' ][ portchannel ][ 'interfaces' ]: if response [ 0 ][ 'portChannels' ][ portchannel ][ 'interfaces' ][ interface ][ 'illegalRxCount' ] != 0 : return False return True except KeyError : return None","title":"verify_illegal_lacp()"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_interface_discards","text":"Verifies interfaces packet discard counters are equal to zero. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the interfaces packet discard counters are equal to zero. False otherwise. Source code in anta/tests/interfaces.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def verify_interface_discards ( device , enable_password ): \"\"\" Verifies interfaces packet discard counters are equal to zero. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the interfaces packet discard counters are equal to zero. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show interfaces counters discards' ], 'json' ) except jsonrpc . AppError : return None try : for interface in response [ 0 ][ 'interfaces' ]: for counter in response [ 0 ][ 'interfaces' ][ interface ]: if response [ 0 ][ 'interfaces' ][ interface ][ counter ] != 0 : return False return True except KeyError : return None","title":"verify_interface_discards()"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_interface_errdisabled","text":"Verifies there is no interface in error disable state. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if there is no interface in error disable state.. False otherwise. Source code in anta/tests/interfaces.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def verify_interface_errdisabled ( device , enable_password ): \"\"\" Verifies there is no interface in error disable state. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if there is no interface in error disable state.. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show interfaces status' ], 'json' ) except jsonrpc . AppError : return None try : for interface in response [ 0 ][ 'interfaceStatuses' ]: if response [ 0 ][ 'interfaceStatuses' ][ interface ][ 'linkStatus' ] == 'errdisabled' : return False return True except KeyError : return None","title":"verify_interface_errdisabled()"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_interface_errors","text":"Verifies interfaces error counters are equal to zero. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the interfaces error counters are equal to zero. False otherwise. Source code in anta/tests/interfaces.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def verify_interface_errors ( device , enable_password ): \"\"\" Verifies interfaces error counters are equal to zero. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the interfaces error counters are equal to zero. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show interfaces counters errors' ], 'json' ) except jsonrpc . AppError : return None try : for interface in response [ 0 ][ 'interfaceErrorCounters' ]: for counter in response [ 0 ][ 'interfaceErrorCounters' ][ interface ]: if response [ 0 ][ 'interfaceErrorCounters' ][ interface ][ counter ] != 0 : return False return True except KeyError : return None","title":"verify_interface_errors()"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_interface_utilization","text":"Verifies interfaces utilization is below 75%. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if interfaces utilization is below 75%. False otherwise. Source code in anta/tests/interfaces.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def verify_interface_utilization ( device , enable_password ): \"\"\" Verifies interfaces utilization is below 75%. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if interfaces utilization is below 75%. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show interfaces counters rates' ], 'text' ) except jsonrpc . AppError : return None try : for line in response [ 0 ][ 'output' ] . split ( ' \\n ' )[ 1 :]: if len ( line ) > 0 : if line . split ()[ - 5 ] == '-' or line . split ()[ - 2 ] == '-' : pass elif float ( line . split ()[ - 5 ] . replace ( '%' , '' )) > 75.0 : return False elif float ( line . split ()[ - 2 ] . replace ( '%' , '' )) > 75.0 : return False return True except KeyError : return None","title":"verify_interface_utilization()"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_interfaces_status","text":"Verifies the number of Ethernet interfaces up/up on the device is higher or equal than a value. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required minimum int Expected minimum number of Ethernet interfaces up/up None Returns: Name Type Description bool True if the number of Ethernet interfaces up/up on the device is higher or equal than the provided value. False otherwise. Source code in anta/tests/interfaces.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def verify_interfaces_status ( device , enable_password , minimum = None ): \"\"\" Verifies the number of Ethernet interfaces up/up on the device is higher or equal than a value. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. minimum (int): Expected minimum number of Ethernet interfaces up/up Returns: bool: `True` if the number of Ethernet interfaces up/up on the device is higher or equal than the provided value. `False` otherwise. \"\"\" if not minimum : return None try : response = device . runCmds ( 1 , [ 'show interfaces description' ], 'json' ) except jsonrpc . AppError : return None nbr = 0 try : for item in response [ 0 ][ 'interfaceDescriptions' ]: if ( 'Ethernet' in item ) \\ and ( response [ 0 ][ 'interfaceDescriptions' ][ item ][ 'lineProtocolStatus' ] == 'up' ) \\ and ( response [ 0 ][ 'interfaceDescriptions' ][ item ][ 'interfaceStatus' ] == 'up' ): nbr = nbr + 1 if nbr >= minimum : return True return False except KeyError : return None","title":"verify_interfaces_status()"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_loopback_count","text":"Verifies the number of loopback interfaces on the device is the one we expect. And if none of the loopback is down. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required number int Expected number of loopback interfaces. None Returns: Name Type Description bool True if the device is running an allowed EOS version. False otherwise. Source code in anta/tests/interfaces.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def verify_loopback_count ( device , enable_password , number = None ): \"\"\" Verifies the number of loopback interfaces on the device is the one we expect. And if none of the loopback is down. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. number (int): Expected number of loopback interfaces. Returns: bool: `True` if the device is running an allowed EOS version. `False` otherwise. \"\"\" if not number : return None try : response = device . runCmds ( 1 , [ 'show ip interface brief | include Loopback' ], 'text' ) except jsonrpc . AppError : return None try : if ( response [ 0 ][ 'output' ] . count ( ' \\n ' ) == number ) and ( response [ 0 ][ 'output' ] . count ( 'down' ) == 0 ) : return True return False except KeyError : return None","title":"verify_loopback_count()"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_portchannels","text":"Verifies there is no inactive port in port channels. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if there is no inactive port in port channels. False otherwise. Source code in anta/tests/interfaces.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def verify_portchannels ( device , enable_password ): \"\"\" Verifies there is no inactive port in port channels. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if there is no inactive port in port channels. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show port-channel' ], 'json' ) except jsonrpc . AppError : return None try : if len ( response [ 0 ][ 'portChannels' ]) == 0 : return None for portchannel in response [ 0 ][ 'portChannels' ]: if len ( response [ 0 ][ 'portChannels' ][ portchannel ][ 'inactivePorts' ]) != 0 : return False return True except KeyError : return None","title":"verify_portchannels()"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_spanning_tree_blocked_ports","text":"Verifies there is no spanning-tree blocked ports. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True there is no spanning-tree blocked ports. False otherwise. Source code in anta/tests/interfaces.py 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def verify_spanning_tree_blocked_ports ( device , enable_password ): \"\"\" Verifies there is no spanning-tree blocked ports. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` there is no spanning-tree blocked ports. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show spanning-tree blockedports' ], 'json' ) except jsonrpc . AppError : return None try : if len ( response [ 0 ][ 'spanningTreeInstances' ]) == 0 : return True return False except KeyError : return None","title":"verify_spanning_tree_blocked_ports()"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_storm_control_drops","text":"Verifies the device did not drop packets due its to storm-control configuration. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device did not drop packet due to its storm-control configuration. False otherwise. Source code in anta/tests/interfaces.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def verify_storm_control_drops ( device , enable_password ): \"\"\" Verifies the device did not drop packets due its to storm-control configuration. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device did not drop packet due to its storm-control configuration. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show storm-control' ], 'json' ) except jsonrpc . AppError : return None try : for interface in response [ 0 ][ 'interfaces' ]: for traffic_type in [ 'all' , 'unknown-unicast' , 'multicast' , 'broadcast' ]: if traffic_type in response [ 0 ][ 'interfaces' ][ interface ][ \"trafficTypes\" ]: if 'drop' in response [ 0 ][ 'interfaces' ][ interface ][ \"trafficTypes\" ][ traffic_type ] \\ and response [ 0 ][ 'interfaces' ][ interface ][ \"trafficTypes\" ][ traffic_type ][ 'drop' ] != 0 : return False return True except KeyError : return None","title":"verify_storm_control_drops()"},{"location":"api/tests.interfaces/#anta.tests.interfaces.verify_svi","text":"Verifies there is no interface vlan down. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if there is no interface vlan down. False otherwise. Source code in anta/tests/interfaces.py 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 def verify_svi ( device , enable_password ): \"\"\" Verifies there is no interface vlan down. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if there is no interface vlan down. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show ip interface brief | include Vl' ], 'text' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'output' ] . count ( 'down' ) == 0 : return True return False except KeyError : return None","title":"verify_svi()"},{"location":"api/tests.mlag/","text":"ANTA catalog for mlag tests \u00b6 Test functions related to Multi-Chassis LAG verify_mlag_config_sanity ( device , enable_password ) \u00b6 Verifies there is no MLAG config-sanity warnings. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if there is no MLAG config-sanity warnings. False otherwise. Source code in anta/tests/mlag.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def verify_mlag_config_sanity ( device , enable_password ): \"\"\" Verifies there is no MLAG config-sanity warnings. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if there is no MLAG config-sanity warnings. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show mlag config-sanity' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'response' ][ 'mlagActive' ] is False : # MLAG isn't running return None if len ( response [ 0 ][ 'response' ][ 'globalConfiguration' ]) > 0 or \\ len ( response [ 0 ][ 'response' ][ 'interfaceConfiguration' ]) > 0 : return False return True except KeyError : return None verify_mlag_interfaces ( device , enable_password ) \u00b6 Verifies there is no inactive or active-partial MLAG interfaces. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if there is no inactive or active-partial MLAG interfaces. False otherwise. Source code in anta/tests/mlag.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def verify_mlag_interfaces ( device , enable_password ): \"\"\" Verifies there is no inactive or active-partial MLAG interfaces. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if there is no inactive or active-partial MLAG interfaces. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show mlag' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'state' ] == 'disabled' : return None if response [ 0 ][ 'mlagPorts' ][ 'Inactive' ] != 0 : return False if response [ 0 ][ 'mlagPorts' ][ 'Active-partial' ] != 0 : return False return True except KeyError : return None verify_mlag_status ( device , enable_password ) \u00b6 Verifies the MLAG status: state is active, negotiation status is connected, local int is up, peer link is up. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the MLAG status is OK. False otherwise. Source code in anta/tests/mlag.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def verify_mlag_status ( device , enable_password ): \"\"\" Verifies the MLAG status: state is active, negotiation status is connected, local int is up, peer link is up. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the MLAG status is OK. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show mlag' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'state' ] == 'disabled' : return None if response [ 0 ][ 'state' ] != 'active' : return False if response [ 0 ][ 'negStatus' ] != 'connected' : return False if response [ 0 ][ 'localIntfStatus' ] != 'up' : return False if response [ 0 ][ 'peerLinkStatus' ] != 'up' : return False return True except KeyError : return None","title":"MLAG"},{"location":"api/tests.mlag/#anta-catalog-for-mlag-tests","text":"Test functions related to Multi-Chassis LAG","title":"ANTA catalog for mlag tests"},{"location":"api/tests.mlag/#anta.tests.mlag.verify_mlag_config_sanity","text":"Verifies there is no MLAG config-sanity warnings. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if there is no MLAG config-sanity warnings. False otherwise. Source code in anta/tests/mlag.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def verify_mlag_config_sanity ( device , enable_password ): \"\"\" Verifies there is no MLAG config-sanity warnings. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if there is no MLAG config-sanity warnings. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show mlag config-sanity' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'response' ][ 'mlagActive' ] is False : # MLAG isn't running return None if len ( response [ 0 ][ 'response' ][ 'globalConfiguration' ]) > 0 or \\ len ( response [ 0 ][ 'response' ][ 'interfaceConfiguration' ]) > 0 : return False return True except KeyError : return None","title":"verify_mlag_config_sanity()"},{"location":"api/tests.mlag/#anta.tests.mlag.verify_mlag_interfaces","text":"Verifies there is no inactive or active-partial MLAG interfaces. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if there is no inactive or active-partial MLAG interfaces. False otherwise. Source code in anta/tests/mlag.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def verify_mlag_interfaces ( device , enable_password ): \"\"\" Verifies there is no inactive or active-partial MLAG interfaces. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if there is no inactive or active-partial MLAG interfaces. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show mlag' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'state' ] == 'disabled' : return None if response [ 0 ][ 'mlagPorts' ][ 'Inactive' ] != 0 : return False if response [ 0 ][ 'mlagPorts' ][ 'Active-partial' ] != 0 : return False return True except KeyError : return None","title":"verify_mlag_interfaces()"},{"location":"api/tests.mlag/#anta.tests.mlag.verify_mlag_status","text":"Verifies the MLAG status: state is active, negotiation status is connected, local int is up, peer link is up. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the MLAG status is OK. False otherwise. Source code in anta/tests/mlag.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def verify_mlag_status ( device , enable_password ): \"\"\" Verifies the MLAG status: state is active, negotiation status is connected, local int is up, peer link is up. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the MLAG status is OK. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show mlag' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'state' ] == 'disabled' : return None if response [ 0 ][ 'state' ] != 'active' : return False if response [ 0 ][ 'negStatus' ] != 'connected' : return False if response [ 0 ][ 'localIntfStatus' ] != 'up' : return False if response [ 0 ][ 'peerLinkStatus' ] != 'up' : return False return True except KeyError : return None","title":"verify_mlag_status()"},{"location":"api/tests.multicast/","text":"ANTA catalog for multicast tests \u00b6 Test functions related to multicast verify_igmp_snooping_global ( device , enable_password , configuration ) \u00b6 Verifies the IGMP snooping global configuration. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required configuration str Expected global IGMP snooping configuration (enabled or disabled) for these VLANs. required Returns: Name Type Description bool True if the IGMP snooping global configuration is the one we expect. False otherwise. Source code in anta/tests/multicast.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def verify_igmp_snooping_global ( device , enable_password , configuration ): \"\"\" Verifies the IGMP snooping global configuration. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. configuration (str): Expected global IGMP snooping configuration (enabled or disabled) for these VLANs. Returns: bool: `True` if the IGMP snooping global configuration is the one we expect. `False` otherwise. \"\"\" if not configuration : return None try : response = device . runCmds ( 1 , [ 'show ip igmp snooping' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'igmpSnoopingState' ] == configuration : return True return False except KeyError : return None verify_igmp_snooping_vlans ( device , enable_password , vlans , configuration ) \u00b6 Verifies the IGMP snooping configuration for some VLANs. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required vlans list A list of VLANs required configuration str Expected IGMP snooping configuration (enabled or disabled) for these VLANs. required Returns: Name Type Description bool True if the IGMP snooping configuration for the VLANs is the one we expect. False otherwise. Source code in anta/tests/multicast.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def verify_igmp_snooping_vlans ( device , enable_password , vlans , configuration ): \"\"\" Verifies the IGMP snooping configuration for some VLANs. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. vlans (list): A list of VLANs configuration (str): Expected IGMP snooping configuration (enabled or disabled) for these VLANs. Returns: bool: `True` if the IGMP snooping configuration for the VLANs is the one we expect. `False` otherwise. \"\"\" if not vlans or not configuration : return None try : response = device . runCmds ( 1 , [ 'show ip igmp snooping' ], 'json' ) except jsonrpc . AppError : return None try : for vlan in vlans : if response [ 0 ][ 'vlans' ][ str ( vlan )][ 'igmpSnoopingState' ] != configuration : return False return True except KeyError : return None","title":"Multicast"},{"location":"api/tests.multicast/#anta-catalog-for-multicast-tests","text":"Test functions related to multicast","title":"ANTA catalog for multicast tests"},{"location":"api/tests.multicast/#anta.tests.multicast.verify_igmp_snooping_global","text":"Verifies the IGMP snooping global configuration. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required configuration str Expected global IGMP snooping configuration (enabled or disabled) for these VLANs. required Returns: Name Type Description bool True if the IGMP snooping global configuration is the one we expect. False otherwise. Source code in anta/tests/multicast.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def verify_igmp_snooping_global ( device , enable_password , configuration ): \"\"\" Verifies the IGMP snooping global configuration. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. configuration (str): Expected global IGMP snooping configuration (enabled or disabled) for these VLANs. Returns: bool: `True` if the IGMP snooping global configuration is the one we expect. `False` otherwise. \"\"\" if not configuration : return None try : response = device . runCmds ( 1 , [ 'show ip igmp snooping' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'igmpSnoopingState' ] == configuration : return True return False except KeyError : return None","title":"verify_igmp_snooping_global()"},{"location":"api/tests.multicast/#anta.tests.multicast.verify_igmp_snooping_vlans","text":"Verifies the IGMP snooping configuration for some VLANs. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required vlans list A list of VLANs required configuration str Expected IGMP snooping configuration (enabled or disabled) for these VLANs. required Returns: Name Type Description bool True if the IGMP snooping configuration for the VLANs is the one we expect. False otherwise. Source code in anta/tests/multicast.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def verify_igmp_snooping_vlans ( device , enable_password , vlans , configuration ): \"\"\" Verifies the IGMP snooping configuration for some VLANs. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. vlans (list): A list of VLANs configuration (str): Expected IGMP snooping configuration (enabled or disabled) for these VLANs. Returns: bool: `True` if the IGMP snooping configuration for the VLANs is the one we expect. `False` otherwise. \"\"\" if not vlans or not configuration : return None try : response = device . runCmds ( 1 , [ 'show ip igmp snooping' ], 'json' ) except jsonrpc . AppError : return None try : for vlan in vlans : if response [ 0 ][ 'vlans' ][ str ( vlan )][ 'igmpSnoopingState' ] != configuration : return False return True except KeyError : return None","title":"verify_igmp_snooping_vlans()"},{"location":"api/tests.profiles/","text":"ANTA catalog for profiles tests \u00b6 Test functions related to ASIC profiles verify_tcam_profile ( device , enable_password , profile ) \u00b6 Verifies the configured TCAM profile is the expected one. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required profile str The expected TCAM profile. required Returns: Name Type Description bool True if the device is configured with the expected TCAM profile. False otherwise. Source code in anta/tests/profiles.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def verify_tcam_profile ( device , enable_password , profile ): \"\"\" Verifies the configured TCAM profile is the expected one. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. profile (str): The expected TCAM profile. Returns: bool: `True` if the device is configured with the expected TCAM profile. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show hardware tcam profile' ], 'json' ) except jsonrpc . AppError : return None try : if ( response [ 0 ][ 'pmfProfiles' ][ 'FixedSystem' ][ 'status' ] == response [ 0 ][ 'pmfProfiles' ][ 'FixedSystem' ][ 'config' ]) \\ and ( response [ 0 ][ 'pmfProfiles' ][ 'FixedSystem' ][ 'status' ] == profile ): return True return False except KeyError : return None verify_unified_forwarding_table_mode ( device , enable_password , mode = None ) \u00b6 Verifies the device is using the expected Unified Forwarding Table mode. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required mode int The expected Unified Forwarding Table mode. None Returns: Name Type Description bool True if the device is using the expected Unified Forwarding Table mode. False otherwise. Source code in anta/tests/profiles.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def verify_unified_forwarding_table_mode ( device , enable_password , mode = None ): \"\"\" Verifies the device is using the expected Unified Forwarding Table mode. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. mode (int): The expected Unified Forwarding Table mode. Returns: bool: `True` if the device is using the expected Unified Forwarding Table mode. `False` otherwise. \"\"\" if not mode : return None try : response = device . runCmds ( 1 , [ 'show platform trident forwarding-table partition' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'uftMode' ] == str ( mode ): return True return False except KeyError : return None","title":"Profiles"},{"location":"api/tests.profiles/#anta-catalog-for-profiles-tests","text":"Test functions related to ASIC profiles","title":"ANTA catalog for profiles tests"},{"location":"api/tests.profiles/#anta.tests.profiles.verify_tcam_profile","text":"Verifies the configured TCAM profile is the expected one. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required profile str The expected TCAM profile. required Returns: Name Type Description bool True if the device is configured with the expected TCAM profile. False otherwise. Source code in anta/tests/profiles.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def verify_tcam_profile ( device , enable_password , profile ): \"\"\" Verifies the configured TCAM profile is the expected one. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. profile (str): The expected TCAM profile. Returns: bool: `True` if the device is configured with the expected TCAM profile. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show hardware tcam profile' ], 'json' ) except jsonrpc . AppError : return None try : if ( response [ 0 ][ 'pmfProfiles' ][ 'FixedSystem' ][ 'status' ] == response [ 0 ][ 'pmfProfiles' ][ 'FixedSystem' ][ 'config' ]) \\ and ( response [ 0 ][ 'pmfProfiles' ][ 'FixedSystem' ][ 'status' ] == profile ): return True return False except KeyError : return None","title":"verify_tcam_profile()"},{"location":"api/tests.profiles/#anta.tests.profiles.verify_unified_forwarding_table_mode","text":"Verifies the device is using the expected Unified Forwarding Table mode. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required mode int The expected Unified Forwarding Table mode. None Returns: Name Type Description bool True if the device is using the expected Unified Forwarding Table mode. False otherwise. Source code in anta/tests/profiles.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def verify_unified_forwarding_table_mode ( device , enable_password , mode = None ): \"\"\" Verifies the device is using the expected Unified Forwarding Table mode. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. mode (int): The expected Unified Forwarding Table mode. Returns: bool: `True` if the device is using the expected Unified Forwarding Table mode. `False` otherwise. \"\"\" if not mode : return None try : response = device . runCmds ( 1 , [ 'show platform trident forwarding-table partition' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'uftMode' ] == str ( mode ): return True return False except KeyError : return None","title":"verify_unified_forwarding_table_mode()"},{"location":"api/tests.routing.bgp/","text":"ANTA catalog for routing-bgp tests \u00b6 BGP test functions verify_bgp_evpn_count ( device , enable_password , number ) \u00b6 Verifies all EVPN BGP sessions are established (default VRF) and the actual number of BGP EVPN neighbors is the one we expect (default VRF). Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required number int The expected number of BGP EVPN neighbors in the default VRF. required Returns: Name Type Description bool True if all EVPN BGP sessions are established and if the actual number of BGP EVPN neighbors is the one we expect. False otherwise. Source code in anta/tests/routing/bgp.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def verify_bgp_evpn_count ( device , enable_password , number ): \"\"\" Verifies all EVPN BGP sessions are established (default VRF) and the actual number of BGP EVPN neighbors is the one we expect (default VRF). Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. number (int): The expected number of BGP EVPN neighbors in the default VRF. Returns: bool: `True` if all EVPN BGP sessions are established and if the actual number of BGP EVPN neighbors is the one we expect. `False` otherwise. \"\"\" if not number : return None try : response = device . runCmds ( 1 , [ 'show bgp evpn summary' ], 'json' ) except jsonrpc . AppError : return None count = 0 try : for peer in response [ 0 ][ 'vrfs' ][ 'default' ][ 'peers' ]: if response [ 0 ][ 'vrfs' ][ 'default' ][ 'peers' ][ peer ][ 'peerState' ] != 'Established' : return False count = count + 1 if count == number : return True return False except KeyError : return None verify_bgp_evpn_state ( device , enable_password ) \u00b6 Verifies all EVPN BGP sessions are established (default VRF). Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if all EVPN BGP sessions are established. False otherwise. Source code in anta/tests/routing/bgp.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def verify_bgp_evpn_state ( device , enable_password ): \"\"\" Verifies all EVPN BGP sessions are established (default VRF). Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if all EVPN BGP sessions are established. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show bgp evpn summary' ], 'json' ) except jsonrpc . AppError : return None try : if len ( response [ 0 ][ 'vrfs' ][ 'default' ][ 'peers' ]) == 0 : return None for peer in response [ 0 ][ 'vrfs' ][ 'default' ][ 'peers' ]: if response [ 0 ][ 'vrfs' ][ 'default' ][ 'peers' ][ peer ][ 'peerState' ] != 'Established' : return False return True except KeyError : return None verify_bgp_ipv4_unicast_count ( device , enable_password , number , vrf = 'default' ) \u00b6 Verifies all IPv4 unicast BGP sessions are established and all BGP messages queues for these sessions are empty and the actual number of BGP IPv4 unicast neighbors is the one we expect. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required number int Expected number of BGP IPv4 unicast neighbors required vrf(str) VRF to verify. required Returns: Name Type Description bool True if all IPv4 unicast BGP sessions are established and if all BGP messages queues for these sessions are empty and if the actual number of BGP IPv4 unicast neighbors is the one we expect. False otherwise. Source code in anta/tests/routing/bgp.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def verify_bgp_ipv4_unicast_count ( device , enable_password , number , vrf = 'default' ): \"\"\" Verifies all IPv4 unicast BGP sessions are established and all BGP messages queues for these sessions are empty and the actual number of BGP IPv4 unicast neighbors is the one we expect. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. number (int): Expected number of BGP IPv4 unicast neighbors vrf(str): VRF to verify. Returns: bool: `True` if all IPv4 unicast BGP sessions are established and if all BGP messages queues for these sessions are empty and if the actual number of BGP IPv4 unicast neighbors is the one we expect. `False` otherwise. \"\"\" if not number : return None if not vrf : return None count = 0 command = 'show bgp ipv4 unicast summary vrf ' + vrf try : response = device . runCmds ( 1 , [ command ], 'json' ) except jsonrpc . AppError : return None try : for peer in response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ]: if ( response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ][ peer ][ 'peerState' ] != 'Established' ) \\ or ( response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ][ peer ][ \"inMsgQueue\" ] != 0 ) \\ or ( response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ][ peer ][ \"outMsgQueue\" ] != 0 ): return False count = count + 1 if count == number : return True return False except KeyError : return None verify_bgp_ipv4_unicast_state ( device , enable_password ) \u00b6 Verifies all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). False otherwise. Source code in anta/tests/routing/bgp.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def verify_bgp_ipv4_unicast_state ( device , enable_password ): \"\"\" Verifies all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show bgp ipv4 unicast summary vrf all' ], 'json' ) except jsonrpc . AppError : return None try : if len ( response [ 0 ][ 'vrfs' ]) == 0 : return None for vrf in response [ 0 ][ 'vrfs' ]: for peer in response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ]: if ( response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ][ peer ][ 'peerState' ] != 'Established' ) \\ or ( response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ][ peer ][ \"inMsgQueue\" ] != 0 ) \\ or ( response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ][ peer ][ \"outMsgQueue\" ] != 0 ): return False return True except KeyError : return None verify_bgp_ipv6_unicast_state ( device , enable_password ) \u00b6 Verifies all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). False otherwise. Source code in anta/tests/routing/bgp.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def verify_bgp_ipv6_unicast_state ( device , enable_password ): \"\"\" Verifies all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show bgp ipv6 unicast summary vrf all' ], 'json' ) except jsonrpc . AppError : return None try : if len ( response [ 0 ][ 'vrfs' ]) == 0 : return None for vrf in response [ 0 ][ 'vrfs' ]: for peer in response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ]: if ( response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ][ peer ][ 'peerState' ] != 'Established' ) \\ or ( response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ][ peer ][ \"inMsgQueue\" ] != 0 ) or \\ ( response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ][ peer ][ \"outMsgQueue\" ] != 0 ): return False return True except KeyError : return None verify_bgp_rtc_count ( device , enable_password , number ) \u00b6 Verifies all RTC BGP sessions are established (default VRF) and the actual number of BGP RTC neighbors is the one we expect (default VRF). Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required number int The expected number of BGP RTC neighbors (default VRF). required Returns: Name Type Description bool True if all RTC BGP sessions are established and if the actual number of BGP RTC neighbors is the one we expect. False otherwise. Source code in anta/tests/routing/bgp.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def verify_bgp_rtc_count ( device , enable_password , number ): \"\"\" Verifies all RTC BGP sessions are established (default VRF) and the actual number of BGP RTC neighbors is the one we expect (default VRF). Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. number (int): The expected number of BGP RTC neighbors (default VRF). Returns: bool: `True` if all RTC BGP sessions are established and if the actual number of BGP RTC neighbors is the one we expect. `False` otherwise. \"\"\" if not number : return None try : response = device . runCmds ( 1 , [ 'show bgp rt-membership summary' ], 'json' ) except jsonrpc . AppError : return None count = 0 try : for peer in response [ 0 ][ 'vrfs' ][ 'default' ][ 'peers' ]: if response [ 0 ][ 'vrfs' ][ 'default' ][ 'peers' ][ peer ][ 'peerState' ] != 'Established' : return False count = count + 1 if count == number : return True return False except KeyError : return None verify_bgp_rtc_state ( device , enable_password ) \u00b6 Verifies all RTC BGP sessions are established (default VRF). Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if all RTC BGP sessions are established. False otherwise. Source code in anta/tests/routing/bgp.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def verify_bgp_rtc_state ( device , enable_password ): \"\"\" Verifies all RTC BGP sessions are established (default VRF). Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if all RTC BGP sessions are established. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show bgp rt-membership summary' ], 'json' ) except jsonrpc . AppError : return None try : if len ( response [ 0 ][ 'vrfs' ][ 'default' ][ 'peers' ]) == 0 : return None for peer in response [ 0 ][ 'vrfs' ][ 'default' ][ 'peers' ]: if response [ 0 ][ 'vrfs' ][ 'default' ][ 'peers' ][ peer ][ 'peerState' ] != 'Established' : return False return True except KeyError : return None","title":"BGP"},{"location":"api/tests.routing.bgp/#anta-catalog-for-routing-bgp-tests","text":"BGP test functions","title":"ANTA catalog for routing-bgp tests"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.verify_bgp_evpn_count","text":"Verifies all EVPN BGP sessions are established (default VRF) and the actual number of BGP EVPN neighbors is the one we expect (default VRF). Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required number int The expected number of BGP EVPN neighbors in the default VRF. required Returns: Name Type Description bool True if all EVPN BGP sessions are established and if the actual number of BGP EVPN neighbors is the one we expect. False otherwise. Source code in anta/tests/routing/bgp.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def verify_bgp_evpn_count ( device , enable_password , number ): \"\"\" Verifies all EVPN BGP sessions are established (default VRF) and the actual number of BGP EVPN neighbors is the one we expect (default VRF). Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. number (int): The expected number of BGP EVPN neighbors in the default VRF. Returns: bool: `True` if all EVPN BGP sessions are established and if the actual number of BGP EVPN neighbors is the one we expect. `False` otherwise. \"\"\" if not number : return None try : response = device . runCmds ( 1 , [ 'show bgp evpn summary' ], 'json' ) except jsonrpc . AppError : return None count = 0 try : for peer in response [ 0 ][ 'vrfs' ][ 'default' ][ 'peers' ]: if response [ 0 ][ 'vrfs' ][ 'default' ][ 'peers' ][ peer ][ 'peerState' ] != 'Established' : return False count = count + 1 if count == number : return True return False except KeyError : return None","title":"verify_bgp_evpn_count()"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.verify_bgp_evpn_state","text":"Verifies all EVPN BGP sessions are established (default VRF). Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if all EVPN BGP sessions are established. False otherwise. Source code in anta/tests/routing/bgp.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def verify_bgp_evpn_state ( device , enable_password ): \"\"\" Verifies all EVPN BGP sessions are established (default VRF). Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if all EVPN BGP sessions are established. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show bgp evpn summary' ], 'json' ) except jsonrpc . AppError : return None try : if len ( response [ 0 ][ 'vrfs' ][ 'default' ][ 'peers' ]) == 0 : return None for peer in response [ 0 ][ 'vrfs' ][ 'default' ][ 'peers' ]: if response [ 0 ][ 'vrfs' ][ 'default' ][ 'peers' ][ peer ][ 'peerState' ] != 'Established' : return False return True except KeyError : return None","title":"verify_bgp_evpn_state()"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.verify_bgp_ipv4_unicast_count","text":"Verifies all IPv4 unicast BGP sessions are established and all BGP messages queues for these sessions are empty and the actual number of BGP IPv4 unicast neighbors is the one we expect. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required number int Expected number of BGP IPv4 unicast neighbors required vrf(str) VRF to verify. required Returns: Name Type Description bool True if all IPv4 unicast BGP sessions are established and if all BGP messages queues for these sessions are empty and if the actual number of BGP IPv4 unicast neighbors is the one we expect. False otherwise. Source code in anta/tests/routing/bgp.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def verify_bgp_ipv4_unicast_count ( device , enable_password , number , vrf = 'default' ): \"\"\" Verifies all IPv4 unicast BGP sessions are established and all BGP messages queues for these sessions are empty and the actual number of BGP IPv4 unicast neighbors is the one we expect. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. number (int): Expected number of BGP IPv4 unicast neighbors vrf(str): VRF to verify. Returns: bool: `True` if all IPv4 unicast BGP sessions are established and if all BGP messages queues for these sessions are empty and if the actual number of BGP IPv4 unicast neighbors is the one we expect. `False` otherwise. \"\"\" if not number : return None if not vrf : return None count = 0 command = 'show bgp ipv4 unicast summary vrf ' + vrf try : response = device . runCmds ( 1 , [ command ], 'json' ) except jsonrpc . AppError : return None try : for peer in response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ]: if ( response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ][ peer ][ 'peerState' ] != 'Established' ) \\ or ( response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ][ peer ][ \"inMsgQueue\" ] != 0 ) \\ or ( response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ][ peer ][ \"outMsgQueue\" ] != 0 ): return False count = count + 1 if count == number : return True return False except KeyError : return None","title":"verify_bgp_ipv4_unicast_count()"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.verify_bgp_ipv4_unicast_state","text":"Verifies all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). False otherwise. Source code in anta/tests/routing/bgp.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def verify_bgp_ipv4_unicast_state ( device , enable_password ): \"\"\" Verifies all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show bgp ipv4 unicast summary vrf all' ], 'json' ) except jsonrpc . AppError : return None try : if len ( response [ 0 ][ 'vrfs' ]) == 0 : return None for vrf in response [ 0 ][ 'vrfs' ]: for peer in response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ]: if ( response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ][ peer ][ 'peerState' ] != 'Established' ) \\ or ( response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ][ peer ][ \"inMsgQueue\" ] != 0 ) \\ or ( response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ][ peer ][ \"outMsgQueue\" ] != 0 ): return False return True except KeyError : return None","title":"verify_bgp_ipv4_unicast_state()"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.verify_bgp_ipv6_unicast_state","text":"Verifies all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). False otherwise. Source code in anta/tests/routing/bgp.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def verify_bgp_ipv6_unicast_state ( device , enable_password ): \"\"\" Verifies all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF). `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show bgp ipv6 unicast summary vrf all' ], 'json' ) except jsonrpc . AppError : return None try : if len ( response [ 0 ][ 'vrfs' ]) == 0 : return None for vrf in response [ 0 ][ 'vrfs' ]: for peer in response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ]: if ( response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ][ peer ][ 'peerState' ] != 'Established' ) \\ or ( response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ][ peer ][ \"inMsgQueue\" ] != 0 ) or \\ ( response [ 0 ][ 'vrfs' ][ vrf ][ 'peers' ][ peer ][ \"outMsgQueue\" ] != 0 ): return False return True except KeyError : return None","title":"verify_bgp_ipv6_unicast_state()"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.verify_bgp_rtc_count","text":"Verifies all RTC BGP sessions are established (default VRF) and the actual number of BGP RTC neighbors is the one we expect (default VRF). Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required number int The expected number of BGP RTC neighbors (default VRF). required Returns: Name Type Description bool True if all RTC BGP sessions are established and if the actual number of BGP RTC neighbors is the one we expect. False otherwise. Source code in anta/tests/routing/bgp.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def verify_bgp_rtc_count ( device , enable_password , number ): \"\"\" Verifies all RTC BGP sessions are established (default VRF) and the actual number of BGP RTC neighbors is the one we expect (default VRF). Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. number (int): The expected number of BGP RTC neighbors (default VRF). Returns: bool: `True` if all RTC BGP sessions are established and if the actual number of BGP RTC neighbors is the one we expect. `False` otherwise. \"\"\" if not number : return None try : response = device . runCmds ( 1 , [ 'show bgp rt-membership summary' ], 'json' ) except jsonrpc . AppError : return None count = 0 try : for peer in response [ 0 ][ 'vrfs' ][ 'default' ][ 'peers' ]: if response [ 0 ][ 'vrfs' ][ 'default' ][ 'peers' ][ peer ][ 'peerState' ] != 'Established' : return False count = count + 1 if count == number : return True return False except KeyError : return None","title":"verify_bgp_rtc_count()"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.verify_bgp_rtc_state","text":"Verifies all RTC BGP sessions are established (default VRF). Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if all RTC BGP sessions are established. False otherwise. Source code in anta/tests/routing/bgp.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def verify_bgp_rtc_state ( device , enable_password ): \"\"\" Verifies all RTC BGP sessions are established (default VRF). Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if all RTC BGP sessions are established. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show bgp rt-membership summary' ], 'json' ) except jsonrpc . AppError : return None try : if len ( response [ 0 ][ 'vrfs' ][ 'default' ][ 'peers' ]) == 0 : return None for peer in response [ 0 ][ 'vrfs' ][ 'default' ][ 'peers' ]: if response [ 0 ][ 'vrfs' ][ 'default' ][ 'peers' ][ peer ][ 'peerState' ] != 'Established' : return False return True except KeyError : return None","title":"verify_bgp_rtc_state()"},{"location":"api/tests.routing.generic/","text":"ANTA catalog for routing-generic tests \u00b6 Generic routing test functions verify_bfd ( device , enable_password ) \u00b6 Verifies there is no BFD peer in down state (all VRF, IPv4 neighbors). Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if there is no BFD peer in down state (all VRF, IPv4 neighbors, single-hop). False otherwise. Source code in anta/tests/routing/generic.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def verify_bfd ( device , enable_password ): \"\"\" Verifies there is no BFD peer in down state (all VRF, IPv4 neighbors). Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if there is no BFD peer in down state (all VRF, IPv4 neighbors, single-hop). `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show bfd peers' ], 'json' ) except jsonrpc . AppError : return None try : for vrf in response [ 0 ][ 'vrfs' ]: for neighbor in response [ 0 ][ 'vrfs' ][ vrf ][ 'ipv4Neighbors' ]: for interface in response [ 0 ][ 'vrfs' ][ vrf ][ 'ipv4Neighbors' ][ neighbor ][ 'peerStats' ]: if response [ 0 ][ 'vrfs' ][ vrf ][ 'ipv4Neighbors' ][ neighbor ][ 'peerStats' ][ interface ][ 'status' ] != 'up' : return False return True except KeyError : return None verify_routing_protocol_model ( device , enable_password , model = None ) \u00b6 Verifies the configured routing protocol model is the one we expect. And if there is no mismatch between the configured and operating routing protocol model. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required model(str) Expected routing protocol model (multi-agent or ribd). required Returns: Name Type Description bool True if the configured routing protocol model is the one we expect. And if there is no mismatch between the configured and operating routing protocol model. False otherwise. Source code in anta/tests/routing/generic.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def verify_routing_protocol_model ( device , enable_password , model = None ): \"\"\" Verifies the configured routing protocol model is the one we expect. And if there is no mismatch between the configured and operating routing protocol model. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. model(str): Expected routing protocol model (multi-agent or ribd). Returns: bool: `True` if the configured routing protocol model is the one we expect. And if there is no mismatch between the configured and operating routing protocol model. `False` otherwise. \"\"\" if not model : return None try : response = device . runCmds ( 1 , [{ 'cmd' : 'show ip route summary' , 'revision' : 3 }], 'json' ) except jsonrpc . AppError : return None try : if ( response [ 0 ][ 'protoModelStatus' ][ 'configuredProtoModel' ] == response [ 0 ][ 'protoModelStatus' ][ 'operatingProtoModel' ]) \\ and ( response [ 0 ][ 'protoModelStatus' ][ 'operatingProtoModel' ] == model ): return True return False except KeyError : return None verify_routing_table_size ( device , enable_password , minimum = None , maximum = None ) \u00b6 Verifies the size of the IP routing table (default VRF). Should be between the two provided thresholds. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required minimum(int) Expected minimum routing table (default VRF) size. required maximum(int) Expected maximum routing table (default VRF) size. required Returns: Name Type Description bool True if the size of the IP routing table (default VRF) is between two thresholds. False otherwise. Source code in anta/tests/routing/generic.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def verify_routing_table_size ( device , enable_password , minimum = None , maximum = None ): \"\"\" Verifies the size of the IP routing table (default VRF). Should be between the two provided thresholds. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. minimum(int): Expected minimum routing table (default VRF) size. maximum(int): Expected maximum routing table (default VRF) size. Returns: bool: `True` if the size of the IP routing table (default VRF) is between two thresholds. `False` otherwise. \"\"\" if not minimum or not maximum : return None try : response = device . runCmds ( 1 , [{ 'cmd' : 'show ip route summary' , 'revision' : 3 }], 'json' ) except jsonrpc . AppError : return None try : if ( response [ 0 ][ 'vrfs' ][ 'default' ][ 'totalRoutes' ] >= minimum ) \\ and ( response [ 0 ][ 'vrfs' ][ 'default' ][ 'totalRoutes' ] <= maximum ): return True return False except KeyError : return None","title":"Generic"},{"location":"api/tests.routing.generic/#anta-catalog-for-routing-generic-tests","text":"Generic routing test functions","title":"ANTA catalog for routing-generic tests"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.verify_bfd","text":"Verifies there is no BFD peer in down state (all VRF, IPv4 neighbors). Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if there is no BFD peer in down state (all VRF, IPv4 neighbors, single-hop). False otherwise. Source code in anta/tests/routing/generic.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def verify_bfd ( device , enable_password ): \"\"\" Verifies there is no BFD peer in down state (all VRF, IPv4 neighbors). Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if there is no BFD peer in down state (all VRF, IPv4 neighbors, single-hop). `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show bfd peers' ], 'json' ) except jsonrpc . AppError : return None try : for vrf in response [ 0 ][ 'vrfs' ]: for neighbor in response [ 0 ][ 'vrfs' ][ vrf ][ 'ipv4Neighbors' ]: for interface in response [ 0 ][ 'vrfs' ][ vrf ][ 'ipv4Neighbors' ][ neighbor ][ 'peerStats' ]: if response [ 0 ][ 'vrfs' ][ vrf ][ 'ipv4Neighbors' ][ neighbor ][ 'peerStats' ][ interface ][ 'status' ] != 'up' : return False return True except KeyError : return None","title":"verify_bfd()"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.verify_routing_protocol_model","text":"Verifies the configured routing protocol model is the one we expect. And if there is no mismatch between the configured and operating routing protocol model. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required model(str) Expected routing protocol model (multi-agent or ribd). required Returns: Name Type Description bool True if the configured routing protocol model is the one we expect. And if there is no mismatch between the configured and operating routing protocol model. False otherwise. Source code in anta/tests/routing/generic.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def verify_routing_protocol_model ( device , enable_password , model = None ): \"\"\" Verifies the configured routing protocol model is the one we expect. And if there is no mismatch between the configured and operating routing protocol model. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. model(str): Expected routing protocol model (multi-agent or ribd). Returns: bool: `True` if the configured routing protocol model is the one we expect. And if there is no mismatch between the configured and operating routing protocol model. `False` otherwise. \"\"\" if not model : return None try : response = device . runCmds ( 1 , [{ 'cmd' : 'show ip route summary' , 'revision' : 3 }], 'json' ) except jsonrpc . AppError : return None try : if ( response [ 0 ][ 'protoModelStatus' ][ 'configuredProtoModel' ] == response [ 0 ][ 'protoModelStatus' ][ 'operatingProtoModel' ]) \\ and ( response [ 0 ][ 'protoModelStatus' ][ 'operatingProtoModel' ] == model ): return True return False except KeyError : return None","title":"verify_routing_protocol_model()"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.verify_routing_table_size","text":"Verifies the size of the IP routing table (default VRF). Should be between the two provided thresholds. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required minimum(int) Expected minimum routing table (default VRF) size. required maximum(int) Expected maximum routing table (default VRF) size. required Returns: Name Type Description bool True if the size of the IP routing table (default VRF) is between two thresholds. False otherwise. Source code in anta/tests/routing/generic.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def verify_routing_table_size ( device , enable_password , minimum = None , maximum = None ): \"\"\" Verifies the size of the IP routing table (default VRF). Should be between the two provided thresholds. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. minimum(int): Expected minimum routing table (default VRF) size. maximum(int): Expected maximum routing table (default VRF) size. Returns: bool: `True` if the size of the IP routing table (default VRF) is between two thresholds. `False` otherwise. \"\"\" if not minimum or not maximum : return None try : response = device . runCmds ( 1 , [{ 'cmd' : 'show ip route summary' , 'revision' : 3 }], 'json' ) except jsonrpc . AppError : return None try : if ( response [ 0 ][ 'vrfs' ][ 'default' ][ 'totalRoutes' ] >= minimum ) \\ and ( response [ 0 ][ 'vrfs' ][ 'default' ][ 'totalRoutes' ] <= maximum ): return True return False except KeyError : return None","title":"verify_routing_table_size()"},{"location":"api/tests.routing.ospf/","text":"ANTA catalog for routing-ospf tests \u00b6 OSPF test functions verify_ospf_count ( device , enable_password , number = None ) \u00b6 Verifies the number of OSPF neighbors in FULL state is the one we expect. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required number int The expected number of OSPF neighbors in FULL state. None Returns: Name Type Description bool True if the number of OSPF neighbors in FULL state is the one we expect. False otherwise. Source code in anta/tests/routing/ospf.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def verify_ospf_count ( device , enable_password , number = None ): \"\"\" Verifies the number of OSPF neighbors in FULL state is the one we expect. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. number (int): The expected number of OSPF neighbors in FULL state. Returns: bool: `True` if the number of OSPF neighbors in FULL state is the one we expect. `False` otherwise. \"\"\" if not number : return None try : response = device . runCmds ( 1 , [ 'show ip ospf neighbor | exclude Address' ], 'text' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'output' ] . count ( 'FULL' ) == number : return True return False except KeyError : return None verify_ospf_state ( device , enable_password ) \u00b6 Verifies all OSPF neighbors are in FULL state. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if all OSPF neighbors are in FULL state. False otherwise. Source code in anta/tests/routing/ospf.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def verify_ospf_state ( device , enable_password ): \"\"\" Verifies all OSPF neighbors are in FULL state. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if all OSPF neighbors are in FULL state. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show ip ospf neighbor | exclude FULL|Address' ], 'text' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'output' ] . count ( ' \\n ' ) == 0 : return True return False except KeyError : return None","title":"OSPF"},{"location":"api/tests.routing.ospf/#anta-catalog-for-routing-ospf-tests","text":"OSPF test functions","title":"ANTA catalog for routing-ospf tests"},{"location":"api/tests.routing.ospf/#anta.tests.routing.ospf.verify_ospf_count","text":"Verifies the number of OSPF neighbors in FULL state is the one we expect. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required number int The expected number of OSPF neighbors in FULL state. None Returns: Name Type Description bool True if the number of OSPF neighbors in FULL state is the one we expect. False otherwise. Source code in anta/tests/routing/ospf.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def verify_ospf_count ( device , enable_password , number = None ): \"\"\" Verifies the number of OSPF neighbors in FULL state is the one we expect. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. number (int): The expected number of OSPF neighbors in FULL state. Returns: bool: `True` if the number of OSPF neighbors in FULL state is the one we expect. `False` otherwise. \"\"\" if not number : return None try : response = device . runCmds ( 1 , [ 'show ip ospf neighbor | exclude Address' ], 'text' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'output' ] . count ( 'FULL' ) == number : return True return False except KeyError : return None","title":"verify_ospf_count()"},{"location":"api/tests.routing.ospf/#anta.tests.routing.ospf.verify_ospf_state","text":"Verifies all OSPF neighbors are in FULL state. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if all OSPF neighbors are in FULL state. False otherwise. Source code in anta/tests/routing/ospf.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def verify_ospf_state ( device , enable_password ): \"\"\" Verifies all OSPF neighbors are in FULL state. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if all OSPF neighbors are in FULL state. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show ip ospf neighbor | exclude FULL|Address' ], 'text' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'output' ] . count ( ' \\n ' ) == 0 : return True return False except KeyError : return None","title":"verify_ospf_state()"},{"location":"api/tests.software/","text":"ANTA catalog for software tests \u00b6 Test functions related to the EOS software verify_eos_extensions ( device , enable_password ) \u00b6 Verifies all EOS extensions installed on the device are enabled for boot persistence. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device has all installed its EOS extensions enabled for boot persistence. False otherwise. Source code in anta/tests/software.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def verify_eos_extensions ( device , enable_password ): \"\"\" Verifies all EOS extensions installed on the device are enabled for boot persistence. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device has all installed its EOS extensions enabled for boot persistence. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show extensions' , 'show boot-extensions' ], 'json' ) except jsonrpc . AppError : return None installed_extensions = [] boot_extensions = [] try : for extension in response [ 0 ][ 'extensions' ]: if response [ 0 ][ 'extensions' ][ extension ][ 'status' ] == 'installed' : installed_extensions . append ( extension ) for extension in response [ 1 ][ 'extensions' ]: extension = extension . strip ( ' \\n ' ) if extension == '' : pass else : boot_extensions . append ( extension ) installed_extensions . sort () boot_extensions . sort () if installed_extensions == boot_extensions : return True return False except KeyError : return None verify_eos_version ( device , enable_password , versions = None ) \u00b6 Verifies the device is running one of the allowed EOS version. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required versions list List of allowed EOS versions. None Returns: Name Type Description bool True if the device is running an allowed EOS version. False otherwise. Source code in anta/tests/software.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def verify_eos_version ( device , enable_password , versions = None ): \"\"\" Verifies the device is running one of the allowed EOS version. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. versions (list): List of allowed EOS versions. Returns: bool: `True` if the device is running an allowed EOS version. `False` otherwise. \"\"\" if not versions : return None try : response = device . runCmds ( 1 , [ 'show version' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'version' ] in versions : return True return False except KeyError : return None verify_field_notice_44_resolution ( device , enable_password ) \u00b6 Verifies the device is using an Aboot version that fix the bug discussed in the field notice 44 (Aboot manages system settings prior to EOS initialization). Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device is using an Aboot version that fix the bug discussed in the field notice 44 or if the device model is not affected. False otherwise. Source code in anta/tests/software.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def verify_field_notice_44_resolution ( device , enable_password ): \"\"\" Verifies the device is using an Aboot version that fix the bug discussed in the field notice 44 (Aboot manages system settings prior to EOS initialization). Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device is using an Aboot version that fix the bug discussed in the field notice 44 or if the device model is not affected. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show version detail' ], 'json' ) except jsonrpc . AppError : return None devices = [ 'DCS-7010T-48' , 'DCS-7010T-48-DC' , 'DCS-7050TX-48' , 'DCS-7050TX-64' , 'DCS-7050TX-72' , 'DCS-7050TX-72Q' , 'DCS-7050TX-96' , 'DCS-7050TX2-128' , 'DCS-7050SX-64' , 'DCS-7050SX-72' , 'DCS-7050SX-72Q' , 'DCS-7050SX2-72Q' , 'DCS-7050SX-96' , 'DCS-7050SX2-128' , 'DCS-7050QX-32S' , 'DCS-7050QX2-32S' , 'DCS-7050SX3-48YC12' , 'DCS-7050CX3-32S' , 'DCS-7060CX-32S' , 'DCS-7060CX2-32S' , 'DCS-7060SX2-48YC6' , 'DCS-7160-48YC6' , 'DCS-7160-48TC6' , 'DCS-7160-32CQ' , 'DCS-7280SE-64' , 'DCS-7280SE-68' , 'DCS-7280SE-72' , 'DCS-7150SC-24-CLD' , 'DCS-7150SC-64-CLD' , 'DCS-7020TR-48' , 'DCS-7020TRA-48' , 'DCS-7020SR-24C2' , 'DCS-7020SRG-24C2' , 'DCS-7280TR-48C6' , 'DCS-7280TRA-48C6' , 'DCS-7280SR-48C6' , 'DCS-7280SRA-48C6' , 'DCS-7280SRAM-48C6' , 'DCS-7280SR2K-48C6-M' , 'DCS-7280SR2-48YC6' , 'DCS-7280SR2A-48YC6' , 'DCS-7280SRM-40CX2' , 'DCS-7280QR-C36' , 'DCS-7280QRA-C36S' ] variants = [ '-SSD-F' , '-SSD-R' , '-M-F' , '-M-R' , '-F' , '-R' ] try : model = response [ 0 ][ 'modelName' ] for variant in variants : model = model . replace ( variant , '' ) if model not in devices : return True for component in response [ 0 ][ 'details' ][ 'components' ]: if component [ 'name' ] == 'Aboot' : aboot_version = component [ 'version' ] . split ( '-' )[ 2 ] if aboot_version . startswith ( '4.0.' ) and int ( aboot_version . split ( '.' )[ 2 ]) < 7 : return False if aboot_version . startswith ( '4.1.' ) and int ( aboot_version . split ( '.' )[ 2 ]) < 1 : return False if aboot_version . startswith ( '6.0.' ) and int ( aboot_version . split ( '.' )[ 2 ]) < 9 : return False if aboot_version . startswith ( '6.1.' ) and int ( aboot_version . split ( '.' )[ 2 ]) < 7 : return False return True except KeyError : return None verify_terminattr_version ( device , enable_password , versions = None ) \u00b6 Verifies the device is running one of the allowed TerminAttr version. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required versions list List of allowed TerminAttr versions. None Returns: Name Type Description bool True if the device is running an allowed TerminAttr version. False otherwise. Source code in anta/tests/software.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def verify_terminattr_version ( device , enable_password , versions = None ): \"\"\" Verifies the device is running one of the allowed TerminAttr version. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. versions (list): List of allowed TerminAttr versions. Returns: bool: `True` if the device is running an allowed TerminAttr version. `False` otherwise. \"\"\" if not versions : return None try : response = device . runCmds ( 1 , [ 'show version detail' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'details' ][ 'packages' ][ 'TerminAttr-core' ][ 'version' ] in versions : return True return False except KeyError : return None","title":"Software"},{"location":"api/tests.software/#anta-catalog-for-software-tests","text":"Test functions related to the EOS software","title":"ANTA catalog for software tests"},{"location":"api/tests.software/#anta.tests.software.verify_eos_extensions","text":"Verifies all EOS extensions installed on the device are enabled for boot persistence. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device has all installed its EOS extensions enabled for boot persistence. False otherwise. Source code in anta/tests/software.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def verify_eos_extensions ( device , enable_password ): \"\"\" Verifies all EOS extensions installed on the device are enabled for boot persistence. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device has all installed its EOS extensions enabled for boot persistence. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show extensions' , 'show boot-extensions' ], 'json' ) except jsonrpc . AppError : return None installed_extensions = [] boot_extensions = [] try : for extension in response [ 0 ][ 'extensions' ]: if response [ 0 ][ 'extensions' ][ extension ][ 'status' ] == 'installed' : installed_extensions . append ( extension ) for extension in response [ 1 ][ 'extensions' ]: extension = extension . strip ( ' \\n ' ) if extension == '' : pass else : boot_extensions . append ( extension ) installed_extensions . sort () boot_extensions . sort () if installed_extensions == boot_extensions : return True return False except KeyError : return None","title":"verify_eos_extensions()"},{"location":"api/tests.software/#anta.tests.software.verify_eos_version","text":"Verifies the device is running one of the allowed EOS version. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required versions list List of allowed EOS versions. None Returns: Name Type Description bool True if the device is running an allowed EOS version. False otherwise. Source code in anta/tests/software.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def verify_eos_version ( device , enable_password , versions = None ): \"\"\" Verifies the device is running one of the allowed EOS version. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. versions (list): List of allowed EOS versions. Returns: bool: `True` if the device is running an allowed EOS version. `False` otherwise. \"\"\" if not versions : return None try : response = device . runCmds ( 1 , [ 'show version' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'version' ] in versions : return True return False except KeyError : return None","title":"verify_eos_version()"},{"location":"api/tests.software/#anta.tests.software.verify_field_notice_44_resolution","text":"Verifies the device is using an Aboot version that fix the bug discussed in the field notice 44 (Aboot manages system settings prior to EOS initialization). Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device is using an Aboot version that fix the bug discussed in the field notice 44 or if the device model is not affected. False otherwise. Source code in anta/tests/software.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def verify_field_notice_44_resolution ( device , enable_password ): \"\"\" Verifies the device is using an Aboot version that fix the bug discussed in the field notice 44 (Aboot manages system settings prior to EOS initialization). Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device is using an Aboot version that fix the bug discussed in the field notice 44 or if the device model is not affected. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show version detail' ], 'json' ) except jsonrpc . AppError : return None devices = [ 'DCS-7010T-48' , 'DCS-7010T-48-DC' , 'DCS-7050TX-48' , 'DCS-7050TX-64' , 'DCS-7050TX-72' , 'DCS-7050TX-72Q' , 'DCS-7050TX-96' , 'DCS-7050TX2-128' , 'DCS-7050SX-64' , 'DCS-7050SX-72' , 'DCS-7050SX-72Q' , 'DCS-7050SX2-72Q' , 'DCS-7050SX-96' , 'DCS-7050SX2-128' , 'DCS-7050QX-32S' , 'DCS-7050QX2-32S' , 'DCS-7050SX3-48YC12' , 'DCS-7050CX3-32S' , 'DCS-7060CX-32S' , 'DCS-7060CX2-32S' , 'DCS-7060SX2-48YC6' , 'DCS-7160-48YC6' , 'DCS-7160-48TC6' , 'DCS-7160-32CQ' , 'DCS-7280SE-64' , 'DCS-7280SE-68' , 'DCS-7280SE-72' , 'DCS-7150SC-24-CLD' , 'DCS-7150SC-64-CLD' , 'DCS-7020TR-48' , 'DCS-7020TRA-48' , 'DCS-7020SR-24C2' , 'DCS-7020SRG-24C2' , 'DCS-7280TR-48C6' , 'DCS-7280TRA-48C6' , 'DCS-7280SR-48C6' , 'DCS-7280SRA-48C6' , 'DCS-7280SRAM-48C6' , 'DCS-7280SR2K-48C6-M' , 'DCS-7280SR2-48YC6' , 'DCS-7280SR2A-48YC6' , 'DCS-7280SRM-40CX2' , 'DCS-7280QR-C36' , 'DCS-7280QRA-C36S' ] variants = [ '-SSD-F' , '-SSD-R' , '-M-F' , '-M-R' , '-F' , '-R' ] try : model = response [ 0 ][ 'modelName' ] for variant in variants : model = model . replace ( variant , '' ) if model not in devices : return True for component in response [ 0 ][ 'details' ][ 'components' ]: if component [ 'name' ] == 'Aboot' : aboot_version = component [ 'version' ] . split ( '-' )[ 2 ] if aboot_version . startswith ( '4.0.' ) and int ( aboot_version . split ( '.' )[ 2 ]) < 7 : return False if aboot_version . startswith ( '4.1.' ) and int ( aboot_version . split ( '.' )[ 2 ]) < 1 : return False if aboot_version . startswith ( '6.0.' ) and int ( aboot_version . split ( '.' )[ 2 ]) < 9 : return False if aboot_version . startswith ( '6.1.' ) and int ( aboot_version . split ( '.' )[ 2 ]) < 7 : return False return True except KeyError : return None","title":"verify_field_notice_44_resolution()"},{"location":"api/tests.software/#anta.tests.software.verify_terminattr_version","text":"Verifies the device is running one of the allowed TerminAttr version. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required versions list List of allowed TerminAttr versions. None Returns: Name Type Description bool True if the device is running an allowed TerminAttr version. False otherwise. Source code in anta/tests/software.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def verify_terminattr_version ( device , enable_password , versions = None ): \"\"\" Verifies the device is running one of the allowed TerminAttr version. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. versions (list): List of allowed TerminAttr versions. Returns: bool: `True` if the device is running an allowed TerminAttr version. `False` otherwise. \"\"\" if not versions : return None try : response = device . runCmds ( 1 , [ 'show version detail' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'details' ][ 'packages' ][ 'TerminAttr-core' ][ 'version' ] in versions : return True return False except KeyError : return None","title":"verify_terminattr_version()"},{"location":"api/tests.system/","text":"ANTA catalog for system tests \u00b6 Test functions related to system-level features and protocols verify_agent_logs ( device , enable_password ) \u00b6 Verifies there is no agent crash reported on the device. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device has no agent crash reported. False otherwise. Source code in anta/tests/system.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def verify_agent_logs ( device , enable_password ): \"\"\" Verifies there is no agent crash reported on the device. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device has no agent crash reported. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show agent logs crash' ], 'text' ) except jsonrpc . AppError : return None try : if len ( response [ 0 ][ 'output' ]) == 0 : return True return False except KeyError : return None verify_coredump ( device , enable_password ) \u00b6 Verifies there is no core file. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device has no core file. False otherwise. Source code in anta/tests/system.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def verify_coredump ( device , enable_password ): \"\"\" Verifies there is no core file. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device has no core file. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , \\ [{ \"cmd\" : \"enable\" , \"input\" : enable_password }, 'bash timeout 10 ls /var/core' ], 'text' ) except jsonrpc . AppError : return None try : if len ( response [ 1 ][ 'output' ]) == 0 : return True return False except KeyError : return None verify_cpu_utilization ( device , enable_password ) \u00b6 Verifies the CPU utilization is less than 75%. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device CPU utilization is less than 75%. False otherwise. Source code in anta/tests/system.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def verify_cpu_utilization ( device , enable_password ): \"\"\" Verifies the CPU utilization is less than 75%. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device CPU utilization is less than 75%. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show processes top once' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'cpuInfo' ][ '%Cpu(s)' ][ 'idle' ] > 25 : return True return False except KeyError : return None verify_filesystem_utilization ( device , enable_password ) \u00b6 Verifies each partition on the disk is used less than 75%. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if each partition on the disk is used less than 75%. False otherwise. Source code in anta/tests/system.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def verify_filesystem_utilization ( device , enable_password ): \"\"\" Verifies each partition on the disk is used less than 75%. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if each partition on the disk is used less than 75%. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , \\ [{ \"cmd\" : \"enable\" , \"input\" : enable_password }, 'bash timeout 10 df -h' ], 'text' ) except jsonrpc . AppError : return None try : for line in response [ 1 ][ 'output' ] . split ( ' \\n ' )[ 1 :]: if 'loop' not in line and len ( line ) > 0 : if int ( line . split ()[ 4 ] . replace ( '%' , '' )) > 75 : return False return True except KeyError : return None verify_memory_utilization ( device , enable_password ) \u00b6 Verifies the memory utilization is less than 75%. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device memory utilization is less than 75%. False otherwise. Source code in anta/tests/system.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 def verify_memory_utilization ( device , enable_password ): \"\"\" Verifies the memory utilization is less than 75%. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device memory utilization is less than 75%. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show version' ], 'json' ) except jsonrpc . AppError : return None try : if float ( response [ 0 ][ 'memFree' ]) / float ( response [ 0 ][ 'memTotal' ]) > 0.25 : return True return False except KeyError : return None verify_ntp ( device , enable_password ) \u00b6 Verifies NTP is synchronised. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the NTP is synchronised. False otherwise. Source code in anta/tests/system.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def verify_ntp ( device , enable_password ): \"\"\" Verifies NTP is synchronised. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the NTP is synchronised. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show ntp status' ], 'text' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'output' ] . split ( ' \\n ' )[ 0 ] . split ( ' ' )[ 0 ] == 'synchronised' : return True return False except KeyError : return None verify_reload_cause ( device , enable_password ) \u00b6 Verifies the last reload of the device was requested by a user. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device last reload was requested by a user. False otherwise. Source code in anta/tests/system.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def verify_reload_cause ( device , enable_password ): \"\"\" Verifies the last reload of the device was requested by a user. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device last reload was requested by a user. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show version' , 'show reload cause' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'response' ][ 'resetCauses' ][ 0 ][ 'description' ] == 'Reload requested by the user.' or \\ response [ 0 ][ 'response' ][ 'resetCauses' ][ 0 ][ 'description' ] == 'Reload requested after FPGA upgrade' : return True return False except KeyError : return None verify_syslog ( device , enable_password ) \u00b6 Verifies the device had no syslog message with a severity of warning (or a more severe message) during the last 7 days. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device had no syslog message with a severity of warning (or a more severe message) during the last 7 days. False otherwise. Source code in anta/tests/system.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def verify_syslog ( device , enable_password ): \"\"\" Verifies the device had no syslog message with a severity of warning (or a more severe message) during the last 7 days. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device had no syslog message with a severity of warning (or a more severe message) during the last 7 days. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show logging last 7 days threshold warnings' ], 'text' ) except jsonrpc . AppError : return None try : if len ( response [ 0 ][ 'output' ]) == 0 : return True return False except KeyError : return None verify_uptime ( device , enable_password , minimum = None ) \u00b6 Verifies the device uptime is higher than a value. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required minimum int Minimum uptime in seconds. None Returns: Name Type Description bool True if the device uptime is higher than the threshold. False otherwise. Source code in anta/tests/system.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def verify_uptime ( device , enable_password , minimum = None ): \"\"\" Verifies the device uptime is higher than a value. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. minimum (int): Minimum uptime in seconds. Returns: bool: `True` if the device uptime is higher than the threshold. `False` otherwise. \"\"\" if not minimum : return None try : response = device . runCmds ( 1 , [ 'show uptime' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'upTime' ] > minimum : return True return False except KeyError : return None","title":"System"},{"location":"api/tests.system/#anta-catalog-for-system-tests","text":"Test functions related to system-level features and protocols","title":"ANTA catalog for system tests"},{"location":"api/tests.system/#anta.tests.system.verify_agent_logs","text":"Verifies there is no agent crash reported on the device. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device has no agent crash reported. False otherwise. Source code in anta/tests/system.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def verify_agent_logs ( device , enable_password ): \"\"\" Verifies there is no agent crash reported on the device. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device has no agent crash reported. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show agent logs crash' ], 'text' ) except jsonrpc . AppError : return None try : if len ( response [ 0 ][ 'output' ]) == 0 : return True return False except KeyError : return None","title":"verify_agent_logs()"},{"location":"api/tests.system/#anta.tests.system.verify_coredump","text":"Verifies there is no core file. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device has no core file. False otherwise. Source code in anta/tests/system.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def verify_coredump ( device , enable_password ): \"\"\" Verifies there is no core file. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device has no core file. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , \\ [{ \"cmd\" : \"enable\" , \"input\" : enable_password }, 'bash timeout 10 ls /var/core' ], 'text' ) except jsonrpc . AppError : return None try : if len ( response [ 1 ][ 'output' ]) == 0 : return True return False except KeyError : return None","title":"verify_coredump()"},{"location":"api/tests.system/#anta.tests.system.verify_cpu_utilization","text":"Verifies the CPU utilization is less than 75%. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device CPU utilization is less than 75%. False otherwise. Source code in anta/tests/system.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def verify_cpu_utilization ( device , enable_password ): \"\"\" Verifies the CPU utilization is less than 75%. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device CPU utilization is less than 75%. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show processes top once' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'cpuInfo' ][ '%Cpu(s)' ][ 'idle' ] > 25 : return True return False except KeyError : return None","title":"verify_cpu_utilization()"},{"location":"api/tests.system/#anta.tests.system.verify_filesystem_utilization","text":"Verifies each partition on the disk is used less than 75%. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if each partition on the disk is used less than 75%. False otherwise. Source code in anta/tests/system.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def verify_filesystem_utilization ( device , enable_password ): \"\"\" Verifies each partition on the disk is used less than 75%. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if each partition on the disk is used less than 75%. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , \\ [{ \"cmd\" : \"enable\" , \"input\" : enable_password }, 'bash timeout 10 df -h' ], 'text' ) except jsonrpc . AppError : return None try : for line in response [ 1 ][ 'output' ] . split ( ' \\n ' )[ 1 :]: if 'loop' not in line and len ( line ) > 0 : if int ( line . split ()[ 4 ] . replace ( '%' , '' )) > 75 : return False return True except KeyError : return None","title":"verify_filesystem_utilization()"},{"location":"api/tests.system/#anta.tests.system.verify_memory_utilization","text":"Verifies the memory utilization is less than 75%. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device memory utilization is less than 75%. False otherwise. Source code in anta/tests/system.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 def verify_memory_utilization ( device , enable_password ): \"\"\" Verifies the memory utilization is less than 75%. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device memory utilization is less than 75%. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show version' ], 'json' ) except jsonrpc . AppError : return None try : if float ( response [ 0 ][ 'memFree' ]) / float ( response [ 0 ][ 'memTotal' ]) > 0.25 : return True return False except KeyError : return None","title":"verify_memory_utilization()"},{"location":"api/tests.system/#anta.tests.system.verify_ntp","text":"Verifies NTP is synchronised. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the NTP is synchronised. False otherwise. Source code in anta/tests/system.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def verify_ntp ( device , enable_password ): \"\"\" Verifies NTP is synchronised. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the NTP is synchronised. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show ntp status' ], 'text' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'output' ] . split ( ' \\n ' )[ 0 ] . split ( ' ' )[ 0 ] == 'synchronised' : return True return False except KeyError : return None","title":"verify_ntp()"},{"location":"api/tests.system/#anta.tests.system.verify_reload_cause","text":"Verifies the last reload of the device was requested by a user. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device last reload was requested by a user. False otherwise. Source code in anta/tests/system.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def verify_reload_cause ( device , enable_password ): \"\"\" Verifies the last reload of the device was requested by a user. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device last reload was requested by a user. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show version' , 'show reload cause' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'response' ][ 'resetCauses' ][ 0 ][ 'description' ] == 'Reload requested by the user.' or \\ response [ 0 ][ 'response' ][ 'resetCauses' ][ 0 ][ 'description' ] == 'Reload requested after FPGA upgrade' : return True return False except KeyError : return None","title":"verify_reload_cause()"},{"location":"api/tests.system/#anta.tests.system.verify_syslog","text":"Verifies the device had no syslog message with a severity of warning (or a more severe message) during the last 7 days. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required Returns: Name Type Description bool True if the device had no syslog message with a severity of warning (or a more severe message) during the last 7 days. False otherwise. Source code in anta/tests/system.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def verify_syslog ( device , enable_password ): \"\"\" Verifies the device had no syslog message with a severity of warning (or a more severe message) during the last 7 days. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. Returns: bool: `True` if the device had no syslog message with a severity of warning (or a more severe message) during the last 7 days. `False` otherwise. \"\"\" try : response = device . runCmds ( 1 , [ 'show logging last 7 days threshold warnings' ], 'text' ) except jsonrpc . AppError : return None try : if len ( response [ 0 ][ 'output' ]) == 0 : return True return False except KeyError : return None","title":"verify_syslog()"},{"location":"api/tests.system/#anta.tests.system.verify_uptime","text":"Verifies the device uptime is higher than a value. Parameters: Name Type Description Default device jsonrpclib . jsonrpc . ServerProxy Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f\u2019https://{username}:{password}@{ip}/command-api\u2019. required enable_password str Enable password. required minimum int Minimum uptime in seconds. None Returns: Name Type Description bool True if the device uptime is higher than the threshold. False otherwise. Source code in anta/tests/system.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def verify_uptime ( device , enable_password , minimum = None ): \"\"\" Verifies the device uptime is higher than a value. Args: device (jsonrpclib.jsonrpc.ServerProxy): Instance of the class jsonrpclib.jsonrpc.ServerProxy with the uri f'https://{username}:{password}@{ip}/command-api'. enable_password (str): Enable password. minimum (int): Minimum uptime in seconds. Returns: bool: `True` if the device uptime is higher than the threshold. `False` otherwise. \"\"\" if not minimum : return None try : response = device . runCmds ( 1 , [ 'show uptime' ], 'json' ) except jsonrpc . AppError : return None try : if response [ 0 ][ 'upTime' ] > minimum : return True return False except KeyError : return None","title":"verify_uptime()"}]}