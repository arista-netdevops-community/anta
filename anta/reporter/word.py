# Copyright (c) 2023 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
"""
Word report management
"""
from __future__ import annotations

import datetime
import json
import logging
from pathlib import Path
from pydantic import BaseModel
from typing import Any, Dict, List, Optional

from docx import Document
from docx.shared import RGBColor
from docx.oxml import parse_xml
from docx.oxml.ns import nsdecls
from docx.shared import Inches, Pt
from docx.table import Table

from anta.result_manager import ResultManager, TestResult

logger = logging.getLogger(__name__)


WIDTHS = (
    Inches(0.5),
    Inches(1.17),
    Inches(2.50),
    Inches(1.25),
    Inches(0.75),
    Inches(1.50),
)


class TextItems(BaseModel):
    intro: str = f"Report generated by ANTA\nDate: {datetime.datetime.now().strftime('%Y-%m-%d at %I:%M')}"
    abstract: str = f"This is a NRFU report generated by ANTA for customer $$CUSTOMER_NAME$$ on {datetime.datetime.now().strftime('%Y-%m-%d at %I:%M')}"
    tests_description_overview: str = "TBC"
    tests_per_device_overview: str = "This section provides a list of all tests sorted by device name."
    tests_summary_by_tests: str = "This section gives an overview of result grouped by Tests name"


class Color(BaseModel):
    """Color definition object."""
    hex: str

    def rgb(self) -> RGBColor:
        """Convert color frm HEX to RGB."""
        return RGBColor(*[int(self.hex.lstrip("#")[i : i + 2], 16) for i in (0, 2, 4)])


class Colors(BaseModel):
    """Color style definition."""
    headers_table: Color = Color(hex="#1F618D")
    success: Color = Color(hex="#A9DFBF")
    failure: Color = Color(hex="#F5B7B1")
    error: Color = Color(hex="#E74C3C")
    skipped: Color = Color(hex="#EB984E")


class DocxStyle(BaseModel):
    """DOCX style defnition."""
    colors: Colors = Colors()
    font_size_default: int = 9
    font_name: str = "Arial"
    table_style: str = "Table Grid"
    font_colors: Colors = Colors(headers_table=Color(hex="#FFFFFF"))


class ReportWordDocx:
    """Class to manage docx reporting."""

    SHADE_CELL = False  # TODO: Must be included in __init__ at some point.
    TABLE_FORMAT = "Table Grid"
    FONT_DEFAULT = "Arial"

    def __init__(self, filename: Path, anta_result_manager: ResultManager, docx_style: Optional[DocxStyle] = None, title: str = "Arista NRFU Report") -> None:
        """Class constructor."""
        # Baseline
        self.anta_results = anta_result_manager
        self.texts = TextItems()
        self.docx_style = docx_style if docx_style is not None else DocxStyle()
        self.filename = filename
        self.document = Document()

        # Instantiate DOCX document
        self.set_header_page(title)

        self.build_report()

        self.save()

    # -------------------------------------------
    # Internal methods
    # -------------------------------------------

    def _set_header_generic(self, level: int, content: str, font_size: int) -> None:
        """
        Wrapper to insert a title with a custom level and font size.
        """
        heading = self.document.add_heading(level=level)
        run = heading.add_run(content)
        run.font.size = Pt(font_size)
        # run.font.color.rgb = RGBColor(204, 0, 0)

    def _shade_cell(self, cell_idx: int, table: Table, count: int, shade: str) -> None:
        """
        Shade a cell in word doc table

        Args:
            cell_idx (int): Column index for cell to shade
            table (obj): Word doc table object
            count (int): Row index for cell to shade
            shade (str): hexadecimal color representation
        """
        cell = table.cell(count, cell_idx)
        color = parse_xml(f'<w:shd {nsdecls("w")} w:fill="{shade}"/>')
        # pylint: disable-next=protected-access
        cell._tc.get_or_add_tcPr().append(color)

    def _create_table(self, headers: List[str]) -> Table:
        """Create a table with its headers."""
        # add table ------------------
        table = self.document.add_table(rows=1, cols=len(headers), style=self.TABLE_FORMAT)
        table.autofit = True

        for count, header in enumerate(headers):
            para = table.rows[0].cells[count].paragraphs[0]
            run = para.add_run(header)
            run.font.bold = True
            run.font.name = self.docx_style.font_name
            run.font.size = Pt(self.docx_style.font_size_default)
            run.font.color.rgb = self.docx_style.font_colors.headers_table.rgb()
            self._shade_cell(count, table, 0, self.docx_style.colors.headers_table.hex)

        return table

    def _clean_table(self, table: Table) -> None:
        """Force all entries to use correct font settings."""
        for row in table.rows:
            for cell in row.cells:
                paragraphs = cell.paragraphs
                for paragraph in paragraphs:
                    for run in paragraph.runs:
                        font = run.font
                        font.size = Pt(self.docx_style.font_size_default)

    def _count_test_results(self, result: List[TestResult]) -> Dict[str, Any]:
        """Count result types in a list of TestResult."""
        # TODO: should be part of ResultManager to avoid duplicate code.
        return {
            "success": len([e for e in result if e.result == "success"]),
            "failure": len([e for e in result if e.result == "failure"]),
            "error": len([e for e in result if e.result == "error"]),
            "skipped": len([e for e in result if e.result == "skipped"]),
            "devices": [e.name for e in result if e.result in ["error", "failure"]],
        }

    # -------------------------------------------
    # Pubic methods
    # -------------------------------------------

    def set_header_page(self, title: str) -> None:
        """Create first page of the report."""
        self.add_text(content="\n\n\n\n\n\n\n\n\n\n\n\n\n\n")
        self.add_header_l1(title)
        self.add_text(content="\n\n\n\n\n\n")
        self.add_text(content=self.texts.intro)
        self.document.add_page_break()

    def save(self) -> None:
        """Close and Save document."""
        logger.info(f"Saving report under {self.filename.absolute()}")
        self.document.save(str(self.filename.absolute()))

    def add_header_l1(self, content: str) -> None:
        """Insert a level 1 header."""
        self._set_header_generic(level=1, content=content, font_size=24)
        # run.font.color.rgb = RGBColor(204, 0, 0)

    def add_header_l2(self, content: str) -> None:
        """Insert a level 2 header."""
        self._set_header_generic(level=2, content=content, font_size=18)
        # run.font.color.rgb = RGBColor(204, 0, 0)

    def add_header_l3(self, content: str) -> None:
        """Insert a level 3 header."""
        self._set_header_generic(level=3, content=content, font_size=14)

    def add_text(self, content: str, font_pt: int = 9, font: str = FONT_DEFAULT) -> None:
        """Add paragraph to document."""
        para = self.document.add_paragraph()
        run = para.add_run(content)
        run.font.size = Pt(font_pt)
        run.font.name = font

    def generate_abstract(self, index: int = 2) -> None:
        """Generate first section of the documment named ABSTRACT"""
        self.add_header_l2(f"{index}. Abstract")
        self.add_text(self.texts.abstract)
        self.add_text("To be continued")

    def generate_tests_description(self, index: int = 3) -> None:
        """Generate a section with a table with test names and their descriptions."""
        testnames = self.anta_results.get_testcases()
        tests_description = []
        for testname in testnames:
            desc = [d["description"] for d in json.loads(self.anta_results.get_json_results()) if d["test"] == testname][0]
            tests_description.append({"test": f"{testname}", "description": f"{desc}"})

        self.add_header_l2(f"{index}. Tests description")
        self.add_text(self.texts.tests_description_overview)

        headers = ["Test Name", "Description"]
        table = self._create_table(headers)
        for item in tests_description:
            cells = table.add_row().cells
            cells[0].text = item["test"]
            cells[1].text = item["description"]

        self._clean_table(table)

    def generate_summary_per_test(self, index: int = 4) -> None:
        """Generate a section with a summary of result grouped by tests name."""
        headers = ["Test Case", "# of success", "# of skipped", "# of failure", "# of erros", "List of failed or error nodes"]
        tests_name = self.anta_results.get_testcases()

        self.add_header_l2(f"{index}. Result summary")
        self.add_text(self.texts.tests_summary_by_tests)

        table = self._create_table(headers=headers)
        for i, tname in enumerate(tests_name, start=1):
            result = self.anta_results.get_result_by_test(tname)
            result_numbers = self._count_test_results(result)
            row_cells = table.add_row().cells
            row_cells[0].text = tname
            row_cells[5].text = str(result_numbers["devices"])

            # Manage Cell for # of success
            run_success = row_cells[1].paragraphs[0].add_run(str(result_numbers["success"]))
            if result_numbers["success"] > 0:
                run_success.font.color.rgb = self.docx_style.colors.success.rgb()

            run_success = row_cells[2].paragraphs[0].add_run(str(result_numbers["skipped"]))
            if result_numbers["skipped"] > 0:
                # run_success.font.color.rgb = self.docx_style.colors.skipped.rgb()
                self._shade_cell(3, table, i, self.docx_style.colors.skipped.hex)

            run_success = row_cells[3].paragraphs[0].add_run(str(result_numbers["failure"]))
            if result_numbers["failure"] > 0:
                # run_success.font.color.rgb = self.docx_style.colors.failure.rgb()
                self._shade_cell(3, table, i, self.docx_style.colors.failure.hex)

            run_success = row_cells[4].paragraphs[0].add_run(str(result_numbers["error"]))
            if result_numbers["error"] > 0:
                # run_success.font.color.rgb = self.docx_style.colors.failure.rgb()
                self._shade_cell(3, table, i, self.docx_style.colors.error.hex)

    def generate_tests_report(self, device_name: str, index: int = 5, index_sub: int = 1) -> None:
        """Populate table with summary of tests run by ANTA."""
        test_data = self.anta_results.get_result_by_host(device_name)
        headers = [
            "Device name",
            "Case Name",
            "Pass/Fail",
            "Observation",
        ]

        if index_sub == 1:
            self.add_header_l1(f"{index}. Tests report per device.")
            self.add_text(self.texts.tests_per_device_overview)

        self.add_header_l3(f"{index}.{index_sub} Tests for device {device_name}")
        table = self._create_table(headers)

        for count, test_case_entry in enumerate(test_data, start=1):
            row_cells = table.add_row().cells
            # Add entries with no formatting
            row_cells[0].text = test_case_entry.name
            row_cells[1].text = test_case_entry.test
            row_cells[3].text = test_case_entry.messages

            # Add entries using formatting
            run = row_cells[2].paragraphs[0].add_run(test_case_entry.result)
            if test_case_entry.result == "failure":
                if self.SHADE_CELL:
                    self._shade_cell(2, table, count, self.docx_style.colors.failure.hex)
                else:
                    run.font.color.rgb = self.docx_style.colors.failure.rgb()
            elif test_case_entry.result == "success":
                if self.SHADE_CELL:
                    self._shade_cell(2, table, count, self.docx_style.colors.success.hex)
                else:
                    run.font.color.rgb = self.docx_style.colors.success.rgb()
            run.bold = True
            run.font.name = self.FONT_DEFAULT

        self._clean_table(table)

    def build_report(self) -> None:
        """Report Builder."""
        self.generate_abstract()
        self.generate_tests_description()

        self.document.add_page_break()

        self.generate_summary_per_test()

        for index_sub, device_name in enumerate(sorted(self.anta_results.get_hosts()), start=1):
            self.generate_tests_report(device_name=device_name, index_sub=index_sub)
            self.add_text("\n")
