{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#arista-network-test-automation-anta-framework","title":"Arista Network Test Automation (ANTA) Framework","text":"<p>ANTA is Python framework that automates tests for Arista devices.</p> <ul> <li>ANTA provides a set of tests to validate the state of your network</li> <li>ANTA can be used to:<ul> <li>Automate NRFU (Network Ready For Use) test on a preproduction network</li> <li>Automate tests on a live network (periodically or on demand)</li> </ul> </li> <li>ANTA can be used with:<ul> <li>The ANTA CLI</li> <li>As a Python library in your own application</li> </ul> </li> </ul> <p></p> <pre><code># Install ANTA CLI\n$ pip install anta\n\n# Run ANTA CLI\n$ anta --help\nUsage: anta [OPTIONS] COMMAND [ARGS]...\n\n  Arista Network Test Automation (ANTA) CLI\n\nOptions:\n  --version                       Show the version and exit.\n  --username TEXT                 Username to connect to EOS  [env var:\n                                  ANTA_USERNAME; required]\n--password TEXT                 Password to connect to EOS that must be\n                                  provided. It can be prompted using '--\n                                  prompt' option.  [env var: ANTA_PASSWORD]\n--enable-password TEXT          Password to access EOS Privileged EXEC mode.\n                                  It can be prompted using '--prompt' option.\n                                  Requires '--enable' option.  [env var:\n                                  ANTA_ENABLE_PASSWORD]\n--enable                        Some commands may require EOS Privileged\n                                  EXEC mode. This option tries to access this\n                                  mode before sending a command to the device.\n                                  [env var: ANTA_ENABLE]\n-P, --prompt                    Prompt for passwords if they are not\n                                  provided.\n  --timeout INTEGER               Global connection timeout  [env var:\n                                  ANTA_TIMEOUT; default: 30]\n--insecure                      Disable SSH Host Key validation  [env var:\n                                  ANTA_INSECURE]\n-i, --inventory FILE            Path to the inventory YAML file  [env var:\n                                  ANTA_INVENTORY; required]\n--log-file FILE                 Send the logs to a file. If logging level is\n                                  DEBUG, only INFO or higher will be sent to\n                                  stdout.  [env var: ANTA_LOG_FILE]\n--log-level, --log [CRITICAL|ERROR|WARNING|INFO|DEBUG]\nANTA logging level  [env var:\n                                  ANTA_LOG_LEVEL; default: INFO]\n--ignore-status                 Always exit with success  [env var:\n                                  ANTA_IGNORE_STATUS]\n--ignore-error                  Only report failures and not errors  [env\n                                  var: ANTA_IGNORE_ERROR]\n--help                          Show this message and exit.\n\nCommands:\n  debug  Debug commands for building ANTA\n  exec   Execute commands to inventory devices\n  get    Get data from/to ANTA\n  nrfu   Run NRFU against inventory devices\n</code></pre> <p><code>username</code>, <code>password</code>, <code>enable-password</code>, <code>enable</code>, <code>timeout</code> and <code>insecure</code> values are the same for all devices</p>"},{"location":"#documentation","title":"Documentation","text":"<p>The documentation is published on ANTA package website. Also, a demo repository is available to facilitate your journey with ANTA.</p>"},{"location":"#contribution-guide","title":"Contribution guide","text":"<p>Contributions are welcome. Please refer to the contribution guide</p>"},{"location":"#credits","title":"Credits","text":"<p>Thank you to Ang\u00e9lique Phillipps, Colin MacGiollaE\u00e1in, Khelil Sator, Matthieu Tache, Onur Gashi, Paul Lavelle, Guillaume Mulocher and Thomas Grimonet for their contributions and guidances.</p>"},{"location":"contribution/","title":"Contributions","text":""},{"location":"contribution/#how-to-contribute-to-anta","title":"How to contribute to ANTA","text":"<p>Contribution model is based on a fork-model. Don\u2019t push to arista-netdevops-community/anta directly. Always do a branch in your forked repository and create a PR.</p> <p>To help development, open your PR as soon as possible even in draft mode. It helps other to know on what you are working on and avoid duplicate PRs.</p>"},{"location":"contribution/#create-a-development-environement","title":"Create a development environement","text":"<p>Run the following commands to create an ANTA development environement:</p> <pre><code># Clone repository\n$ git clone https://github.com/arista-netdevops-community/anta.git\n$ cd anta\n\n# Install ANTA in editable mode and its development tools\n$ pip install -e .[dev]\n\n# Verify installation\n$ pip list -e\nPackage Version Editable project location\n------- ------- -------------------------\nanta    0.7.2   /mnt/lab/projects/anta\n</code></pre> <p>Then, <code>tox</code> is configued with few environments to run CI locally:</p> <pre><code>$ tox list -d\ndefault environments:\nclean  -&gt; Erase previous coverage reports\nlint   -&gt; Check the code style\ntype   -&gt; Check typing\npy38   -&gt; Run pytest with py38\npy39   -&gt; Run pytest with py39\npy310  -&gt; Run pytest with py310\npy311  -&gt; Run pytest with py311\nreport -&gt; Generate coverage report\n</code></pre>"},{"location":"contribution/#code-linting","title":"Code linting","text":"<pre><code>tox -e lint\n[...]\nlint: commands[0]&gt; black --check --diff --color .\nAll done! \u2728 \ud83c\udf70 \u2728\n104 files would be left unchanged.\nlint: commands[1]&gt; isort --check --diff --color .\nSkipped 7 files\nlint: commands[2]&gt; flake8 --max-line-length=165 --config=/dev/null anta\nlint: commands[3]&gt; flake8 --max-line-length=165 --config=/dev/null tests\nlint: commands[4]&gt; pylint anta\n\n--------------------------------------------------------------------\nYour code has been rated at 10.00/10 (previous run: 10.00/10, +0.00)\n\n.pkg: _exit&gt; python /Users/guillaumemulocher/.pyenv/versions/3.8.13/envs/anta/lib/python3.8/site-packages/pyproject_api/_backend.py True setuptools.build_meta\n  lint: OK (19.26=setup[5.83]+cmd[1.50,0.76,1.19,1.20,8.77] seconds)\ncongratulations :) (19.56 seconds)\n</code></pre>"},{"location":"contribution/#code-typing","title":"Code Typing","text":"<pre><code>tox -e type\n\n[...]\ntype: commands[0]&gt; mypy --config-file=pyproject.toml anta\nSuccess: no issues found in 52 source files\n.pkg: _exit&gt; python /Users/guillaumemulocher/.pyenv/versions/3.8.13/envs/anta/lib/python3.8/site-packages/pyproject_api/_backend.py True setuptools.build_meta\n  type: OK (46.66=setup[24.20]+cmd[22.46] seconds)\ncongratulations :) (47.01 seconds)\n</code></pre> <p>NOTE: Typing is configured quite strictly, do not hesitate to reach out if you have any questions, struggles, nightmares.</p>"},{"location":"contribution/#unit-tests","title":"Unit tests","text":"<p>To keep high quality code, we require to provide a Pytest for every tests implemented in ANTA.</p> <p>All submodule should have its own pytest section under <code>tests/units/anta_tests/&lt;submodule-name&gt;.py</code>.</p>"},{"location":"contribution/#how-to-write-a-unit-test-for-an-antatest-subclass","title":"How to write a unit test for an AntaTest subclass","text":"<p>The Python modules in the <code>tests/units/anta_tests</code> folder  define test parameters for AntaTest subclasses unit tests. A generic test function is written for all unit tests in <code>tests.lib.anta</code> module. The <code>pytest_generate_tests</code> function definition in <code>conftest.py</code> is called during test collection. The <code>pytest_generate_tests</code> function will parametrize the generic test function based on the <code>DATA</code> data structure defined in <code>tests.units.anta_tests</code> modules. See https://docs.pytest.org/en/7.3.x/how-to/parametrize.html#basic-pytest-generate-tests-example</p> <p>The <code>DATA</code> structure is a list of dictionaries used to parametrize the test. The list elements have the following keys: - <code>name</code> (str): Test name as displayed by Pytest. - <code>test</code> (AntaTest): An AntaTest subclass imported in the test module - e.g. VerifyUptime. - <code>eos_data</code> (list[dict]): List of data mocking EOS returned data to be passed to the test. - <code>inputs</code> (dict): Dictionary to instantiate the <code>test</code> inputs as defined in the class from <code>test</code>. - <code>expected</code> (dict): Expected test result structure, a dictionary containing a key     <code>result</code> containing one of the allowed status (<code>Literal['success', 'failure', 'unset', 'skipped', 'error']</code>) and optionally a key <code>messages</code> which is a list(str) and each message is expected to  be a substring of one of the actual messages in the TestResult object.</p> <p>In order for your unit tests to be correctly collected, you need to import the generic test function even if not used in the Python module.</p> <p>Test example for <code>anta.tests.system.VerifyUptime</code> AntaTest.</p> <pre><code># Import the generic test function\nfrom tests.lib.anta import test  # noqa: F401\n\n# Import your AntaTest\nfrom anta.tests.system import VerifyUptime\n\n# Define test parameters\nDATA: list[dict[str, Any]] = [\n   {\n        # Arbitrary test name\n        \"name\": \"success\",\n        # Must be an AntaTest definition\n        \"test\": VerifyUptime,\n        # Data returned by EOS on which the AntaTest is tested\n        \"eos_data\": [{\"upTime\": 1186689.15, \"loadAvg\": [0.13, 0.12, 0.09], \"users\": 1, \"currentTime\": 1683186659.139859}],\n        # Dictionary to instantiate VerifyUptime.Input\n        \"inputs\": {\"minimum\": 666},\n        # Expected test result\n        \"expected\": {\"result\": \"success\"},\n    },\n    {\n        \"name\": \"failure\",\n        \"test\": VerifyUptime,\n        \"eos_data\": [{\"upTime\": 665.15, \"loadAvg\": [0.13, 0.12, 0.09], \"users\": 1, \"currentTime\": 1683186659.139859}],\n        \"inputs\": {\"minimum\": 666},\n        # If the test returns messages, it needs to be expected otherwise test will fail.\n        # NB: expected messages only needs to be included in messages returned by the test. Exact match is not required.\n        \"expected\": {\"result\": \"failure\", \"messages\": [\"Device uptime is 665.15 seconds\"]},\n    },\n]\n</code></pre>"},{"location":"contribution/#git-pre-commit-hook","title":"Git Pre-commit hook","text":"<pre><code>pip install pre-commit\npre-commit install\n</code></pre> <p>When running a commit or a pre-commit check:</p> <pre><code>\u276f echo \"import foobaz\" &gt; test.py &amp;&amp; git add test.py\n\u276f pre-commit\npylint...................................................................Failed\n- hook id: pylint\n- exit code: 22\n\n************* Module test\ntest.py:1:0: C0114: Missing module docstring (missing-module-docstring)\ntest.py:1:0: E0401: Unable to import 'foobaz' (import-error)\ntest.py:1:0: W0611: Unused import foobaz (unused-import)\n</code></pre> <p>NOTE: It could happen that pre-commit and tox disagree on something, in that case please open an issue on Github so we can take a look.. It is most probably wrong configuration on our side.</p>"},{"location":"contribution/#configure-mypypath","title":"Configure MYPYPATH","text":"<p>In some cases, mypy can complain about not having <code>MYPYPATH</code> configured in your shell. It is especially the case when you update both an anta test and its unit test. So you can configure this environment variable with:</p> <pre><code># Option 1: use local folder\nexport MYPYPATH=.\n\n# Option 2: use absolute path\nexport MYPYPATH=/path/to/your/local/anta/repository\n</code></pre>"},{"location":"contribution/#documentation","title":"Documentation","text":"<p><code>mkdocs</code> is used to generate the documentation. A PR should always update the documentation to avoid documentation debt.</p>"},{"location":"contribution/#install-documentation-requirements","title":"Install documentation requirements","text":"<p>Run pip to install the documentation requirements from the root of the repo:</p> <pre><code>pip install -e .[doc]\n</code></pre>"},{"location":"contribution/#testing-documentation","title":"Testing documentation","text":"<p>You can then check locally the documentation using the following command from the root of the repo:</p> <pre><code>mkdocs serve\n</code></pre> <p>By default, <code>mkdocs</code> listens to http://127.0.0.1:8000/, if you need to expose the documentation to another IP or port (for instance all IPs on port 8080), use the following command:</p> <pre><code>mkdocs serve --dev-addr=0.0.0.0:8080\n</code></pre>"},{"location":"contribution/#build-class-diagram","title":"Build class diagram","text":"<p>To build class diagram to use in API documentation, you can use <code>pyreverse</code> part of <code>pylint</code> with <code>graphviz</code> installed for jpeg generation.</p> <pre><code>pyreverse anta --colorized -a1 -s1 -o jpeg -m true -k --output-directory docs/imgs/uml/ -c &lt;FQDN anta class&gt;\n</code></pre> <p>Image will be generated under <code>docs/imgs/uml/</code> and can be inserted in your documentation.</p>"},{"location":"contribution/#checking-links","title":"Checking links","text":"<p>Writing documentation is crucial but managing links can be cumbersome. To be sure there is no dead links, you can use <code>muffet</code> with the following command:</p> <pre><code>muffet -c 2 --color=always http://127.0.0.1:8000 -e fonts.gstatic.com\n</code></pre>"},{"location":"contribution/#continuous-integration","title":"Continuous Integration","text":"<p>GitHub actions is used to test git pushes and pull requests. The workflows are defined in this directory. We can view the results here.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#frequently-asked-questions-faq","title":"Frequently Asked Questions (FAQ)","text":""},{"location":"faq/#why-am-i-seeing-an-importerror-related-to-urllib3-when-running-anta","title":"Why am I seeing an <code>ImportError</code> related to <code>urllib3</code> when running ANTA?","text":"<p>When running the <code>anta --help</code> command, some users might encounter the following error:</p> <pre><code>ImportError: urllib3 v2.0 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'OpenSSL 1.0.2k-fips  26 Jan 2017'. See: https://github.com/urllib3/urllib3/issues/2168\n</code></pre> <p>This error arises due to a compatibility issue between <code>urllib3</code> v2.0 and older versions of OpenSSL.</p>"},{"location":"faq/#how-can-i-resolve-this-error","title":"How can I resolve this error?","text":"<ol> <li> <p>Workaround: Downgrade <code>urllib3</code></p> <p>If you need a quick fix, you can temporarily downgrade the <code>urllib3</code> package:</p> <pre><code>pip3 uninstall urllib3\n\npip3 install urllib3==1.26.15\n</code></pre> </li> <li> <p>Recommended: Upgrade System or Libraries:</p> <p>As per the urllib3 v2 migration guide, the root cause of this error is an incompatibility with older OpenSSL versions. For example, users on RHEL7 might consider upgrading to RHEL8, which supports the required OpenSSL version.</p> </li> </ol>"},{"location":"faq/#still-facing-issues","title":"Still facing issues?","text":"<p>If you\u2019ve tried the above solutions and continue to experience problems, please report the issue in our GitHub repository.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#getting-started","title":"Getting Started","text":"<p>This section shows how to use ANTA with basic configuration. All examples are based on Arista Test Drive (ATD) topology you can access by reaching out to your prefered SE.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>The easiest way to intall ANTA package is to run Python (<code>&gt;=3.8</code>) and its pip package to install:</p> <pre><code>pip install anta\n</code></pre> <p>For more details about how to install package, please see the requirements and intallation section.</p>"},{"location":"getting-started/#configure-arista-eos-devices","title":"Configure Arista EOS devices","text":"<p>For ANTA to be able to connect to your target devices, you need to configure your management interface</p> <pre><code>vrf instance MGMT\n!\ninterface Management0\n   description oob_management\n   vrf MGMT\n   ip address 192.168.0.10/24\n!\n</code></pre> <p>Then, configure access to eAPI:</p> <pre><code>!\nmanagement api http-commands\n   protocol https port 443\n   no shutdown\n   vrf MGMT\n      no shutdown\n   !\n!\n</code></pre>"},{"location":"getting-started/#create-your-inventory","title":"Create your inventory","text":"<p>ANTA uses an inventory to list the target devices for the tests. You can create a file manually with this format:</p> <pre><code>anta_inventory:\nhosts:\n- host: 192.168.0.10\nname: spine01\ntags: ['fabric', 'spine']\n- host: 192.168.0.11\nname: spine02\ntags: ['fabric', 'spine']\n- host: 192.168.0.12\nname: leaf01\ntags: ['fabric', 'leaf']\n- host: 192.168.0.13\nname: leaf02\ntags: ['fabric', 'leaf']\n- host: 192.168.0.14\nname: leaf03\ntags: ['fabric', 'leaf']\n- host: 192.168.0.15\nname: leaf04\ntags: ['fabric', 'leaf']\n</code></pre> <p>You can read more details about how to build your inventory here</p>"},{"location":"getting-started/#test-catalog","title":"Test Catalog","text":"<p>To test your network, ANTA relies on a test catalog to list all the tests to run against your inventory. A test catalog references python functions into a yaml file.</p> <p>The structure to follow is like:</p> <pre><code>&lt;anta_tests_submodule&gt;:\n- &lt;anta_tests_submodule function name&gt;:\n&lt;test function option&gt;:\n&lt;test function option value&gt;\n</code></pre> <p>You can read more details about how to build your catalog here</p> <p>Here is an example for basic tests:</p> <pre><code># Load anta.tests.software\nanta.tests.software:\n- VerifyEOSVersion: # Verifies the device is running one of the allowed EOS version.\nversions: # List of allowed EOS versions.\n- 4.25.4M\n- 4.26.1F\n- '4.28.3M-28837868.4283M (engineering build)'\n- VerifyTerminAttrVersion:\nversions:\n- v1.22.1\n\nanta.tests.system:\n- VerifyUptime: # Verifies the device uptime is higher than a value.\nminimum: 1\n- VerifyNTP:\n- VerifySyslog:\n\nanta.tests.mlag:\n- VerifyMlagStatus:\n- VerifyMlagInterfaces:\n- VerifyMlagConfigSanity:\n\nanta.tests.configuration:\n- VerifyZeroTouch: # Verifies ZeroTouch is disabled.\n- VerifyRunningConfigDiffs:\n</code></pre>"},{"location":"getting-started/#test-your-network","title":"Test your network","text":"<p>ANTA comes with a generic CLI entrypoint to run tests in your network. It requires an inventory file as well as a test catalog.</p> <p>This entrypoint has multiple options to manage test coverage and reporting.</p> <pre><code># Generic ANTA options\n$ anta\nUsage: anta [OPTIONS] COMMAND [ARGS]...\n\n  Arista Network Test Automation (ANTA) CLI\n\nOptions:\n  --version                       Show the version and exit.\n  --username TEXT                 Username to connect to EOS  [env var:\n                                  ANTA_USERNAME; required]\n--password TEXT                 Password to connect to EOS that must be\n                                  provided. It can be prompted using '--\n                                  prompt' option.  [env var: ANTA_PASSWORD]\n--enable-password TEXT          Password to access EOS Privileged EXEC mode.\n                                  It can be prompted using '--prompt' option.\n                                  Requires '--enable' option.  [env var:\n                                  ANTA_ENABLE_PASSWORD]\n--enable                        Some commands may require EOS Privileged\n                                  EXEC mode. This option tries to access this\n                                  mode before sending a command to the device.\n                                  [env var: ANTA_ENABLE]\n-P, --prompt                    Prompt for passwords if they are not\n                                  provided.\n  --timeout INTEGER               Global connection timeout  [env var:\n                                  ANTA_TIMEOUT; default: 30]\n--insecure                      Disable SSH Host Key validation  [env var:\n                                  ANTA_INSECURE]\n-i, --inventory FILE            Path to the inventory YAML file  [env var:\n                                  ANTA_INVENTORY; required]\n--log-file FILE                 Send the logs to a file. If logging level is\n                                  DEBUG, only INFO or higher will be sent to\n                                  stdout.  [env var: ANTA_LOG_FILE]\n--log-level, --log [CRITICAL|ERROR|WARNING|INFO|DEBUG]\nANTA logging level  [env var:\n                                  ANTA_LOG_LEVEL; default: INFO]\n--ignore-status                 Always exit with success  [env var:\n                                  ANTA_IGNORE_STATUS]\n--ignore-error                  Only report failures and not errors  [env\n                                  var: ANTA_IGNORE_ERROR]\n--help                          Show this message and exit.\n\nCommands:\n  debug  Debug commands for building ANTA\n  exec   Execute commands to inventory devices\n  get    Get data from/to ANTA\n  nrfu   Run NRFU against inventory devices\n</code></pre> <pre><code># NRFU part of ANTA\n$ anta nrfu --help\nUsage: anta nrfu [OPTIONS] COMMAND [ARGS]...\n\n  Run NRFU against inventory devices\n\nOptions:\n  -c, --catalog FILE  Path to the tests catalog YAML file  [env var:\n                      ANTA_NRFU_CATALOG; required]\n--help              Show this message and exit.\n\nCommands:\n  json        ANTA command to check network state with JSON result\n  table       ANTA command to check network states with table result\n  text        ANTA command to check network states with text result\n  tpl-report  ANTA command to check network state with templated report\n</code></pre> <p>Currently to be able to run <code>anta nrfu --help</code> you need to have given to ANTA the mandatory input parameters: username, password and inventory otherwise the CLI will report an issue. This is tracked in: https://github.com/arista-netdevops-community/anta/issues/263</p> <p>To run the NRFU, you need to select an output format amongst [\u201cjson\u201d, \u201ctable\u201d, \u201ctext\u201d, \u201ctpl-report\u201d]. For a first usage, <code>table</code> is recommended.  By default all test results for all devices are rendered but it can be changed to a report per test case or per host</p>"},{"location":"getting-started/#default-report-using-table","title":"Default report using table","text":"<pre><code>anta \\\n--username tom \\\n--password arista123 \\\n--enable \\\n--enable-password t \\\n--inventory .personal/inventory_atd.yml \\\nnrfu --catalog .personal/tests-bases.yml table --tags leaf\n\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Running ANTA tests:                                  \u2502\n\u2502 - ANTA Inventory contains 6 devices (AsyncEOSDevice) \u2502\n\u2502 - Tests catalog contains 10 tests                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n[10:17:24] INFO     Running ANTA tests...                                                                                                           runner.py:75\n  \u2022 Running NRFU Tests...100% \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 40/40 \u2022 0:00:02 \u2022 0:00:00\n\n                                                                       All tests results\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Device IP \u2503 Test Name                \u2503 Test Status \u2503 Message(s)       \u2503 Test description                                                     \u2503 Test category \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 leaf01    \u2502 VerifyEOSVersion         \u2502 success     \u2502                  \u2502 Verifies the device is running one of the allowed EOS version.       \u2502 software      \u2502\n\u2502 leaf01    \u2502 VerifyTerminAttrVersion  \u2502 success     \u2502                  \u2502 Verifies the device is running one of the allowed TerminAttr         \u2502 software      \u2502\n\u2502           \u2502                          \u2502             \u2502                  \u2502 version.                                                             \u2502               \u2502\n\u2502 leaf01    \u2502 VerifyUptime             \u2502 success     \u2502                  \u2502 Verifies the device uptime is higher than a value.                   \u2502 system        \u2502\n\u2502 leaf01    \u2502 VerifyNTP                \u2502 success     \u2502                  \u2502 Verifies NTP is synchronised.                                        \u2502 system        \u2502\n\u2502 leaf01    \u2502 VerifySyslog             \u2502 success     \u2502                  \u2502 Verifies the device had no syslog message with a severity of warning \u2502 system        \u2502\n\u2502           \u2502                          \u2502             \u2502                  \u2502 (or a more severe message) during the last 7 days.                   \u2502               \u2502\n\u2502 leaf01    \u2502 VerifyMlagStatus         \u2502 skipped     \u2502 MLAG is disabled \u2502 This test verifies the health status of the MLAG configuration.      \u2502 mlag          \u2502\n\u2502 leaf01    \u2502 VerifyMlagInterfaces     \u2502 skipped     \u2502 MLAG is disabled \u2502 This test verifies there are no inactive or active-partial MLAG      \u2502 mlag          \u2502\n[...]\n\u2502 leaf04    \u2502 VerifyMlagConfigSanity   \u2502 skipped     \u2502 MLAG is disabled \u2502 This test verifies there are no MLAG config-sanity inconsistencies.  \u2502 mlag          \u2502\n\u2502 leaf04    \u2502 VerifyZeroTouch          \u2502 success     \u2502                  \u2502 Verifies ZeroTouch is disabled.                                      \u2502 configuration \u2502\n\u2502 leaf04    \u2502 VerifyRunningConfigDiffs \u2502 success     \u2502                  \u2502                                                                      \u2502 configuration \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"getting-started/#report-in-text-mode","title":"Report in text mode","text":"<pre><code>$ anta \\\n--username tom \\\n--password arista123 \\\n--enable \\\n--enable-password t \\\n--inventory .personal/inventory_atd.yml \\\nnrfu --catalog .personal/tests-bases.yml text --tags leaf\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Running ANTA tests:                                  \u2502\n\u2502 - ANTA Inventory contains 6 devices (AsyncEOSDevice) \u2502\n\u2502 - Tests catalog contains 10 tests                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n[10:20:47] INFO     Running ANTA tests...                                                                                                           runner.py:75\n  \u2022 Running NRFU Tests...100% \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 40/40 \u2022 0:00:01 \u2022 0:00:00\nleaf01 :: VerifyEOSVersion :: SUCCESS\nleaf01 :: VerifyTerminAttrVersion :: SUCCESS\nleaf01 :: VerifyUptime :: SUCCESS\nleaf01 :: VerifyNTP :: SUCCESS\nleaf01 :: VerifySyslog :: SUCCESS\nleaf01 :: VerifyMlagStatus :: SKIPPED (MLAG is disabled)\nleaf01 :: VerifyMlagInterfaces :: SKIPPED (MLAG is disabled)\nleaf01 :: VerifyMlagConfigSanity :: SKIPPED (MLAG is disabled)\n[...]\n</code></pre>"},{"location":"getting-started/#report-per-host","title":"Report per host","text":"<pre><code>$ anta \\\n--username tom \\\n--password arista123 \\\n--enable \\\n--enable-password t \\\n--inventory .personal/inventory_atd.yml \\\nnrfu --catalog .personal/tests-bases.yml json --tags leaf\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Running ANTA tests:                                  \u2502\n\u2502 - ANTA Inventory contains 6 devices (AsyncEOSDevice) \u2502\n\u2502 - Tests catalog contains 10 tests                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n[10:21:51] INFO     Running ANTA tests...                                                                                                           runner.py:75\n  \u2022 Running NRFU Tests...100% \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 40/40 \u2022 0:00:02 \u2022 0:00:00\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 JSON results of all tests                                                                                                                                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n[\n{\n\"name\": \"leaf01\",\n    \"test\": \"VerifyEOSVersion\",\n    \"categories\": [\n\"software\"\n],\n    \"description\": \"Verifies the device is running one of the allowed EOS version.\",\n    \"result\": \"success\",\n    \"messages\": [],\n    \"custom_field\": \"None\",\n  },\n  {\n\"name\": \"leaf01\",\n    \"test\": \"VerifyTerminAttrVersion\",\n    \"categories\": [\n\"software\"\n],\n    \"description\": \"Verifies the device is running one of the allowed TerminAttr version.\",\n    \"result\": \"success\",\n    \"messages\": [],\n    \"custom_field\": \"None\",\n  },\n[...]\n]\n</code></pre> <p>You can find more information under the usage section of the website</p>"},{"location":"requirements-and-installation/","title":"Installation","text":""},{"location":"requirements-and-installation/#anta-requirements","title":"ANTA Requirements","text":""},{"location":"requirements-and-installation/#python-version","title":"Python version","text":"<p>Python 3 (<code>&gt;=3.8</code>) is required:</p> <pre><code>python --version\nPython 3.9.9\n</code></pre>"},{"location":"requirements-and-installation/#install-anta-package","title":"Install ANTA package","text":"<p>This installation will deploy tests collection, scripts and all their Python requirements.</p> <p>The ANTA package and the cli require some packages that are not part of the Python standard library. They are indicated in the pyproject.toml file, under dependencies.</p>"},{"location":"requirements-and-installation/#install-from-pypi-server","title":"Install from Pypi server","text":"<pre><code>pip install anta\n</code></pre>"},{"location":"requirements-and-installation/#install-anta-from-github","title":"Install ANTA from github","text":"<pre><code>pip install git+https://github.com/arista-netdevops-community/anta.git\n\n# You can even specify the branch, tag or commit:\npip install git+https://github.com/arista-netdevops-community/anta.git@&lt;cool-feature-branch&gt;\npip install git+https://github.com/arista-netdevops-community/anta.git@&lt;cool-tag&gt;\npip install git+https://github.com/arista-netdevops-community/anta.git@&lt;more-or-less-cool-hash&gt;\n</code></pre>"},{"location":"requirements-and-installation/#check-installation","title":"Check installation","text":"<p>After installing ANTA, verify the installation with the following commands:</p> <pre><code># Check ANTA has been installed in your python path\npip list | grep anta\n\n# Check scripts are in your $PATH\n# Path may differ but it means CLI is in your path\nwhich anta\n/home/tom/.pyenv/shims/anta\n</code></pre> <p>Warning</p> <p>Before running the <code>anta --version</code> command, please be aware that some users have reported issues related to the <code>urllib3</code> package. If you encounter an error at this step, please refer to our FAQ page for guidance on resolving it.</p> <pre><code># Check ANTA version\nanta --version\nanta, version v0.7.2\n</code></pre>"},{"location":"requirements-and-installation/#eos-requirements","title":"EOS Requirements","text":"<p>To get ANTA working, the targetted Arista EOS devices must have the following configuration (assuming you connect to the device using Management interface in MGMT VRF):</p> <pre><code>configure\n!\nvrf instance MGMT\n!\ninterface Management1\n   description oob_management\n   vrf MGMT\n   ip address 10.73.1.105/24\n!\nend\n</code></pre> <p>Enable eAPI on the MGMT vrf:</p> <pre><code>configure\n!\nmanagement api http-commands\n   protocol https port 443\n   no shutdown\n   vrf MGMT\n      no shutdown\n!\nend\n</code></pre> <p>Now the swicth accepts on port 443 in the MGMT VRF HTTPS requests containing a list of CLI commands.</p> <p>Run these EOS commands to verify:</p> <pre><code>show management http-server\nshow management api http-commands\n</code></pre>"},{"location":"usage-inventory-catalog/","title":"Inventory & Tests catalog","text":""},{"location":"usage-inventory-catalog/#inventory-and-catalog-definition","title":"Inventory and Catalog definition","text":"<p>This page describes how to create an inventory and a tests catalog.</p>"},{"location":"usage-inventory-catalog/#create-an-inventory-file","title":"Create an inventory file","text":"<p><code>anta</code> cli needs an inventory file to list all devices to tests. This inventory is a YAML file with the folowing keys:</p> <pre><code>anta_inventory:\nhosts:\n- host: &lt; ip address value &gt;\nport: &lt; TCP port for eAPI. Default is 443 (Optional)&gt;\nname: &lt; name to display in report. Default is host:port (Optional) &gt;\ntags: &lt; list of tags to use to filter inventory during tests. Default is ['all']. (Optional) &gt;\nnetworks:\n- network: &lt; network using CIDR notation &gt;\ntags: &lt; list of tags to use to filter inventory during tests. Default is ['all']. (Optional) &gt;\nranges:\n- start: &lt; first ip address value of the range &gt;\nend: &lt; last ip address value of the range &gt;\ntags: &lt; list of tags to use to filter inventory during tests. Default is ['all']. (Optional) &gt;\n</code></pre> <p>Your inventory file can be based on any of these 3 keys and MUST start with <code>anta_inventory</code> key. A full description of the inventory model is available in API documentation</p> <p>An inventory example:</p> <pre><code>---\nanta_inventory:\nhosts:\n- host: 192.168.0.10\nname: spine01\ntags: ['fabric', 'spine']\n- host: 192.168.0.11\nname: spine02\ntags: ['fabric', 'spine']\nnetworks:\n- network: '192.168.110.0/24'\ntags: ['fabric', 'leaf']\nranges:\n- start: 10.0.0.9\nend: 10.0.0.11\ntags: ['fabric', 'l2leaf']\n</code></pre>"},{"location":"usage-inventory-catalog/#test-catalog","title":"Test Catalog","text":"<p>In addition to your inventory file, you also have to define a catalog of tests to execute against all your devices. This catalog list all your tests and their parameters. Its format is a YAML file and keys are tests functions inherited from the python path.</p>"},{"location":"usage-inventory-catalog/#default-tests-catalog","title":"Default tests catalog","text":"<p>All tests are located under <code>anta.tests</code> module and are categorised per family (one submodule). So to run test for software version, you can do:</p> <pre><code>anta.tests.software:\n- VerifyEosVersion:\n</code></pre> <p>It will load the test <code>VerifyEosVersion</code> located in <code>anta.tests.software</code>. But since this function has parameters, we will create a catalog with the following structure:</p> <pre><code>anta.tests.software:\n- VerifyEosVersion:\n# List of allowed EOS versions.\nversions:\n- 4.25.4M\n- 4.26.1F\n</code></pre> <p>To get a list of all available tests and their respective parameters, you can read the tests section of this website.</p> <p>The following example gives a very minimal tests catalog you can use in almost any situation</p> <pre><code>---\n# Load anta.tests.software\nanta.tests.software:\n# Verifies the device is running one of the allowed EOS version.\n- VerifyEosVersion:\n# List of allowed EOS versions.\nversions:\n- 4.25.4M\n- 4.26.1F\n\n# Load anta.tests.system\nanta.tests.system:\n# Verifies the device uptime is higher than a value.\n- VerifyUptime:\nminimum: 1\n\n# Load anta.tests.configuration\nanta.tests.configuration:\n# Verifies ZeroTouch is disabled.\n- VerifyZeroTouch:\n- VerifyRunningConfigDiffs:\n</code></pre>"},{"location":"usage-inventory-catalog/#custom-tests-catalog","title":"Custom tests catalog","text":"<p>In case you want to leverage your own tests collection, you can use the following syntax:</p> <pre><code>&lt;your package name&gt;:\n- &lt;your test in your package name&gt;:\n</code></pre> <p>So for instance, it could be:</p> <pre><code>titom73.tests.system:\n- VerifyPlatform:\ntype: ['cEOS-LAB']\n</code></pre> <p>How to create custom tests</p> <p>To create your custom tests, you should refer to this following documentation</p>"},{"location":"usage-inventory-catalog/#customize-test-description-and-categories","title":"Customize test description and categories","text":"<p>It might be interesting to use your own categories and customized test description to build a better report for your environment. ANTA comes with a handy feature to define your own <code>categories</code> and <code>description</code> in the report.</p> <p>In your test catalog, use <code>result_overwrite</code> dictionary with <code>categories</code> and <code>description</code> to just overwrite this values in your report:</p> <pre><code>anta.tests.configuration:\n- VerifyZeroTouch: # Verifies ZeroTouch is disabled.\nresult_overwrite:\ncategories: ['demo', 'pr296']\ndescription: A custom test\n- VerifyRunningConfigDiffs:\nanta.tests.interfaces:\n- VerifyInterfaceUtilization:\n</code></pre> <p>Once you run <code>anta nrfu table</code>, you will see following output:</p> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Device IP \u2503 Test Name                  \u2503 Test Status \u2503 Message(s) \u2503 Test description                              \u2503 Test category \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 spine01   \u2502 VerifyZeroTouch            \u2502 success     \u2502            \u2502 A custom test                                 \u2502 demo, pr296   \u2502\n\u2502 spine01   \u2502 VerifyRunningConfigDiffs   \u2502 success     \u2502            \u2502                                               \u2502 configuration \u2502\n\u2502 spine01   \u2502 VerifyInterfaceUtilization \u2502 success     \u2502            \u2502 Verifies interfaces utilization is below 75%. \u2502 interfaces    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"advanced_usages/as-python-lib/","title":"ANTA as a Python Library","text":"<p>ANTA is a Python library that can be used in user applications. This section describes how you can leverage ANTA Python modules to help you create your own NRFU solution.</p> <p>Tip</p> <p>If you are unfamiliar with asyncio, refer to the Python documentation relevant to your Python version - https://docs.python.org/3/library/asyncio.html</p>"},{"location":"advanced_usages/as-python-lib/#antadevice-abstract-class","title":"AntaDevice Abstract Class","text":"<p>A device is represented in ANTA as a instance of a subclass of the AntaDevice abstract class. There are few abstract methods that needs to be implemented by child classes:</p> <ul> <li>The collect() coroutine is in charge of collecting outputs of AntaCommand instances.</li> <li>The refresh() coroutine is in charge of updating attributes of the AntaDevice instance. These attributes are used by AntaInventory to filter out unreachable devices or by AntaTest to skip devices based on their hardware models.</li> </ul> <p>The copy() coroutine is used to copy files to and from the device. It does not need to be implemented if tests are not using it.</p>"},{"location":"advanced_usages/as-python-lib/#asynceosdevice-class","title":"AsyncEOSDevice Class","text":"<p>The AsyncEOSDevice class is an implementation of AntaDevice for Arista EOS. It uses the aio-eapi eAPI client and the AsyncSSH library.</p> <ul> <li>The collect() coroutine collects AntaCommand outputs using eAPI.</li> <li>The refresh() coroutine tries to open a TCP connection on the eAPI port and update the <code>is_online</code> attribute accordingly. If the TCP connection succeeds, it sends a <code>show version</code> command to gather the hardware model of the device and updates the <code>established</code> and <code>hw_model</code> attributes.</li> <li>The copy() coroutine copies files to and from the device using the SCP protocol.</li> </ul>"},{"location":"advanced_usages/as-python-lib/#antainventory-class","title":"AntaInventory Class","text":"<p>The AntaInventory class is a subclass of the standard Python type dict. The keys of this dictionary are the device names, the values are AntaDevice instances.</p> <p>AntaInventory provides methods to interact with the ANTA inventory:</p> <ul> <li>The add_device() method adds an AntaDevice instance to the inventory. Adding an entry to AntaInventory with a key different from the device name is not allowed.</li> <li>The get_inventory() returns a new AntaInventory instance with filtered out devices based on the method inputs.</li> <li>The connect_inventory() coroutine will execute the refresh() coroutines of all the devices in the inventory.</li> <li>The parse() static method creates an AntaInventory instance from a YAML file and returns it. The devices are AsyncEOSDevice instances.</li> </ul> <p>To parse a YAML inventory file and print the devices connection status:</p> <pre><code>\"\"\"\nExample\n\"\"\"\nimport asyncio\n\nfrom anta.inventory import AntaInventory\n\n\nasync def main(inv: AntaInventory) -&gt; None:\n\"\"\"\n    Take an AntaInventory and:\n    1. try to connect to every device in the inventory\n    2. print a message for every device connection status\n    \"\"\"\n    await inv.connect_inventory()\n\n    for device in inv.values():\n        if device.established:\n            print(f\"Device {device.name} is online\")\n        else:\n            print(f\"Could not connect to device {device.name}\")\n\nif __name__ == \"__main__\":\n    # Create the AntaInventory instance\n    inventory = AntaInventory.parse(\n        inventory_file=\"inv.yml\",\n        username=\"arista\",\n        password=\"@rista123\",\n        timeout=15,\n    )\n\n    # Run the main coroutine\n    res = asyncio.run(main(inventory))\n</code></pre> How to create your inventory file <p>Please visit this dedicated section for how to use inventory and catalog files.</p> <p>To run an EOS commands list on the reachable devices from the inventory: <pre><code>\"\"\"\nExample\n\"\"\"\n# This is needed to run the script for python &lt; 3.10 for typing annotations\nfrom __future__ import annotations\n\nimport asyncio\nfrom pprint import pprint\n\nfrom anta.inventory import AntaInventory\nfrom anta.models import AntaCommand\n\n\nasync def main(inv: AntaInventory, commands: list[str]) -&gt; dict[str, list[AntaCommand]]:\n\"\"\"\n    Take an AntaInventory and a list of commands as string and:\n    1. try to connect to every device in the inventory\n    2. collect the results of the commands from each device\n\n    Returns:\n      a dictionary where key is the device name and the value is the list of AntaCommand ran towards the device\n    \"\"\"\n    await inv.connect_inventory()\n\n    # Make a list of coroutine to run commands towards each connected device\n    coros = []\n    # dict to keep track of the commands per device\n    result_dict = {}\n    for name, device in inv.get_inventory(established_only=True).items():\n        anta_commands = [AntaCommand(command=command, ofmt=\"json\") for command in commands]\n        result_dict[name] = anta_commands\n        coros.append(device.collect_commands(anta_commands))\n\n    # Run the coroutines\n    await asyncio.gather(*coros)\n\n    return result_dict\n\n\nif __name__ == \"__main__\":\n    # Create the AntaInventory instance\n    inventory = AntaInventory.parse(\n        inventory_file=\"inv.yml\",\n        username=\"arista\",\n        password=\"@rista123\",\n        timeout=15,\n    )\n\n    # Create a list of commands with json output\n    commands = [\"show version\", \"show ip bgp summary\"]\n\n    # Run the main asyncio  entry point\n    res = asyncio.run(main(inventory, commands))\n\n    pprint(res)\n</code></pre></p>"},{"location":"advanced_usages/as-python-lib/#use-tests-from-anta","title":"Use tests from ANTA","text":"<p>All the test classes inherit from the same abstract Base Class AntaTest. The Class definition indicates which commands are required for the test and the user should focus only on writing the <code>test</code> function with optional keywords argument. The instance of the class upon creation instantiates a TestResult object that can be accessed later on to check the status of the test ([unset, skipped, success, failure, error]).</p>"},{"location":"advanced_usages/as-python-lib/#test-structure","title":"Test structure","text":"<p>All tests are built on a class named <code>AntaTest</code> which provides a complete toolset for a test:</p> <ul> <li>Object creation</li> <li>Test definition</li> <li>TestResult definition</li> <li>Abstracted method to collect data</li> </ul> <p>This approach means each time you create a test it will be based on this <code>AntaTest</code> class. Besides that, you will have to provide some elements:</p> <ul> <li><code>name</code>: Name of the test</li> <li><code>description</code>: A human readable description of your test</li> <li><code>categories</code>: a list of categories to sort test.</li> <li><code>commands</code>: a list of command to run. This list must be a list of <code>AntaCommand</code> which is described in the next part of this document.</li> </ul> <p>Here is an example of a hardware test related to device temperature:</p> <pre><code>from __future__ import annotations\n\nimport logging\nfrom typing import Any, Dict, List, Optional, cast\n\nfrom anta.models import AntaTest, AntaCommand\n\n\nclass VerifyTemperature(AntaTest):\n\"\"\"\n    Verifies device temparture is currently OK.\n    \"\"\"\n\n    # The test name\n    name = \"VerifyTemperature\"\n    # A small description of the test, usually the first line of the class docstring\n    description = \"Verifies device temparture is currently OK\"\n    # The category of the test, usually the module name\n    categories = [\"hardware\"]\n    # The command(s) used for the test. Could be a template instead\n    commands = [AntaCommand(command=\"show system environment temperature\", ofmt=\"json\")]\n\n    # Decorator\n    @AntaTest.anta_test\n    # abstract method that must be defined by the child Test class\n    def test(self) -&gt; None:\n\"\"\"Run VerifyTemperature validation\"\"\"\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        temperature_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n        if temperature_status == \"temperatureOk\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device temperature is not OK, systemStatus: {temperature_status }\")\n</code></pre> <p>When you run the test, object will automatically call its <code>anta.models.AntaTest.collect()</code> method to get device output for each command if no pre-collected data was given to the test. This method does a loop to call <code>anta.inventory.models.InventoryDevice.collect()</code> methods which is in charge of managing device connection and how to get data.</p> run test offline <p>You can also pass eos data directly to your test if you want to validate data collected in a different workflow. An example is provided below just for information:</p> <pre><code>test = VerifyTemperature(mocked_device, eos_data=test_data[\"eos_data\"])\nasyncio.run(test.test())\n</code></pre> <p>The <code>test</code> function is always the same and must be defined with the <code>@AntaTest.anta_test</code> decorator. This function takes at least one argument which is a <code>anta.inventory.models.InventoryDevice</code> object. In some cases a test would rely on some additional inputs from the user, for instance the number of expected peers or some expected numbers. All parameters must come with a default value and the test function should validate the parameters values (at this stage this is the only place where validation can be done but there are future plans to make this better).</p> <pre><code>class VerifyTemperature(AntaTest):\n    ...\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        pass\n\nclass VerifyTransceiversManufacturers(AntaTest):\n    ...\n    @AntaTest.anta_test\n    def test(self, manufacturers: Optional[List[str]] = None) -&gt; None:\n        # validate the manufactures parameter\n        pass\n</code></pre> <p>The test itself does not return any value, but the result is directly availble from your AntaTest object and exposes a <code>anta.result_manager.models.TestResult</code> object with result, name of the test and optional messages:</p> <ul> <li><code>name</code> (str): Device name where the test has run.</li> <li><code>test</code> (str): Test name runs on the device.</li> <li><code>categories</code> (List[str]): List of categories the TestResult belongs to, by default the AntaTest categories.</li> <li><code>description</code> (str): TestResult description, by default the AntaTest description.</li> <li><code>results</code> (str): Result of the test. Can be one of [\u201cunset\u201d, \u201csuccess\u201d, \u201cfailure\u201d, \u201cerror\u201d, \u201cskipped\u201d].</li> <li><code>message</code> (str, optional): Message to report after the test if any.</li> <li><code>custom_field</code> (str, optional): Custom field to store a string for flexibility in integrating with ANTA</li> </ul> <pre><code>from anta.tests.hardware import VerifyTemperature\n\ntest = VerifyTemperature(mocked_device, eos_data=test_data[\"eos_data\"])\nasyncio.run(test.test())\nassert test.result.result == \"success\"\n</code></pre>"},{"location":"advanced_usages/as-python-lib/#classes-for-commands","title":"Classes for commands","text":"<p>To make it easier to get data, ANTA defines 2 different classes to manage commands to send to devices:</p>"},{"location":"advanced_usages/as-python-lib/#antacommand-class","title":"AntaCommand Class","text":"<p>Represent a command with following information:</p> <ul> <li>Command to run</li> <li>Ouput format expected</li> <li>eAPI version</li> <li>Output of the command</li> </ul> <p>Usage example:</p> <pre><code>from anta.models import AntaCommand\n\ncmd1 = AntaCommand(command=\"show zerotouch\")\ncmd2 = AntaCommand(command=\"show running-config diffs\", ofmt=\"text\")\n</code></pre> <p>Command revision and version</p> <ul> <li>Most of EOS commands return a JSON structure according to a model (some commands may not be modeled hence the necessity to use <code>text</code> outformat sometimes.</li> <li>The model can change across time (adding feature, \u2026 ) and when the model is changed in a non backward-compatible way, the revision number is bumped. The initial model starts with revision 1.</li> <li>A revision applies to a particular CLI command whereas a version is global to an eAPI call. The version is internally translated to a specific revision for each CLI command in the RPC call. The currently supported version vaues  are <code>1</code> and <code>latest</code>.</li> <li>A revision takes precedence over a version (e.g. if a command is run with version=\u201dlatest\u201d and revision=1, the first revision of the model is returned)</li> <li>By default eAPI returns the first revision of each model to ensure that when upgrading, intergation with existing tools is not broken. This is done by using by default <code>version=1</code> in eAPI calls.</li> </ul> <p>ANTA uses by default <code>version=\"latest\"</code> in AntaCommand. For some commands, you may want to run them with a different revision or version.</p> <p>For instance the <code>VerifyRoutingTableSize</code> test leverages the first revision of <code>show bfd peers</code>:</p> <pre><code># revision 1 as later revision introduce additional nesting for type\ncommands = [AntaCommand(command=\"show bfd peers\", revision=1)]\n</code></pre>"},{"location":"advanced_usages/as-python-lib/#antatemplate-class","title":"AntaTemplate Class","text":"<p>Because some command can require more dynamic than just a command with no parameter provided by user, ANTA supports command template: you define a template in your test class and user provide parameters when creating test object.</p> <pre><code>class RunArbitraryTemplateCommand(AntaTest):\n\"\"\"\n    Run an EOS command and return result\n    Based on AntaTest to build relevant output for pytest\n    \"\"\"\n\n    name = \"Run aributrary EOS command\"\n    description = \"To be used only with anta debug commands\"\n    template = AntaTemplate(template=\"show interfaces {ifd}\")\n    categories = [\"debug\"]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        errdisabled_interfaces = [interface for interface, value in response[\"interfaceStatuses\"].items() if value[\"linkStatus\"] == \"errdisabled\"]\n        ...\n\n\nparams = [{\"ifd\": \"Ethernet2\"}, {\"ifd\": \"Ethernet49/1\"}]\nrun_command1 = RunArbitraryTemplateCommand(device_anta, params)\n</code></pre> <p>In this example, test waits for interfaces to check from user setup and will only check for interfaces in <code>params</code></p>"},{"location":"advanced_usages/custom-tests/","title":"Developing ANTA tests","text":"<p>This documentation applies for both creating tests in ANTA or creating your own test package.</p> <p>ANTA is not only a Python library with a CLI and a collection of built-in tests, it is also a framework you can extend by building your own tests.</p>"},{"location":"advanced_usages/custom-tests/#generic-approach","title":"Generic approach","text":"<p>A test is a Python class where a test function is defined and will be run by the framework.</p> <p>ANTA provides an abstract class AntaTest. This class does the heavy lifting and provide the logic to define, collect and test data. The code below is an example of a simple test in ANTA, which is an AntaTest subclass:</p> <pre><code>from anta.models import AntaTest, AntaCommand\nfrom anta.decorators import skip_on_platforms\n\n\nclass VerifyTemperature(AntaTest):\n\"\"\"\n    This test verifies if the device temperature is within acceptable limits.\n\n    Expected Results:\n      * success: The test will pass if the device temperature is currently OK: 'temperatureOk'.\n      * failure: The test will fail if the device temperature is NOT OK.\n    \"\"\"\n\n    name = \"VerifyTemperature\"\n    description = \"Verifies if the device temperature is within the acceptable range.\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show system environment temperature\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        temperature_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n        if temperature_status == \"temperatureOk\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device temperature exceeds acceptable limits. Current system status: '{temperature_status}'\")\n</code></pre> <p>AntaTest also provide more advanced capabilities like AntaCommand templating using the AntaTemplate class or test inputs definition and validation using AntaTest.Input pydantic model. This will be discussed in the sections below.</p>"},{"location":"advanced_usages/custom-tests/#antatest-structure","title":"AntaTest structure","text":""},{"location":"advanced_usages/custom-tests/#class-attributes","title":"Class Attributes","text":"<ul> <li><code>name</code> (<code>str</code>): Name of the test. Used during reporting.</li> <li><code>description</code> (<code>str</code>): A human readable description of your test.</li> <li><code>categories</code> (<code>list[str]</code>): A list of categories in which the test belongs.</li> <li><code>commands</code> (<code>list[Union[AntaTemplate, AntaCommand]]</code>): A list of command to collect from devices. This list must be a list of AntaCommand or AntaTemplate instances. Rendering AntaTemplate instances will be discussed later.</li> </ul> <p>Info</p> <p>All these class attributes are mandatory. If any attribute is missing, a <code>NotImplementedError</code> exception will be raised during class instantiation.</p>"},{"location":"advanced_usages/custom-tests/#instance-attributes","title":"Instance Attributes","text":"<p>Info</p> <p>You can access an instance attribute in your code using the <code>self</code> reference. E.g. you can access the test input values using <code>self.inputs</code>.</p> <p>Logger object</p> <p>ANTA already provides comprehensive logging at every steps of a test execution. The AntaTest class also provides a <code>logger</code> attribute that is a Python logger specific to the test instance. See Python documentation for more information.</p> <p>AntaDevice object</p> <p>Even if <code>device</code> is not a private attribute, you should not need to access this object in your code.</p>"},{"location":"advanced_usages/custom-tests/#test-inputs","title":"Test Inputs","text":"<p>AntaTest.Input is a pydantic model that allow test developers to define their test inputs. pydantic provides out of the box error handling for test input validation based on the type hints defined by the test developer.</p> <p>The base definition of AntaTest.Input provides common test inputs for all AntaTest instances:</p>"},{"location":"advanced_usages/custom-tests/#input-model","title":"Input model","text":""},{"location":"advanced_usages/custom-tests/#resultoverwrite-model","title":"ResultOverwrite model","text":"<p>Attributes:</p> Name Type Description <code>description</code> <code>Optional[str]</code> <p>overwrite TestResult.description</p> <code>categories</code> <code>Optional[List[str]]</code> <p>overwrite TestResult.categories</p> <code>custom_field</code> <code>Optional[str]</code> <p>a free string that will be included in the TestResult object</p> <p>Note</p> <p>The pydantic model is configured using the <code>extra=forbid</code> that will fail input validation if extra fields are provided.</p>"},{"location":"advanced_usages/custom-tests/#methods","title":"Methods","text":"<ul> <li>test(self) -&gt; None: This is an abstract method that must be implemented. It contains the test logic that can access the collected command outputs using the <code>instance_commands</code> instance attribute, access the test inputs using the <code>inputs</code> instance attribute and must set the <code>result</code> instance attribute accordingly. It must be implemented using the <code>AntaTest.anta_test</code> decorator that provides logging and will collect commands before executing the <code>test()</code> method.</li> <li>render(self, template: AntaTemplate) -&gt; list[AntaCommand]: This method only needs to be implemented if AntaTemplate instances are present in the <code>commands</code> class attribute. It will be called for every AntaTemplate occurence and must return a list of AntaCommand using the AntaTemplate.render() method. It can access test inputs using the <code>inputs</code> instance attribute.</li> </ul>"},{"location":"advanced_usages/custom-tests/#test-execution","title":"Test execution","text":"<p>Below is a high level description of the test execution flow in ANTA:</p> <ol> <li> <p>ANTA will parse the test catalog to get the list of AntaTest subclasses to instantiate and their associated input values. We consider a single AntaTest subclass in the following steps.</p> </li> <li> <p>ANTA will instantiate the AntaTest subclass and a single device will be provided to the test instance. The <code>Input</code> model defined in the class will also be instantiated at this moment. If any ValidationError is raised, the test execution will be stopped.</p> </li> <li> <p>If there is any AntaTemplate instance in the <code>commands</code> class attribute, render() will be called for every occurrence. At this moment, the <code>instance_commands</code> attribute has been initialized. If any rendering error occurs, the test execution will be stopped.</p> </li> <li> <p>The <code>AntaTest.anta_test</code> decorator will collect the commands from the device and update the <code>instance_commands</code> attribute with the outputs. If any collection error occurs, the test execution will be stopped.</p> </li> <li> <p>The test() method is executed.</p> </li> </ol>"},{"location":"advanced_usages/custom-tests/#writing-an-antatest-subclass","title":"Writing an AntaTest subclass","text":"<p>In this section, we will go into all the details of writing an AntaTest subclass.</p>"},{"location":"advanced_usages/custom-tests/#class-definition","title":"Class definition","text":"<p>Import anta.models.AntaTest and define your own class. Define the mandatory class attributes using anta.models.AntaCommand, anta.models.AntaTemplate or both.</p> <pre><code>from anta.models import AntaTest, AntaCommand, AntaTemplate\n\n\nclass &lt;YourTestName&gt;(AntaTest):\n\"\"\"\n    &lt;a docstring description of your test&gt;\n    \"\"\"\n\n    name = \"YourTestName\"                                           # should be your class name\n    description = \"&lt;test description in human reading format&gt;\"\n    categories = [\"&lt;arbitrary category&gt;\", \"&lt;another arbitrary category&gt;\"]\n    commands = [\n        AntaCommand(\n            command=\"&lt;EOS command to run&gt;\",\n            ofmt=\"&lt;command format output&gt;\",\n            version=\"&lt;eAPI version to use&gt;\",\n            revision=\"&lt;revision to use for the command&gt;\",           # revision has precedence over version\n        ),\n        AntaTemplate(\n            template=\"&lt;Python f-string to render an EOS command&gt;\",\n            ofmt=\"&lt;command format output&gt;\",\n            version=\"&lt;eAPI version to use&gt;\",\n            revision=\"&lt;revision to use for the command&gt;\",           # revision has precedence over version\n        )\n    ]\n</code></pre>"},{"location":"advanced_usages/custom-tests/#inputs-definition","title":"Inputs definition","text":"<p>If the user needs to provide inputs for your test, you need to define a pydantic model that defines the schema of the test inputs:</p> <pre><code>class &lt;YourTestName&gt;(AntaTest):\n    ...\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        &lt;input field name&gt;: &lt;input field type&gt;\n\"\"\"&lt;input field docstring&gt;\"\"\"\n</code></pre> <p>To define an input field type, refer to the pydantic documentation about types. You can also leverage anta.custom_types that provides reusable types defined in ANTA tests.</p> <p>Regarding required, optional and nullable fields, refer to this documentation on how to define them.</p> <p>Note</p> <p>All the <code>pydantic</code> features are supported. For instance you can define validators for complex input validation.</p>"},{"location":"advanced_usages/custom-tests/#template-rendering","title":"Template rendering","text":"<p>Define the <code>render()</code> method if you have AntaTemplate instances in your <code>commands</code> class attribute:</p> <pre><code>class &lt;YourTestName&gt;(AntaTest):\n    ...\n    def render(self, template: AntaTemplate) -&gt; list[AntaCommand]:\n        return [template.render(&lt;template param&gt;=input_value) for input_value in self.inputs.&lt;input_field&gt;]\n</code></pre> <p>You can access test inputs and render as many AntaCommand as desired.</p>"},{"location":"advanced_usages/custom-tests/#test-definition","title":"Test definition","text":"<p>Implement the <code>test()</code> method with your test logic:</p> <pre><code>class &lt;YourTestName&gt;(AntaTest):\n    ...\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        pass\n</code></pre> <p>The logic usually includes the following different stages: 1. Parse the command outputs using the <code>self.instance_commands</code> instance attribute. 2. If needed, access the test inputs using the <code>self.inputs</code> instance attribute and write your conditional logic. 3. Set the <code>result</code> instance attribute to reflect the test result by either calling <code>self.result.is_success()</code> or <code>self.result.is_failure(\"&lt;FAILURE REASON&gt;\")</code>. Sometimes, setting the test result to <code>skipped</code> using <code>self.result.is_skipped(\"&lt;SKIPPED REASON&gt;\")</code> can make sense (e.g. testing the OSPF neighbor states but no neighbor was found). However, you should not need to catch any exception and set the test result to <code>error</code> since the error handling is done by the framework, see below.</p> <p>The example below is based on the VerifyTemperature test.</p> <pre><code>class VerifyTemperature(AntaTest):\n    ...\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        # Grab output of the collected command\n        command_output = self.instance_commands[0].json_output\n\n        # Do your test: In this example we check a specific field of the JSON output from EOS\n        temperature_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n        if temperature_status == \"temperatureOk\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device temperature exceeds acceptable limits. Current system status: '{temperature_status}'\")\n</code></pre> <p>As you can see there is no error handling to do in your code. Everything is packaged in the <code>AntaTest.anta_tests</code> decorator and below is a simple example of error captured when trying to access a dictionary with an incorrect key:</p> <pre><code>class VerifyTemperature(AntaTest):\n    ...\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        # Grab output of the collected command\n        command_output = self.instance_commands[0].json_output\n\n        # Access the dictionary with an incorrect key\n        command_output['incorrectKey']\n</code></pre> <pre><code>ERROR    Exception raised for test VerifyTemperature (on device 192.168.0.10) - KeyError ('incorrectKey')\n</code></pre> <p>Get stack trace for debugging</p> <p>If you want to access to the full exception stack, you can run ANTA in debug mode by setting the <code>ANTA_DEBUG</code> environment variable to <code>true</code>. Example: <pre><code>$ ANTA_DEBUG=true anta nrfu --catalog test_custom.yml text\n</code></pre></p>"},{"location":"advanced_usages/custom-tests/#test-decorators","title":"Test decorators","text":"<p>Besides the <code>AntaTest.anta_tests</code> mandatory decorator, ANTA provides some additional and optional decorators:</p> <ul> <li><code>anta.decorators.skip_on_platforms</code>: To skip a test for a function not available for some platform</li> <li><code>anta.decorators.check_bgp_family_enable</code>: To run tests only if specific BGP family is active.</li> </ul> <pre><code>from anta.decorators import skip_on_platforms\n\nclass VerifyTemperature(AntaTest):\n    ...\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        pass\n</code></pre>"},{"location":"advanced_usages/custom-tests/#access-your-custom-tests-in-the-test-catalog","title":"Access your custom tests in the test catalog","text":"<p>This section is required only if you are not merging your development into ANTA. Otherwise, just follow contribution guide.</p> <p>For that, you need to create your own Python package as described in this hitchhiker\u2019s guide to package Python code. We assume it is well known and we won\u2019t focus on this aspect. Thus, your package must be impartable by ANTA hence available in the module search path <code>sys.path</code> (you can use <code>PYTHONPATH</code> for example).</p> <p>It is very similar to what is documented in catalog section but you have to use your own package name.2</p> <p>Let say the custom Python package is <code>anta_titom73</code> and the test is defined in <code>anta_titom73.dc_project</code> Python module, the test catalog would look like:</p> <p><pre><code>anta_titom73.dc_project:\n- VerifyFeatureX:\nminimum: 1\n</code></pre> And now you can run your NRFU tests with the CLI:</p> <pre><code>anta nrfu text --catalog test_custom.yml\nspine01 :: verify_dynamic_vlan :: FAILURE (Device has 0 configured, we expect at least 1)\nspine02 :: verify_dynamic_vlan :: FAILURE (Device has 0 configured, we expect at least 1)\nleaf01 :: verify_dynamic_vlan :: SUCCESS\nleaf02 :: verify_dynamic_vlan :: SUCCESS\nleaf03 :: verify_dynamic_vlan :: SUCCESS\nleaf04 :: verify_dynamic_vlan :: SUCCESS\n</code></pre>"},{"location":"api/device/","title":"Device models","text":""},{"location":"api/device/#antadevice-base-class","title":"AntaDevice base class","text":""},{"location":"api/device/#uml-representation","title":"UML representation","text":""},{"location":"api/device/#anta.device.AntaDevice","title":"AntaDevice","text":"<pre><code>AntaDevice(name: str, tags: Optional[List[str]] = None)\n</code></pre> <p>             Bases: <code>ABC</code></p> <p>Abstract class representing a device in ANTA. An implementation of this class needs must override the abstract coroutines <code>collect()</code> and <code>refresh()</code>.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Device name</p> <code>is_online</code> <code>bool</code> <p>True if the device IP is reachable and a port can be open</p> <code>established</code> <code>bool</code> <p>True if remote command execution succeeds</p> <code>hw_model</code> <code>Optional[str]</code> <p>Hardware model of the device</p> <code>tags</code> <code>List[str]</code> <p>List of tags for this device</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Device name</p> required <code>tags</code> <code>Optional[List[str]]</code> <p>List of tags for this device</p> <code>None</code> Source code in <code>anta/device.py</code> <pre><code>def __init__(self, name: str, tags: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Constructor of AntaDevice\n\n    Args:\n        name: Device name\n        tags: List of tags for this device\n    \"\"\"\n    self.name: str = name\n    self.hw_model: Optional[str] = None\n    self.tags: List[str] = tags if tags is not None else []\n    self.is_online: bool = False\n    self.established: bool = False\n\n    # Ensure tag 'all' is always set\n    if DEFAULT_TAG not in self.tags:\n        self.tags.append(DEFAULT_TAG)\n</code></pre>"},{"location":"api/device/#anta.device.AntaDevice.collect","title":"collect  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>collect(command: AntaCommand) -&gt; None\n</code></pre> <p>Collect device command output. This abstract coroutine can be used to implement any command collection method for a device in ANTA.</p> <p>The <code>collect()</code> implementation needs to populate the <code>output</code> attribute of the <code>AntaCommand</code> object passed as argument.</p> <p>If a failure occurs, the <code>collect()</code> implementation is expected to catch the exception and implement proper logging, the <code>output</code> attribute of the <code>AntaCommand</code> object passed as argument would be <code>None</code> in this case.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>AntaCommand</code> <p>the command to collect</p> required Source code in <code>anta/device.py</code> <pre><code>@abstractmethod\nasync def collect(self, command: AntaCommand) -&gt; None:\n\"\"\"\n    Collect device command output.\n    This abstract coroutine can be used to implement any command collection method\n    for a device in ANTA.\n\n    The `collect()` implementation needs to populate the `output` attribute\n    of the `AntaCommand` object passed as argument.\n\n    If a failure occurs, the `collect()` implementation is expected to catch the\n    exception and implement proper logging, the `output` attribute of the\n    `AntaCommand` object passed as argument would be `None` in this case.\n\n    Args:\n        command: the command to collect\n    \"\"\"\n</code></pre>"},{"location":"api/device/#anta.device.AntaDevice.collect_commands","title":"collect_commands  <code>async</code>","text":"<pre><code>collect_commands(commands: List[AntaCommand]) -&gt; None\n</code></pre> <p>Collect multiple commands.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>List[AntaCommand]</code> <p>the commands to collect</p> required Source code in <code>anta/device.py</code> <pre><code>async def collect_commands(self, commands: List[AntaCommand]) -&gt; None:\n\"\"\"\n    Collect multiple commands.\n\n    Args:\n        commands: the commands to collect\n    \"\"\"\n    await asyncio.gather(*(self.collect(command=command) for command in commands))\n</code></pre>"},{"location":"api/device/#anta.device.AntaDevice.copy","title":"copy  <code>async</code>","text":"<pre><code>copy(sources: List[Path], destination: Path, direction: Literal['to', 'from'] = 'from') -&gt; None\n</code></pre> <p>Copy files to and from the device, usually through SCP. It is not mandatory to implement this for a valid AntaDevice subclass.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>List[Path]</code> <p>List of files to copy to or from the device.</p> required <code>destination</code> <code>Path</code> <p>Local or remote destination when copying the files. Can be a folder.</p> required <code>direction</code> <code>Literal['to', 'from']</code> <p>Defines if this coroutine copies files to or from the device.</p> <code>'from'</code> Source code in <code>anta/device.py</code> <pre><code>async def copy(self, sources: List[Path], destination: Path, direction: Literal[\"to\", \"from\"] = \"from\") -&gt; None:\n\"\"\"\n    Copy files to and from the device, usually through SCP.\n    It is not mandatory to implement this for a valid AntaDevice subclass.\n\n    Args:\n        sources: List of files to copy to or from the device.\n        destination: Local or remote destination when copying the files. Can be a folder.\n        direction: Defines if this coroutine copies files to or from the device.\n    \"\"\"\n    raise NotImplementedError(f\"copy() method has not been implemented in {self.__class__.__name__} definition\")\n</code></pre>"},{"location":"api/device/#anta.device.AntaDevice.refresh","title":"refresh  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Update attributes of an AntaDevice instance.</p> This coroutine must update the following attributes of AntaDevice <ul> <li><code>is_online</code>: When the device IP is reachable and a port can be open</li> <li><code>established</code>: When a command execution succeeds</li> <li><code>hw_model</code>: The hardware model of the device</li> </ul> Source code in <code>anta/device.py</code> <pre><code>@abstractmethod\nasync def refresh(self) -&gt; None:\n\"\"\"\n    Update attributes of an AntaDevice instance.\n\n    This coroutine must update the following attributes of AntaDevice:\n        - `is_online`: When the device IP is reachable and a port can be open\n        - `established`: When a command execution succeeds\n        - `hw_model`: The hardware model of the device\n    \"\"\"\n</code></pre>"},{"location":"api/device/#async-eos-device-class","title":"Async EOS device class","text":""},{"location":"api/device/#uml-representation_1","title":"UML representation","text":""},{"location":"api/device/#anta.device.AsyncEOSDevice","title":"AsyncEOSDevice","text":"<pre><code>AsyncEOSDevice(host: str, username: str, password: str, name: Optional[str] = None, enable: bool = False, enable_password: Optional[str] = None, port: Optional[int] = None, ssh_port: Optional[int] = 22, tags: Optional[List[str]] = None, timeout: Optional[float] = None, insecure: bool = False, proto: Literal['http', 'https'] = 'https')\n</code></pre> <p>             Bases: <code>AntaDevice</code></p> <p>Implementation of AntaDevice for EOS using aio-eapi.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>Device name</p> <code>is_online</code> <p>True if the device IP is reachable and a port can be open</p> <code>established</code> <p>True if remote command execution succeeds</p> <code>hw_model</code> <p>Hardware model of the device</p> <code>tags</code> <p>List of tags for this device</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Device FQDN or IP</p> required <code>username</code> <code>str</code> <p>Username to connect to eAPI and SSH</p> required <code>password</code> <code>str</code> <p>Password to connect to eAPI and SSH</p> required <code>name</code> <code>Optional[str]</code> <p>Device name</p> <code>None</code> <code>enable</code> <code>bool</code> <p>Device needs privileged access</p> <code>False</code> <code>enable_password</code> <code>Optional[str]</code> <p>Password used to gain privileged access on EOS</p> <code>None</code> <code>port</code> <code>Optional[int]</code> <p>eAPI port. Defaults to 80 is proto is \u2018http\u2019 or 443 if proto is \u2018https\u2019.</p> <code>None</code> <code>ssh_port</code> <code>Optional[int]</code> <p>SSH port</p> <code>22</code> <code>tags</code> <code>Optional[List[str]]</code> <p>List of tags for this device</p> <code>None</code> <code>timeout</code> <code>Optional[float]</code> <p>Timeout value in seconds for outgoing connections. Default to 10 secs.</p> <code>None</code> <code>insecure</code> <code>bool</code> <p>Disable SSH Host Key validation</p> <code>False</code> <code>proto</code> <code>Literal['http', 'https']</code> <p>eAPI protocol. Value can be \u2018http\u2019 or \u2018https\u2019</p> <code>'https'</code> Source code in <code>anta/device.py</code> <pre><code>def __init__(  # pylint: disable=R0913\n    self,\n    host: str,\n    username: str,\n    password: str,\n    name: Optional[str] = None,\n    enable: bool = False,\n    enable_password: Optional[str] = None,\n    port: Optional[int] = None,\n    ssh_port: Optional[int] = 22,\n    tags: Optional[List[str]] = None,\n    timeout: Optional[float] = None,\n    insecure: bool = False,\n    proto: Literal[\"http\", \"https\"] = \"https\",\n) -&gt; None:\n\"\"\"\n    Constructor of AsyncEOSDevice\n\n    Args:\n        host: Device FQDN or IP\n        username: Username to connect to eAPI and SSH\n        password: Password to connect to eAPI and SSH\n        name: Device name\n        enable: Device needs privileged access\n        enable_password: Password used to gain privileged access on EOS\n        port: eAPI port. Defaults to 80 is proto is 'http' or 443 if proto is 'https'.\n        ssh_port: SSH port\n        tags: List of tags for this device\n        timeout: Timeout value in seconds for outgoing connections. Default to 10 secs.\n        insecure: Disable SSH Host Key validation\n        proto: eAPI protocol. Value can be 'http' or 'https'\n    \"\"\"\n    if name is None:\n        name = f\"{host}{f':{port}' if port else ''}\"\n    super().__init__(name, tags)\n    self.enable = enable\n    self._enable_password = enable_password\n    self._session: Device = Device(host=host, port=port, username=username, password=password, proto=proto, timeout=timeout)\n    ssh_params: Dict[str, Any] = {}\n    if insecure:\n        ssh_params.update({\"known_hosts\": None})\n    self._ssh_opts: SSHClientConnectionOptions = SSHClientConnectionOptions(host=host, port=ssh_port, username=username, password=password, **ssh_params)\n</code></pre>"},{"location":"api/device/#anta.device.AsyncEOSDevice.collect","title":"collect  <code>async</code>","text":"<pre><code>collect(command: AntaCommand) -&gt; None\n</code></pre> <p>Collect device command output from EOS using aio-eapi.</p> <p>Supports outformat <code>json</code> and <code>text</code> as output structure. Gain privileged access using the <code>enable_password</code> attribute of the <code>AntaDevice</code> instance if populated.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>AntaCommand</code> <p>the command to collect</p> required Source code in <code>anta/device.py</code> <pre><code>async def collect(self, command: AntaCommand) -&gt; None:\n\"\"\"\n    Collect device command output from EOS using aio-eapi.\n\n    Supports outformat `json` and `text` as output structure.\n    Gain privileged access using the `enable_password` attribute\n    of the `AntaDevice` instance if populated.\n\n    Args:\n        command: the command to collect\n    \"\"\"\n    try:\n        commands = []\n        if self.enable and self._enable_password is not None:\n            commands.append(\n                {\n                    \"cmd\": \"enable\",\n                    \"input\": str(self._enable_password),\n                }\n            )\n        elif self.enable:\n            # No password\n            commands.append({\"cmd\": \"enable\"})\n        if command.revision:\n            commands.append({\"cmd\": command.command, \"revision\": command.revision})\n        else:\n            commands.append({\"cmd\": command.command})\n        response = await self._session.cli(\n            commands=commands,\n            ofmt=command.ofmt,\n            version=command.version,\n        )\n        # remove first dict related to enable command\n        # only applicable to json output\n        if command.ofmt in [\"json\", \"text\"]:\n            # selecting only our command output\n            response = response[-1]\n        command.output = response\n        logger.debug(f\"{self.name}: {command}\")\n\n    except EapiCommandError as e:\n        message = f\"Command '{command.command}' failed on {self.name}\"\n        anta_log_exception(e, message, logger)\n        command.failed = e\n    except (HTTPError, ConnectError) as e:\n        message = f\"Cannot connect to device {self.name}\"\n        anta_log_exception(e, message, logger)\n        command.failed = e\n    except Exception as e:  # pylint: disable=broad-exception-caught\n        message = f\"Exception raised while collecting command '{command.command}' on device {self.name}\"\n        anta_log_exception(e, message, logger)\n        command.failed = e\n        logger.debug(command)\n</code></pre>"},{"location":"api/device/#anta.device.AsyncEOSDevice.copy","title":"copy  <code>async</code>","text":"<pre><code>copy(sources: List[Path], destination: Path, direction: Literal['to', 'from'] = 'from') -&gt; None\n</code></pre> <p>Copy files to and from the device using asyncssh.scp().</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>List[Path]</code> <p>List of files to copy to or from the device.</p> required <code>destination</code> <code>Path</code> <p>Local or remote destination when copying the files. Can be a folder.</p> required <code>direction</code> <code>Literal['to', 'from']</code> <p>Defines if this coroutine copies files to or from the device.</p> <code>'from'</code> Source code in <code>anta/device.py</code> <pre><code>async def copy(self, sources: List[Path], destination: Path, direction: Literal[\"to\", \"from\"] = \"from\") -&gt; None:\n\"\"\"\n    Copy files to and from the device using asyncssh.scp().\n\n    Args:\n        sources: List of files to copy to or from the device.\n        destination: Local or remote destination when copying the files. Can be a folder.\n        direction: Defines if this coroutine copies files to or from the device.\n    \"\"\"\n    async with asyncssh.connect(\n        host=self._ssh_opts.host,\n        port=self._ssh_opts.port,\n        tunnel=self._ssh_opts.tunnel,\n        family=self._ssh_opts.family,\n        local_addr=self._ssh_opts.local_addr,\n        options=self._ssh_opts,\n    ) as conn:\n        src: Union[List[Tuple[SSHClientConnection, Path]], List[Path]]\n        dst: Union[Tuple[SSHClientConnection, Path], Path]\n        if direction == \"from\":\n            src = [(conn, file) for file in sources]\n            dst = destination\n            for file in sources:\n                logger.info(f\"Copying '{file}' from device {self.name} to '{destination}' locally\")\n        elif direction == \"to\":\n            src = sources\n            dst = (conn, destination)\n            for file in sources:\n                logger.info(f\"Copying '{file}' to device {self.name} to '{destination}' remotely\")\n        else:\n            logger.critical(f\"'direction' argument to copy() fonction is invalid: {direction}\")\n            return\n        await asyncssh.scp(src, dst)\n</code></pre>"},{"location":"api/device/#anta.device.AsyncEOSDevice.refresh","title":"refresh  <code>async</code>","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Update attributes of an AsyncEOSDevice instance.</p> <p>This coroutine must update the following attributes of AsyncEOSDevice: - is_online: When a device IP is reachable and a port can be open - established: When a command execution succeeds - hw_model: The hardware model of the device</p> Source code in <code>anta/device.py</code> <pre><code>async def refresh(self) -&gt; None:\n\"\"\"\n    Update attributes of an AsyncEOSDevice instance.\n\n    This coroutine must update the following attributes of AsyncEOSDevice:\n    - is_online: When a device IP is reachable and a port can be open\n    - established: When a command execution succeeds\n    - hw_model: The hardware model of the device\n    \"\"\"\n    # Refresh command\n    COMMAND: str = \"show version\"\n    # Hardware model definition in show version\n    HW_MODEL_KEY: str = \"modelName\"\n    logger.debug(f\"Refreshing device {self.name}\")\n    self.is_online = await self._session.check_connection()\n    if self.is_online:\n        try:\n            response = await self._session.cli(command=COMMAND)\n        except EapiCommandError as e:\n            logger.warning(f\"Cannot get hardware information from device {self.name}: {e.errmsg}\")\n        except (HTTPError, ConnectError) as e:\n            logger.warning(f\"Cannot get hardware information from device {self.name}: {exc_to_str(e)}\")\n        else:\n            if HW_MODEL_KEY in response:\n                self.hw_model = response[HW_MODEL_KEY]\n            else:\n                logger.warning(f\"Cannot get hardware information from device {self.name}: cannot parse '{COMMAND}'\")\n    else:\n        logger.warning(f\"Could not connect to device {self.name}: cannot open eAPI port\")\n    self.established = bool(self.is_online and self.hw_model)\n</code></pre>"},{"location":"api/inventory/","title":"Inventory module","text":""},{"location":"api/inventory/#anta.inventory.AntaInventory","title":"AntaInventory","text":"<p>             Bases: <code>dict</code></p> <p>Inventory abstraction for ANTA framework.</p>"},{"location":"api/inventory/#anta.inventory.AntaInventory.add_device","title":"add_device","text":"<pre><code>add_device(device: AntaDevice) -&gt; None\n</code></pre> <p>Add a device to final inventory.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>AntaDevice</code> <p>Device object to be added</p> required Source code in <code>anta/inventory/__init__.py</code> <pre><code>def add_device(self, device: AntaDevice) -&gt; None:\n\"\"\"Add a device to final inventory.\n\n    Args:\n        device: Device object to be added\n    \"\"\"\n    self[device.name] = device\n</code></pre>"},{"location":"api/inventory/#anta.inventory.AntaInventory.connect_inventory","title":"connect_inventory  <code>async</code>","text":"<pre><code>connect_inventory() -&gt; None\n</code></pre> <p>Run <code>refresh()</code> coroutines for all AntaDevice objects in this inventory.</p> Source code in <code>anta/inventory/__init__.py</code> <pre><code>async def connect_inventory(self) -&gt; None:\n\"\"\"Run `refresh()` coroutines for all AntaDevice objects in this inventory.\"\"\"\n    logger.debug(\"Refreshing devices...\")\n    results = await asyncio.gather(\n        *(device.refresh() for device in self.values()),\n        return_exceptions=True,\n    )\n    for r in results:\n        if isinstance(r, Exception):\n            message = \"Error when refreshing inventory\"\n            anta_log_exception(r, message, logger)\n</code></pre>"},{"location":"api/inventory/#anta.inventory.AntaInventory.get_inventory","title":"get_inventory","text":"<pre><code>get_inventory(established_only: bool = False, tags: Optional[List[str]] = None) -&gt; AntaInventory\n</code></pre> <p>Returns a filtered inventory.</p> <p>Parameters:</p> Name Type Description Default <code>established_only</code> <code>bool</code> <p>Whether or not to include only established devices. Default False.</p> <code>False</code> <code>tags</code> <code>Optional[List[str]]</code> <p>List of tags to filter devices.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>AntaInventory</code> <code>AntaInventory</code> <p>An inventory with filtered AntaDevice objects.</p> Source code in <code>anta/inventory/__init__.py</code> <pre><code>def get_inventory(self, established_only: bool = False, tags: Optional[List[str]] = None) -&gt; AntaInventory:\n\"\"\"\n    Returns a filtered inventory.\n\n    Args:\n        established_only: Whether or not to include only established devices. Default False.\n        tags: List of tags to filter devices.\n\n    Returns:\n        AntaInventory: An inventory with filtered AntaDevice objects.\n    \"\"\"\n\n    def _filter_devices(device: AntaDevice) -&gt; bool:\n\"\"\"\n        Helper function to select the devices based on the input tags\n        and the requirement for an established connection.\n        \"\"\"\n        if tags is not None and all(tag not in tags for tag in device.tags):\n            return False\n        return bool(not established_only or device.established)\n\n    devices: List[AntaDevice] = list(filter(_filter_devices, self.values()))\n    result = AntaInventory()\n    for device in devices:\n        result.add_device(device)\n    return result\n</code></pre>"},{"location":"api/inventory/#anta.inventory.AntaInventory.parse","title":"parse  <code>staticmethod</code>","text":"<pre><code>parse(inventory_file: str, username: str, password: str, enable: bool = False, enable_password: Optional[str] = None, timeout: Optional[float] = None, insecure: bool = False) -&gt; AntaInventory\n</code></pre> <p>Create an AntaInventory instance from an inventory file. The inventory devices are AsyncEOSDevice instances.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_file</code> <code>str</code> <p>Path to inventory YAML file where user has described his inputs</p> required <code>username</code> <code>str</code> <p>Username to use to connect to devices</p> required <code>password</code> <code>str</code> <p>Password to use to connect to devices</p> required <code>enable</code> <code>bool</code> <p>Whether or not the commands need to be run in enable mode towards the devices</p> <code>False</code> <code>timeout</code> <code>float</code> <p>timeout in seconds for every API call.</p> <code>None</code> <p>Raises:</p> Type Description <code>InventoryRootKeyError</code> <p>Root key of inventory is missing.</p> <code>InventoryIncorrectSchema</code> <p>Inventory file is not following AntaInventory Schema.</p> <code>InventoryUnknownFormat</code> <p>Output format is not supported.</p> Source code in <code>anta/inventory/__init__.py</code> <pre><code>@staticmethod\ndef parse(\n    inventory_file: str,\n    username: str,\n    password: str,\n    enable: bool = False,\n    enable_password: Optional[str] = None,\n    timeout: Optional[float] = None,\n    insecure: bool = False,\n) -&gt; AntaInventory:\n    # pylint: disable=too-many-arguments\n\"\"\"\n    Create an AntaInventory instance from an inventory file.\n    The inventory devices are AsyncEOSDevice instances.\n\n    Args:\n        inventory_file (str): Path to inventory YAML file where user has described his inputs\n        username (str): Username to use to connect to devices\n        password (str): Password to use to connect to devices\n        enable (bool): Whether or not the commands need to be run in enable mode towards the devices\n        timeout (float, optional): timeout in seconds for every API call.\n\n    Raises:\n        InventoryRootKeyError: Root key of inventory is missing.\n        InventoryIncorrectSchema: Inventory file is not following AntaInventory Schema.\n        InventoryUnknownFormat: Output format is not supported.\n    \"\"\"\n\n    inventory = AntaInventory()\n    kwargs: Dict[str, Any] = {\n        \"username\": username,\n        \"password\": password,\n        \"enable\": enable,\n        \"enable_password\": enable_password,\n        \"timeout\": timeout,\n        \"insecure\": insecure,\n    }\n    kwargs = {k: v for k, v in kwargs.items() if v is not None}\n\n    with open(inventory_file, \"r\", encoding=\"UTF-8\") as file:\n        data = safe_load(file)\n\n    # Load data using Pydantic\n    try:\n        inventory_input = AntaInventoryInput(**data[AntaInventory.INVENTORY_ROOT_KEY])\n    except KeyError as exc:\n        logger.error(f\"Inventory root key is missing: {AntaInventory.INVENTORY_ROOT_KEY}\")\n        raise InventoryRootKeyError(f\"Inventory root key ({AntaInventory.INVENTORY_ROOT_KEY}) is not defined in your inventory\") from exc\n    except ValidationError as exc:\n        logger.error(\"Inventory data are not compliant with inventory models\")\n        raise InventoryIncorrectSchema(f\"Inventory is not following the schema: {str(exc)}\") from exc\n\n    # Read data from input\n    AntaInventory._parse_hosts(inventory_input, inventory, **kwargs)\n    AntaInventory._parse_networks(inventory_input, inventory, **kwargs)\n    AntaInventory._parse_ranges(inventory_input, inventory, **kwargs)\n\n    return inventory\n</code></pre>"},{"location":"api/inventory/#anta.inventory.exceptions","title":"exceptions","text":"<p>Manage Exception in Inventory module.</p>"},{"location":"api/inventory/#anta.inventory.exceptions.InventoryIncorrectSchema","title":"InventoryIncorrectSchema","text":"<p>             Bases: <code>Exception</code></p> <p>Error when user data does not follow ANTA schema.</p>"},{"location":"api/inventory/#anta.inventory.exceptions.InventoryRootKeyError","title":"InventoryRootKeyError","text":"<p>             Bases: <code>Exception</code></p> <p>Error raised when inventory root key is not found.</p>"},{"location":"api/inventory.models.input/","title":"Inventory models","text":""},{"location":"api/inventory.models.input/#anta.inventory.models.AntaInventoryInput","title":"AntaInventoryInput","text":"<p>             Bases: <code>BaseModel</code></p> <p>User\u2019s inventory model.</p> <p>Attributes:</p> Name Type Description <code>networks</code> <code>(List[AntaInventoryNetwork], Optional)</code> <p>List of AntaInventoryNetwork objects for networks.</p> <code>hosts</code> <code>(List[AntaInventoryHost], Optional)</code> <p>List of AntaInventoryHost objects for hosts.</p> <code>range</code> <code>(List[AntaInventoryRange], Optional)</code> <p>List of AntaInventoryRange objects for ranges.</p>"},{"location":"api/inventory.models.input/#anta.inventory.models.AntaInventoryHost","title":"AntaInventoryHost","text":"<p>             Bases: <code>BaseModel</code></p> <p>Host definition for user\u2019s inventory.</p> <p>Attributes:</p> Name Type Description <code>host</code> <code>IPvAnyAddress</code> <p>IPv4 or IPv6 address of the device</p> <code>port</code> <code>int</code> <p>(Optional) eAPI port to use Default is 443.</p> <code>name</code> <code>str</code> <p>(Optional) Name to display during tests report. Default is hostname:port</p> <code>tags</code> <code>List[str]</code> <p>List of attached tags read from inventory file.</p>"},{"location":"api/inventory.models.input/#anta.inventory.models.AntaInventoryNetwork","title":"AntaInventoryNetwork","text":"<p>             Bases: <code>BaseModel</code></p> <p>Network definition for user\u2019s inventory.</p> <p>Attributes:</p> Name Type Description <code>network</code> <code>IPvAnyNetwork</code> <p>Subnet to use for testing.</p> <code>tags</code> <code>List[str]</code> <p>List of attached tags read from inventory file.</p>"},{"location":"api/inventory.models.input/#anta.inventory.models.AntaInventoryRange","title":"AntaInventoryRange","text":"<p>             Bases: <code>BaseModel</code></p> <p>IP Range definition for user\u2019s inventory.</p> <p>Attributes:</p> Name Type Description <code>start</code> <code>IPvAnyAddress</code> <p>IPv4 or IPv6 address for the begining of the range.</p> <code>stop</code> <code>IPvAnyAddress</code> <p>IPv4 or IPv6 address for the end of the range.</p> <code>tags</code> <code>List[str]</code> <p>List of attached tags read from inventory file.</p>"},{"location":"api/models/","title":"Test models","text":""},{"location":"api/models/#test-definition","title":"Test definition","text":""},{"location":"api/models/#uml-diagram","title":"UML Diagram","text":""},{"location":"api/models/#anta.models.AntaTest","title":"AntaTest","text":"<pre><code>AntaTest(device: AntaDevice, inputs: dict[str, Any] | None, eos_data: list[dict[Any, Any] | str] | None = None)\n</code></pre> <p>             Bases: <code>ABC</code></p> <p>Abstract class defining a test in ANTA</p> <p>The goal of this class is to handle the heavy lifting and make writing a test as simple as possible.</p> <p>Examples:</p> <p>The following is an example of an AntaTest subclass implementation:     <pre><code>    class VerifyReachability(AntaTest):\n        name = \"VerifyReachability\"\n        description = \"Test the network reachability to one or many destination IP(s).\"\n        categories = [\"connectivity\"]\n        commands = [AntaTemplate(template=\"ping vrf {vrf} {dst} source {src} repeat 2\")]\n\n        class Input(AntaTest.Input):\n            hosts: List[Host]\n            class Host(BaseModel):\n                dst: IPv4Address\n                src: IPv4Address\n                vrf: str = \"default\"\n\n        def render(self, template: AntaTemplate) -&gt; list[AntaCommand]:\n            return [template.render({\"dst\": host.dst, \"src\": host.src, \"vrf\": host.vrf}) for host in self.inputs.hosts]\n\n        @AntaTest.anta_test\n        def test(self) -&gt; None:\n            failures = []\n            for command in self.instance_commands:\n                if command.params and (\"src\" and \"dst\") in command.params:\n                    src, dst = command.params[\"src\"], command.params[\"dst\"]\n                if \"2 received\" not in command.json_output[\"messages\"][0]:\n                    failures.append((str(src), str(dst)))\n            if not failures:\n                self.result.is_success()\n            else:\n                self.result.is_failure(f\"Connectivity test failed for the following source-destination pairs: {failures}\")\n</code></pre> Attributes:     device: AntaDevice instance on which this test is run     inputs: AntaTest.Input instance carrying the test inputs     instance_commands: List of AntaCommand instances of this test     result: TestResult instance representing the result of this test     logger: Python logger for this test instance</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>AntaDevice</code> <p>AntaDevice instance on which the test will be run</p> required <code>inputs</code> <code>dict[str, Any] | None</code> <p>dictionary of attributes used to instantiate the AntaTest.Input instance</p> required <code>eos_data</code> <code>list[dict[Any, Any] | str] | None</code> <p>Populate outputs of the test commands instead of collecting from devices.       This list must have the same length and order than the <code>instance_commands</code> instance attribute.</p> <code>None</code> Source code in <code>anta/models.py</code> <pre><code>def __init__(\n    self,\n    device: AntaDevice,\n    inputs: dict[str, Any] | None,\n    eos_data: list[dict[Any, Any] | str] | None = None,\n):\n\"\"\"AntaTest Constructor\n\n    Args:\n        device: AntaDevice instance on which the test will be run\n        inputs: dictionary of attributes used to instantiate the AntaTest.Input instance\n        eos_data: Populate outputs of the test commands instead of collecting from devices.\n                  This list must have the same length and order than the `instance_commands` instance attribute.\n    \"\"\"\n    self.logger: logging.Logger = logging.getLogger(f\"{self.__module__}.{self.__class__.__name__}\")\n    self.device: AntaDevice = device\n    self.inputs: AntaTest.Input\n    self.instance_commands: list[AntaCommand] = []\n    self.result: TestResult = TestResult(name=device.name, test=self.name, categories=self.categories, description=self.description)\n    self._init_inputs(inputs)\n    if self.result.result == \"unset\":\n        self._init_commands(eos_data)\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.collected","title":"collected  <code>property</code>","text":"<pre><code>collected: bool\n</code></pre> <p>Returns True if all commands for this test have been collected.</p>"},{"location":"api/models/#anta.models.AntaTest.failed_commands","title":"failed_commands  <code>property</code>","text":"<pre><code>failed_commands: list[AntaCommand]\n</code></pre> <p>Returns a list of all the commands that have failed.</p>"},{"location":"api/models/#anta.models.AntaTest.Input","title":"Input","text":"<p>             Bases: <code>BaseModel</code></p> <p>Class defining inputs for a test in ANTA.</p> <p>Examples:</p> <p>A valid test catalog will look like the following:     <pre><code>&lt;Python module&gt;:\n- &lt;AntaTest subclass&gt;:\nresult_overwrite:\ncategories:\n- \"Overwritten category 1\"\ndescription: \"Test with overwritten description\"\ncustom_field: \"Test run by John Doe\"\n</code></pre> Attributes:     result_overwrite: Define fields to overwrite in the TestResult object</p>"},{"location":"api/models/#anta.models.AntaTest.Input.ResultOverwrite","title":"ResultOverwrite","text":"<p>             Bases: <code>BaseModel</code></p> <p>Test inputs model to overwrite result fields</p> <p>Attributes:</p> Name Type Description <code>description</code> <code>Optional[str]</code> <p>overwrite TestResult.description</p> <code>categories</code> <code>Optional[List[str]]</code> <p>overwrite TestResult.categories</p> <code>custom_field</code> <code>Optional[str]</code> <p>a free string that will be included in the TestResult object</p>"},{"location":"api/models/#anta.models.AntaTest.anta_test","title":"anta_test  <code>staticmethod</code>","text":"<pre><code>anta_test(function: F) -&gt; Callable[..., Coroutine[Any, Any, TestResult]]\n</code></pre> <p>Decorator for the <code>test()</code> method.</p> <p>This decorator implements (in this order):</p> <ol> <li>Instantiate the command outputs if <code>eos_data</code> is provided to the <code>test()</code> method</li> <li>Collect the commands from the device</li> <li>Run the <code>test()</code> method</li> <li>Catches any exception in <code>test()</code> user code and set the <code>result</code> instance attribute</li> </ol> Source code in <code>anta/models.py</code> <pre><code>@staticmethod\ndef anta_test(function: F) -&gt; Callable[..., Coroutine[Any, Any, TestResult]]:\n\"\"\"\n    Decorator for the `test()` method.\n\n    This decorator implements (in this order):\n\n    1. Instantiate the command outputs if `eos_data` is provided to the `test()` method\n    2. Collect the commands from the device\n    3. Run the `test()` method\n    4. Catches any exception in `test()` user code and set the `result` instance attribute\n    \"\"\"\n\n    @wraps(function)\n    async def wrapper(\n        self: AntaTest,\n        eos_data: list[dict[Any, Any] | str] | None = None,\n        **kwargs: Any,\n    ) -&gt; TestResult:\n\"\"\"\n        Args:\n            eos_data: Populate outputs of the test commands instead of collecting from devices.\n                      This list must have the same length and order than the `instance_commands` instance attribute.\n\n        Returns:\n            result: TestResult instance attribute populated with error status if any\n        \"\"\"\n\n        def format_td(seconds: float, digits: int = 3) -&gt; str:\n            isec, fsec = divmod(round(seconds * 10**digits), 10**digits)\n            return f\"{timedelta(seconds=isec)}.{fsec:0{digits}.0f}\"\n\n        start_time = time.time()\n        if self.result.result != \"unset\":\n            return self.result\n\n        # TODO maybe_skip decorators\n\n        # Data\n        if eos_data is not None:\n            self.save_commands_data(eos_data)\n            self.logger.debug(f\"Test {self.name} initialized with input data {eos_data}\")\n\n        # If some data is missing, try to collect\n        if not self.collected:\n            await self.collect()\n            if self.result.result != \"unset\":\n                return self.result\n\n        try:\n            if self.failed_commands:\n                self.result.is_error(\n                    message=\"\\n\".join(\n                        [f\"{cmd.command} has failed: {exc_to_str(cmd.failed)}\" if cmd.failed else f\"{cmd.command} has failed\" for cmd in self.failed_commands]\n                    )\n                )\n                return self.result\n            function(self, **kwargs)\n        except Exception as e:  # pylint: disable=broad-exception-caught\n            message = f\"Exception raised for test {self.name} (on device {self.device.name})\"\n            anta_log_exception(e, message, self.logger)\n            self.result.is_error(message=exc_to_str(e))\n\n        test_duration = time.time() - start_time\n        self.logger.debug(f\"Executing test {self.name} on device {self.device.name} took {format_td(test_duration)}\")\n\n        AntaTest.update_progress()\n        return self.result\n\n    return wrapper\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.collect","title":"collect  <code>async</code>","text":"<pre><code>collect() -&gt; None\n</code></pre> <p>Method used to collect outputs of all commands of this test class from the device of this test instance.</p> Source code in <code>anta/models.py</code> <pre><code>async def collect(self) -&gt; None:\n\"\"\"\n    Method used to collect outputs of all commands of this test class from the device of this test instance.\n    \"\"\"\n    try:\n        await self.device.collect_commands(self.instance_commands)\n    except Exception as e:  # pylint: disable=broad-exception-caught\n        message = f\"Exception raised while collecting commands for test {self.name} (on device {self.device.name})\"\n        anta_log_exception(e, message, self.logger)\n        self.result.is_error(message=exc_to_str(e))\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.render","title":"render","text":"<pre><code>render(template: AntaTemplate) -&gt; list[AntaCommand]\n</code></pre> <p>Render an AntaTemplate instance of this AntaTest using the provided    AntaTest.Input instance at self.inputs.</p> <p>This is not an abstract method because it does not need to be implemented if there is no AntaTemplate for this test.</p> Source code in <code>anta/models.py</code> <pre><code>def render(self, template: AntaTemplate) -&gt; list[AntaCommand]:\n\"\"\"Render an AntaTemplate instance of this AntaTest using the provided\n       AntaTest.Input instance at self.inputs.\n\n    This is not an abstract method because it does not need to be implemented if there is\n    no AntaTemplate for this test.\"\"\"\n    raise NotImplementedError(f\"AntaTemplate are provided but render() method has not been implemented for {self.__module__}.{self.name}\")\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.save_commands_data","title":"save_commands_data","text":"<pre><code>save_commands_data(eos_data: list[dict[str, Any] | str]) -&gt; None\n</code></pre> <p>Populate output of all AntaCommand instances in <code>instance_commands</code></p> Source code in <code>anta/models.py</code> <pre><code>def save_commands_data(self, eos_data: list[dict[str, Any] | str]) -&gt; None:\n\"\"\"Populate output of all AntaCommand instances in `instance_commands`\"\"\"\n    if len(eos_data) != len(self.instance_commands):\n        self.result.is_error(message=\"Test initialization error: Trying to save more data than there are commands for the test\")\n        return\n    for index, data in enumerate(eos_data or []):\n        self.instance_commands[index].output = data\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.test","title":"test  <code>abstractmethod</code>","text":"<pre><code>test() -&gt; Coroutine[Any, Any, TestResult]\n</code></pre> <p>This abstract method is the core of the test logic. It must set the correct status of the <code>result</code> instance attribute with the appropriate outcome of the test.</p> <p>Examples:</p> <p>It must be implemented using the <code>AntaTest.anta_test</code> decorator:     <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n    self.result.is_success()\n    for command in self.instance_commands:\n        if not self._test_command(command): # _test_command() is an arbitrary test logic\n            self.result.is_failure(\"Failure reson\")\n</code></pre></p> Source code in <code>anta/models.py</code> <pre><code>@abstractmethod\ndef test(self) -&gt; Coroutine[Any, Any, TestResult]:\n\"\"\"\n    This abstract method is the core of the test logic.\n    It must set the correct status of the `result` instance attribute\n    with the appropriate outcome of the test.\n\n    Examples:\n    It must be implemented using the `AntaTest.anta_test` decorator:\n        ```python\n        @AntaTest.anta_test\n        def test(self) -&gt; None:\n            self.result.is_success()\n            for command in self.instance_commands:\n                if not self._test_command(command): # _test_command() is an arbitrary test logic\n                    self.result.is_failure(\"Failure reson\")\n        ```\n    \"\"\"\n</code></pre>"},{"location":"api/models/#command-definition","title":"Command definition","text":""},{"location":"api/models/#uml-diagram_1","title":"UML Diagram","text":""},{"location":"api/models/#anta.models.AntaCommand","title":"AntaCommand","text":"<p>             Bases: <code>BaseModel</code></p> <p>Class to define a command.</p> <p>Info</p> <p>eAPI models are revisioned, this means that if a model is modified in a non-backwards compatible way, then its revision will be bumped up (revisions are numbers, default value is 1).</p> <p>By default an eAPI request will return revision 1 of the model instance, this ensures that older management software will not suddenly stop working when a switch is upgraded. A revision applies to a particular CLI command whereas a version is global and is internally translated to a specific revision for each CLI command in the RPC.</p> <p>Revision has precedence over version.</p> <p>Attributes:</p> Name Type Description <code>command</code> <code>str</code> <p>Device command</p> <code>version</code> <code>Literal[1, 'latest']</code> <p>eAPI version - valid values are 1 or \u201clatest\u201d - default is \u201clatest\u201d</p> <code>revision</code> <code>Optional[conint(ge=1, le=99)]</code> <p>eAPI revision of the command. Valid values are 1 to 99. Revision has precedence over version.</p> <code>ofmt</code> <code>Literal['json', 'text']</code> <p>eAPI output - json or text - default is json</p> <code>template</code> <code>Optional[AntaTemplate]</code> <p>AntaTemplate object used to render this command</p> <code>params</code> <code>Optional[Dict[str, Any]]</code> <p>dictionary of variables with string values to render the template</p> <code>failed</code> <code>Optional[Exception]</code> <p>If the command execution fails, the Exception object is stored in this field</p>"},{"location":"api/models/#anta.models.AntaCommand.collected","title":"collected  <code>property</code>","text":"<pre><code>collected: bool\n</code></pre> <p>Return True if the command has been collected</p>"},{"location":"api/models/#anta.models.AntaCommand.json_output","title":"json_output  <code>property</code>","text":"<pre><code>json_output: dict[str, Any]\n</code></pre> <p>Get the command output as JSON</p>"},{"location":"api/models/#anta.models.AntaCommand.text_output","title":"text_output  <code>property</code>","text":"<pre><code>text_output: str\n</code></pre> <p>Get the command output as a string</p>"},{"location":"api/models/#template-definition","title":"Template definition","text":""},{"location":"api/models/#uml-diagram_2","title":"UML Diagram","text":""},{"location":"api/models/#anta.models.AntaTemplate","title":"AntaTemplate","text":"<p>             Bases: <code>BaseModel</code></p> <p>Class to define a command template as Python f-string. Can render a command from parameters.</p> <p>Attributes:</p> Name Type Description <code>template</code> <code>str</code> <p>Python f-string. Example: \u2018show vlan {vlan_id}\u2019</p> <code>version</code> <code>Literal[1, 'latest']</code> <p>eAPI version - valid values are 1 or \u201clatest\u201d - default is \u201clatest\u201d</p> <code>revision</code> <code>Optional[conint(ge=1, le=99)]</code> <p>Revision of the command. Valid values are 1 to 99. Revision has precedence over version.</p> <code>ofmt</code> <code>Literal['json', 'text']</code> <p>eAPI output - json or text - default is json</p>"},{"location":"api/models/#anta.models.AntaTemplate.render","title":"render","text":"<pre><code>render(**params: dict[str, Any]) -&gt; AntaCommand\n</code></pre> <p>Render an AntaCommand from an AntaTemplate instance. Keep the parameters used in the AntaTemplate instance.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict[str, Any]</code> <p>dictionary of variables with string values to render the Python f-string</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>command</code> <code>AntaCommand</code> <p>The rendered AntaCommand.      This AntaCommand instance have a template attribute that references this      AntaTemplate instance.</p> Source code in <code>anta/models.py</code> <pre><code>def render(self, **params: dict[str, Any]) -&gt; AntaCommand:\n\"\"\"Render an AntaCommand from an AntaTemplate instance.\n    Keep the parameters used in the AntaTemplate instance.\n\n    Args:\n        params: dictionary of variables with string values to render the Python f-string\n\n    Returns:\n        command: The rendered AntaCommand.\n                 This AntaCommand instance have a template attribute that references this\n                 AntaTemplate instance.\n    \"\"\"\n    try:\n        return AntaCommand(command=self.template.format(**params), ofmt=self.ofmt, version=self.version, revision=self.revision, template=self, params=params)\n    except KeyError as e:\n        raise AntaTemplateRenderError(self, e.args[0]) from e\n</code></pre>"},{"location":"api/report_manager/","title":"Report Manager module","text":""},{"location":"api/report_manager/#anta.reporter.ReportTable","title":"ReportTable","text":"<pre><code>ReportTable()\n</code></pre> <p>TableReport Generate a Table based on TestResult.</p> Source code in <code>anta/reporter/__init__.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"\n    __init__ Class constructor\n    \"\"\"\n    self.colors = []\n    self.colors.append(ColorManager(level=\"success\", color=RICH_COLOR_PALETTE.SUCCESS))\n    self.colors.append(ColorManager(level=\"failure\", color=RICH_COLOR_PALETTE.FAILURE))\n    self.colors.append(ColorManager(level=\"error\", color=RICH_COLOR_PALETTE.ERROR))\n    self.colors.append(ColorManager(level=\"skipped\", color=RICH_COLOR_PALETTE.SKIPPED))\n</code></pre>"},{"location":"api/report_manager/#anta.reporter.ReportTable.report_all","title":"report_all","text":"<pre><code>report_all(result_manager: ResultManager, host: Optional[str] = None, testcase: Optional[str] = None, title: str = 'All tests results') -&gt; Table\n</code></pre> <p>Create a table report with all tests for one or all devices.</p> <p>Create table with full output: Host / Test / Status / Message</p> <p>Parameters:</p> Name Type Description Default <code>result_manager</code> <code>ResultManager</code> <p>A manager with a list of tests.</p> required <code>host</code> <code>str</code> <p>IP Address of a host to search for. Defaults to None.</p> <code>None</code> <code>testcase</code> <code>str</code> <p>A test name to search for. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the report. Defaults to \u2018All tests results\u2019.</p> <code>'All tests results'</code> <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>A fully populated rich Table</p> Source code in <code>anta/reporter/__init__.py</code> <pre><code>def report_all(\n    self,\n    result_manager: ResultManager,\n    host: Optional[str] = None,\n    testcase: Optional[str] = None,\n    title: str = \"All tests results\",\n) -&gt; Table:\n\"\"\"\n    Create a table report with all tests for one or all devices.\n\n    Create table with full output: Host / Test / Status / Message\n\n    Args:\n        result_manager (ResultManager): A manager with a list of tests.\n        host (str, optional): IP Address of a host to search for. Defaults to None.\n        testcase (str, optional): A test name to search for. Defaults to None.\n        title (str, optional): Title for the report. Defaults to 'All tests results'.\n\n    Returns:\n        Table: A fully populated rich Table\n    \"\"\"\n    table = Table(title=title)\n    headers = [\"Device\", \"Test Name\", \"Test Status\", \"Message(s)\", \"Test description\", \"Test category\"]\n    table = self._build_headers(headers=headers, table=table)\n\n    for result in result_manager.get_results(output_format=\"list\"):\n        # pylint: disable=R0916\n        if (host is None and testcase is None) or (host is not None and str(result.name) == host) or (testcase is not None and testcase == str(result.test)):\n            state = self._color_result(status=str(result.result), output_type=\"str\")\n            message = self._split_list_to_txt_list(result.messages) if len(result.messages) &gt; 0 else \"\"\n            categories = \", \".join(result.categories)\n            table.add_row(str(result.name), result.test, state, message, result.description, categories)\n    return table\n</code></pre>"},{"location":"api/report_manager/#anta.reporter.ReportTable.report_summary_hosts","title":"report_summary_hosts","text":"<pre><code>report_summary_hosts(result_manager: ResultManager, host: Optional[str] = None, title: str = 'Summary per host') -&gt; Table\n</code></pre> <p>Create a table report with result agregated per host.</p> <p>Create table with full output: Host / Number of success / Number of failure / Number of error / List of nodes in error or failure</p> <p>Parameters:</p> Name Type Description Default <code>result_manager</code> <code>ResultManager</code> <p>A manager with a list of tests.</p> required <code>host</code> <code>str</code> <p>IP Address of a host to search for. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the report. Defaults to \u2018All tests results\u2019.</p> <code>'Summary per host'</code> <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>A fully populated rich Table</p> Source code in <code>anta/reporter/__init__.py</code> <pre><code>def report_summary_hosts(\n    self,\n    result_manager: ResultManager,\n    host: Optional[str] = None,\n    title: str = \"Summary per host\",\n) -&gt; Table:\n\"\"\"\n    Create a table report with result agregated per host.\n\n    Create table with full output: Host / Number of success / Number of failure / Number of error / List of nodes in error or failure\n\n    Args:\n        result_manager (ResultManager): A manager with a list of tests.\n        host (str, optional): IP Address of a host to search for. Defaults to None.\n        title (str, optional): Title for the report. Defaults to 'All tests results'.\n\n    Returns:\n        Table: A fully populated rich Table\n    \"\"\"\n    table = Table(title=title)\n    headers = [\n        \"Device\",\n        \"# of success\",\n        \"# of skipped\",\n        \"# of failure\",\n        \"# of errors\",\n        \"List of failed or error test cases\",\n    ]\n    table = self._build_headers(headers=headers, table=table)\n    for host_read in result_manager.get_hosts():\n        if host is None or str(host_read) == host:\n            results = result_manager.get_result_by_host(host_read)\n            logger.debug(\"data to use for computation\")\n            logger.debug(f\"{host}: {results}\")\n            nb_failure = len([result for result in results if result.result == \"failure\"])\n            nb_error = len([result for result in results if result.result == \"error\"])\n            list_failure = [str(result.test) for result in results if result.result in [\"failure\", \"error\"]]\n            nb_success = len([result for result in results if result.result == \"success\"])\n            nb_skipped = len([result for result in results if result.result == \"skipped\"])\n            table.add_row(\n                str(host_read),\n                str(nb_success),\n                str(nb_skipped),\n                str(nb_failure),\n                str(nb_error),\n                str(list_failure),\n            )\n    return table\n</code></pre>"},{"location":"api/report_manager/#anta.reporter.ReportTable.report_summary_tests","title":"report_summary_tests","text":"<pre><code>report_summary_tests(result_manager: ResultManager, testcase: Optional[str] = None, title: str = 'Summary per test case') -&gt; Table\n</code></pre> <p>Create a table report with result agregated per test.</p> <p>Create table with full output: Test / Number of success / Number of failure / Number of error / List of nodes in error or failure</p> <p>Parameters:</p> Name Type Description Default <code>result_manager</code> <code>ResultManager</code> <p>A manager with a list of tests.</p> required <code>testcase</code> <code>str</code> <p>A test name to search for. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the report. Defaults to \u2018All tests results\u2019.</p> <code>'Summary per test case'</code> <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>A fully populated rich Table</p> Source code in <code>anta/reporter/__init__.py</code> <pre><code>def report_summary_tests(\n    self,\n    result_manager: ResultManager,\n    testcase: Optional[str] = None,\n    title: str = \"Summary per test case\",\n) -&gt; Table:\n\"\"\"\n    Create a table report with result agregated per test.\n\n    Create table with full output: Test / Number of success / Number of failure / Number of error / List of nodes in error or failure\n\n    Args:\n        result_manager (ResultManager): A manager with a list of tests.\n        testcase (str, optional): A test name to search for. Defaults to None.\n        title (str, optional): Title for the report. Defaults to 'All tests results'.\n\n    Returns:\n        Table: A fully populated rich Table\n    \"\"\"\n    # sourcery skip: class-extract-method\n    table = Table(title=title)\n    headers = [\n        \"Test Case\",\n        \"# of success\",\n        \"# of skipped\",\n        \"# of failure\",\n        \"# of errors\",\n        \"List of failed or error nodes\",\n    ]\n    table = self._build_headers(headers=headers, table=table)\n    for testcase_read in result_manager.get_testcases():\n        if testcase is None or str(testcase_read) == testcase:\n            results = result_manager.get_result_by_test(testcase_read)\n            nb_failure = len([result for result in results if result.result == \"failure\"])\n            nb_error = len([result for result in results if result.result == \"error\"])\n            list_failure = [str(result.name) for result in results if result.result in [\"failure\", \"error\"]]\n            nb_success = len([result for result in results if result.result == \"success\"])\n            nb_skipped = len([result for result in results if result.result == \"skipped\"])\n            table.add_row(\n                testcase_read,\n                str(nb_success),\n                str(nb_skipped),\n                str(nb_failure),\n                str(nb_error),\n                str(list_failure),\n            )\n    return table\n</code></pre>"},{"location":"api/report_manager_models/","title":"Report Manager models","text":""},{"location":"api/report_manager_models/#anta.reporter.models.ColorManager","title":"ColorManager","text":"<p>             Bases: <code>BaseModel</code></p> <p>Color management for status report.</p> <p>Attributes:</p> Name Type Description <code>level</code> <code>str</code> <p>Test result value.</p> <code>color</code> <code>str</code> <p>Associated color.</p>"},{"location":"api/report_manager_models/#anta.reporter.models.ColorManager.string","title":"string","text":"<pre><code>string() -&gt; str\n</code></pre> <p>Build an str with color code</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String with level and its associated color</p> Source code in <code>anta/reporter/models.py</code> <pre><code>def string(self) -&gt; str:\n\"\"\"\n    Build an str with color code\n\n    Returns:\n        str: String with level and its associated color\n    \"\"\"\n    return f\"[{self.color}]{self.level}\"\n</code></pre>"},{"location":"api/report_manager_models/#anta.reporter.models.ColorManager.style_rich","title":"style_rich","text":"<pre><code>style_rich() -&gt; Text\n</code></pre> <p>Build a rich Text syntax with color</p> <p>Returns:</p> Name Type Description <code>Text</code> <code>Text</code> <p>object with level string and its associated color.</p> Source code in <code>anta/reporter/models.py</code> <pre><code>def style_rich(self) -&gt; Text:\n\"\"\"\n    Build a rich Text syntax with color\n\n    Returns:\n        Text: object with level string and its associated color.\n    \"\"\"\n    return Text(self.level, style=self.color)\n</code></pre>"},{"location":"api/result_manager/","title":"Result Manager module","text":""},{"location":"api/result_manager/#result-manager-definition","title":"Result Manager definition","text":""},{"location":"api/result_manager/#uml-diagram","title":"UML Diagram","text":""},{"location":"api/result_manager/#anta.result_manager.ResultManager","title":"ResultManager","text":"<pre><code>ResultManager()\n</code></pre> <p>Helper to manage Test Results and generate reports.</p> <p>Examples:</p> <pre><code>Create Inventory:\n\n    inventory_anta = AntaInventory.parse(\n        inventory_file='examples/inventory.yml',\n        username='ansible',\n        password='ansible',\n        timeout=0.5\n    )\n\nCreate Result Manager:\n\n    manager = ResultManager()\n\nRun tests for all connected devices:\n\n    for device in inventory_anta.get_inventory():\n        manager.add_test_result(\n            VerifyNTP(device=device).test()\n        )\n        manager.add_test_result(\n            VerifyEOSVersion(device=device).test(version='4.28.3M')\n        )\n\nPrint result in native format:\n\n    manager.get_results()\n    [\n        TestResult(\n            host=IPv4Address('192.168.0.10'),\n            test='VerifyNTP',\n            result='failure',\n            message=\"device is not running NTP correctly\"\n        ),\n        TestResult(\n            host=IPv4Address('192.168.0.10'),\n            test='VerifyEOSVersion',\n            result='success',\n            message=None\n        ),\n    ]\n</code></pre> <p>The status of the class is initialized to \u201cunset\u201d</p> <p>Then when adding a test with a status that is NOT \u2018error\u2019 the following table shows the updated status:</p> Current Status Added test Status Updated Status unset Any Any skipped unset, skipped skipped skipped success success skipped failure failure success unset, skipped, success success success failure failure failure unset, skipped success, failure failure <p>If the status of the added test is error, the status is untouched and the error_status is set to True.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"\n    Class constructor.\n\n    The status of the class is initialized to \"unset\"\n\n    Then when adding a test with a status that is NOT 'error' the following\n    table shows the updated status:\n\n    | Current Status |         Added test Status       | Updated Status |\n    | -------------- | ------------------------------- | -------------- |\n    |      unset     |              Any                |       Any      |\n    |     skipped    |         unset, skipped          |     skipped    |\n    |     skipped    |            success              |     success    |\n    |     skipped    |            failure              |     failure    |\n    |     success    |     unset, skipped, success     |     success    |\n    |     success    |            failure              |     failure    |\n    |     failure    | unset, skipped success, failure |     failure    |\n\n    If the status of the added test is error, the status is untouched and the\n    error_status is set to True.\n    \"\"\"\n    self._result_entries = ListResult()\n    # Initialize status\n    self.status: TestStatus = \"unset\"\n    self.error_status = False\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.add_test_result","title":"add_test_result","text":"<pre><code>add_test_result(entry: TestResult) -&gt; None\n</code></pre> <p>Add a result to the list</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>TestResult</code> <p>TestResult data to add to the report</p> required Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def add_test_result(self, entry: TestResult) -&gt; None:\n\"\"\"Add a result to the list\n\n    Args:\n        entry (TestResult): TestResult data to add to the report\n    \"\"\"\n    self._result_entries.append(entry)\n    self._update_status(entry.result)\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.add_test_results","title":"add_test_results","text":"<pre><code>add_test_results(entries: List[TestResult]) -&gt; None\n</code></pre> <p>Add a list of results to the list</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>List[TestResult]</code> <p>list of TestResult data to add to the report</p> required Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def add_test_results(self, entries: List[TestResult]) -&gt; None:\n\"\"\"Add a list of results to the list\n\n    Args:\n        entries (List[TestResult]): list of TestResult data to add to the report\n    \"\"\"\n    for e in entries:\n        self.add_test_result(e)\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_hosts","title":"get_hosts","text":"<pre><code>get_hosts() -&gt; List[str]\n</code></pre> <p>Get list of IP addresses in current manager.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of IP addresses.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_hosts(self) -&gt; List[str]:\n\"\"\"\n    Get list of IP addresses in current manager.\n\n    Returns:\n        List[str]: List of IP addresses.\n    \"\"\"\n    result_list = []\n    for testcase in self._result_entries:\n        if str(testcase.name) not in result_list:\n            result_list.append(str(testcase.name))\n    return result_list\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_result_by_host","title":"get_result_by_host","text":"<pre><code>get_result_by_host(host_ip: str, output_format: str = 'native') -&gt; Any\n</code></pre> <p>Get list of test result for a given host.</p> <p>Parameters:</p> Name Type Description Default <code>host_ip</code> <code>str</code> <p>IP Address of the host to use to filter results.</p> required <code>output_format</code> <code>str</code> <p>format selector. Can be either native/list. Defaults to \u2018native\u2019.</p> <code>'native'</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>List of results related to the host.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_result_by_host(self, host_ip: str, output_format: str = \"native\") -&gt; Any:\n\"\"\"\n    Get list of test result for a given host.\n\n    Args:\n        host_ip (str): IP Address of the host to use to filter results.\n        output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'.\n\n    Returns:\n        Any: List of results related to the host.\n    \"\"\"\n    if output_format == \"list\":\n        return [result for result in self._result_entries if str(result.name) == host_ip]\n\n    result_manager_filtered = ListResult()\n    for result in self._result_entries:\n        if str(result.name) == host_ip:\n            result_manager_filtered.append(result)\n    return result_manager_filtered\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_result_by_test","title":"get_result_by_test","text":"<pre><code>get_result_by_test(test_name: str, output_format: str = 'native') -&gt; Any\n</code></pre> <p>Get list of test result for a given test.</p> <p>Parameters:</p> Name Type Description Default <code>test_name</code> <code>str</code> <p>Test name to use to filter results</p> required <code>output_format</code> <code>str</code> <p>format selector. Can be either native/list. Defaults to \u2018native\u2019.</p> <code>'native'</code> <p>Returns:</p> Type Description <code>Any</code> <p>list[TestResult]: List of results related to the test.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_result_by_test(self, test_name: str, output_format: str = \"native\") -&gt; Any:\n\"\"\"\n    Get list of test result for a given test.\n\n    Args:\n        test_name (str): Test name to use to filter results\n        output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'.\n\n    Returns:\n        list[TestResult]: List of results related to the test.\n    \"\"\"\n    if output_format == \"list\":\n        return [result for result in self._result_entries if str(result.test) == test_name]\n\n    result_manager_filtered = ListResult()\n    for result in self._result_entries:\n        if result.test == test_name:\n            result_manager_filtered.append(result)\n    return result_manager_filtered\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_results","title":"get_results","text":"<pre><code>get_results(output_format: str = 'native') -&gt; Any\n</code></pre> <p>Expose list of all test results in different format</p> Support multiple format <ul> <li>native: ListResults format</li> <li>list: a list of TestResult</li> <li>json: a native JSON format</li> </ul> <p>Parameters:</p> Name Type Description Default <code>output_format</code> <code>str</code> <p>format selector. Can be either native/list/json. Defaults to \u2018native\u2019.</p> <code>'native'</code> <p>Returns:</p> Name Type Description <code>any</code> <code>Any</code> <p>List of results.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_results(self, output_format: str = \"native\") -&gt; Any:\n\"\"\"\n    Expose list of all test results in different format\n\n    Support multiple format:\n      - native: ListResults format\n      - list: a list of TestResult\n      - json: a native JSON format\n\n    Args:\n        output_format (str, optional): format selector. Can be either native/list/json. Defaults to 'native'.\n\n    Returns:\n        any: List of results.\n    \"\"\"\n    if output_format == \"list\":\n        return list(self._result_entries)\n\n    if output_format == \"json\":\n        return json.dumps(pydantic_to_dict(self._result_entries), indent=4)\n\n    if output_format == \"native\":\n        # Default return for native format.\n        return self._result_entries\n    raise ValueError(f\"{output_format} is not a valid value ['list', 'json', 'native']\")\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_status","title":"get_status","text":"<pre><code>get_status(ignore_error: bool = False) -&gt; str\n</code></pre> <p>Returns the current status including error_status if ignore_error is False</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_status(self, ignore_error: bool = False) -&gt; str:\n\"\"\"\n    Returns the current status including error_status if ignore_error is False\n    \"\"\"\n    return \"error\" if self.error_status and not ignore_error else self.status\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_testcases","title":"get_testcases","text":"<pre><code>get_testcases() -&gt; List[str]\n</code></pre> <p>Get list of name of all test cases in current manager.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of names for all tests.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_testcases(self) -&gt; List[str]:\n\"\"\"\n    Get list of name of all test cases in current manager.\n\n    Returns:\n        List[str]: List of names for all tests.\n    \"\"\"\n    result_list = []\n    for testcase in self._result_entries:\n        if str(testcase.test) not in result_list:\n            result_list.append(str(testcase.test))\n    return result_list\n</code></pre>"},{"location":"api/result_manager_models/","title":"Result Manager models","text":""},{"location":"api/result_manager_models/#test-result-model","title":"Test Result model","text":""},{"location":"api/result_manager_models/#uml-diagram","title":"UML Diagram","text":""},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult","title":"TestResult","text":"<p>             Bases: <code>BaseModel</code></p> <p>Describe the result of a test from a single device.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Device name where the test has run.</p> <code>test</code> <code>str</code> <p>Test name runs on the device.</p> <code>categories</code> <code>List[str]</code> <p>List of categories the TestResult belongs to, by default the AntaTest categories.</p> <code>description</code> <code>str</code> <p>TestResult description, by default the AntaTest description.</p> <code>results</code> <code>str</code> <p>Result of the test. Can be one of [\u201cunset\u201d, \u201csuccess\u201d, \u201cfailure\u201d, \u201cerror\u201d, \u201cskipped\u201d].</p> <code>message</code> <code>str</code> <p>Message to report after the test if any.</p> <code>error</code> <code>Optional[Exception]</code> <p>Exception object if the test result is \u201cerror\u201d and an Exception occured</p> <code>custom_field</code> <code>Optional[str]</code> <p>Custom field to store a string for flexibility in integrating with ANTA</p>"},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult.is_error","title":"is_error","text":"<pre><code>is_error(message: str | None = None, exception: Exception | None = None) -&gt; None\n</code></pre> <p>Helper to set status to error</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>Exception | None</code> <p>Optional Exception objet related to the error</p> <code>None</code> Source code in <code>anta/result_manager/models.py</code> <pre><code>def is_error(self, message: str | None = None, exception: Exception | None = None) -&gt; None:\n\"\"\"\n    Helper to set status to error\n\n    Args:\n        exception: Optional Exception objet related to the error\n    \"\"\"\n    self._set_status(\"error\", message)\n    self.error = exception\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult.is_failure","title":"is_failure","text":"<pre><code>is_failure(message: str | None = None) -&gt; None\n</code></pre> <p>Helper to set status to failure</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str | None</code> <p>Optional message related to the test</p> <code>None</code> Source code in <code>anta/result_manager/models.py</code> <pre><code>def is_failure(self, message: str | None = None) -&gt; None:\n\"\"\"\n    Helper to set status to failure\n\n    Args:\n        message: Optional message related to the test\n    \"\"\"\n    self._set_status(\"failure\", message)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult.is_skipped","title":"is_skipped","text":"<pre><code>is_skipped(message: str | None = None) -&gt; None\n</code></pre> <p>Helper to set status to skipped</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str | None</code> <p>Optional message related to the test</p> <code>None</code> Source code in <code>anta/result_manager/models.py</code> <pre><code>def is_skipped(self, message: str | None = None) -&gt; None:\n\"\"\"\n    Helper to set status to skipped\n\n    Args:\n        message: Optional message related to the test\n    \"\"\"\n    self._set_status(\"skipped\", message)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult.is_success","title":"is_success","text":"<pre><code>is_success(message: str | None = None) -&gt; None\n</code></pre> <p>Helper to set status to success</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str | None</code> <p>Optional message related to the test</p> <code>None</code> Source code in <code>anta/result_manager/models.py</code> <pre><code>def is_success(self, message: str | None = None) -&gt; None:\n\"\"\"\n    Helper to set status to success\n\n    Args:\n        message: Optional message related to the test\n    \"\"\"\n    self._set_status(\"success\", message)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.ListResult","title":"ListResult","text":"<p>             Bases: <code>RootModel[List[TestResult]]</code></p> <p>List result for all tests on all devices.</p> <p>Attributes:</p> Name Type Description <code>__root__</code> <code>List[TestResult]</code> <p>A list of TestResult objects.</p>"},{"location":"api/result_manager_models/#anta.result_manager.models.ListResult.append","title":"append","text":"<pre><code>append(value: TestResult) -&gt; None\n</code></pre> <p>Add support for append method.</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def append(self, value: TestResult) -&gt; None:\n\"\"\"Add support for append method.\"\"\"\n    self.root.append(value)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.ListResult.extend","title":"extend","text":"<pre><code>extend(values: List[TestResult]) -&gt; None\n</code></pre> <p>Add support for extend method.</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def extend(self, values: List[TestResult]) -&gt; None:\n\"\"\"Add support for extend method.\"\"\"\n    self.root.extend(values)\n</code></pre>"},{"location":"api/tests.aaa/","title":"AAA","text":""},{"location":"api/tests.aaa/#anta-catalog-for-interfaces-tests","title":"ANTA catalog for interfaces tests","text":"<p>Test functions related to the EOS various AAA settings</p>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAcctConsoleMethods","title":"VerifyAcctConsoleMethods","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the AAA accounting console method lists for different accounting types (system, exec, commands, dot1x).</p> Expected Results <ul> <li>success: The test will pass if the provided AAA accounting console method list is matching in the configured accounting types.</li> <li>failure: The test will fail if the provided AAA accounting console method list is NOT matching in the configured accounting types.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyAcctConsoleMethods(AntaTest):\n\"\"\"\n    Verifies the AAA accounting console method lists for different accounting types (system, exec, commands, dot1x).\n\n    Expected Results:\n        * success: The test will pass if the provided AAA accounting console method list is matching in the configured accounting types.\n        * failure: The test will fail if the provided AAA accounting console method list is NOT matching in the configured accounting types.\n    \"\"\"\n\n    name = \"VerifyAcctConsoleMethods\"\n    description = \"Verifies the AAA accounting console method lists for different accounting types (system, exec, commands, dot1x).\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show aaa methods accounting\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        methods: List[AAAAuthMethod]\n\"\"\"List of AAA accounting console methods. Methods should be in the right order\"\"\"\n        types: Set[Literal[\"commands\", \"exec\", \"system\", \"dot1x\"]]\n\"\"\"List of accounting console types to verify\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        not_matching = []\n        not_configured = []\n        for k, v in command_output.items():\n            acct_type = k.replace(\"AcctMethods\", \"\")\n            if acct_type not in self.inputs.types:\n                # We do not need to verify this accounting type\n                continue\n            for methods in v.values():\n                if \"consoleAction\" not in methods:\n                    not_configured.append(acct_type)\n                if methods[\"consoleMethods\"] != self.inputs.methods:\n                    not_matching.append(acct_type)\n        if not_configured:\n            self.result.is_failure(f\"AAA console accounting is not configured for {not_configured}\")\n            return\n        if not not_matching:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"AAA accounting console methods {self.inputs.methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAcctConsoleMethods.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/aaa.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    methods: List[AAAAuthMethod]\n\"\"\"List of AAA accounting console methods. Methods should be in the right order\"\"\"\n    types: Set[Literal[\"commands\", \"exec\", \"system\", \"dot1x\"]]\n\"\"\"List of accounting console types to verify\"\"\"\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAcctConsoleMethods.Input.methods","title":"methods  <code>instance-attribute</code>","text":"<pre><code>methods: List[AAAAuthMethod]\n</code></pre> <p>List of AAA accounting console methods. Methods should be in the right order</p>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAcctConsoleMethods.Input.types","title":"types  <code>instance-attribute</code>","text":"<pre><code>types: Set[Literal['commands', 'exec', 'system', 'dot1x']]\n</code></pre> <p>List of accounting console types to verify</p>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAcctDefaultMethods","title":"VerifyAcctDefaultMethods","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the AAA accounting default method lists for different accounting types (system, exec, commands, dot1x).</p> Expected Results <ul> <li>success: The test will pass if the provided AAA accounting default method list is matching in the configured accounting types.</li> <li>failure: The test will fail if the provided AAA accounting default method list is NOT matching in the configured accounting types.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyAcctDefaultMethods(AntaTest):\n\"\"\"\n    Verifies the AAA accounting default method lists for different accounting types (system, exec, commands, dot1x).\n\n    Expected Results:\n        * success: The test will pass if the provided AAA accounting default method list is matching in the configured accounting types.\n        * failure: The test will fail if the provided AAA accounting default method list is NOT matching in the configured accounting types.\n    \"\"\"\n\n    name = \"VerifyAcctDefaultMethods\"\n    description = \"Verifies the AAA accounting default method lists for different accounting types (system, exec, commands, dot1x).\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show aaa methods accounting\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        methods: List[AAAAuthMethod]\n\"\"\"List of AAA accounting methods. Methods should be in the right order\"\"\"\n        types: Set[Literal[\"commands\", \"exec\", \"system\", \"dot1x\"]]\n\"\"\"List of accounting types to verify\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        not_matching = []\n        not_configured = []\n        for k, v in command_output.items():\n            acct_type = k.replace(\"AcctMethods\", \"\")\n            if acct_type not in self.inputs.types:\n                # We do not need to verify this accounting type\n                continue\n            for methods in v.values():\n                if \"defaultAction\" not in methods:\n                    not_configured.append(acct_type)\n                if methods[\"defaultMethods\"] != self.inputs.methods:\n                    not_matching.append(acct_type)\n        if not_configured:\n            self.result.is_failure(f\"AAA default accounting is not configured for {not_configured}\")\n            return\n        if not not_matching:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"AAA accounting default methods {self.inputs.methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAcctDefaultMethods.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/aaa.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    methods: List[AAAAuthMethod]\n\"\"\"List of AAA accounting methods. Methods should be in the right order\"\"\"\n    types: Set[Literal[\"commands\", \"exec\", \"system\", \"dot1x\"]]\n\"\"\"List of accounting types to verify\"\"\"\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAcctDefaultMethods.Input.methods","title":"methods  <code>instance-attribute</code>","text":"<pre><code>methods: List[AAAAuthMethod]\n</code></pre> <p>List of AAA accounting methods. Methods should be in the right order</p>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAcctDefaultMethods.Input.types","title":"types  <code>instance-attribute</code>","text":"<pre><code>types: Set[Literal['commands', 'exec', 'system', 'dot1x']]\n</code></pre> <p>List of accounting types to verify</p>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAuthenMethods","title":"VerifyAuthenMethods","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the AAA authentication method lists for different authentication types (login, enable, dot1x).</p> Expected Results <ul> <li>success: The test will pass if the provided AAA authentication method list is matching in the configured authentication types.</li> <li>failure: The test will fail if the provided AAA authentication method list is NOT matching in the configured authentication types.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyAuthenMethods(AntaTest):\n\"\"\"\n    Verifies the AAA authentication method lists for different authentication types (login, enable, dot1x).\n\n    Expected Results:\n        * success: The test will pass if the provided AAA authentication method list is matching in the configured authentication types.\n        * failure: The test will fail if the provided AAA authentication method list is NOT matching in the configured authentication types.\n    \"\"\"\n\n    name = \"VerifyAuthenMethods\"\n    description = \"Verifies the AAA authentication method lists for different authentication types (login, enable, dot1x).\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show aaa methods authentication\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        methods: List[AAAAuthMethod]\n\"\"\"List of AAA authentication methods. Methods should be in the right order\"\"\"\n        types: Set[Literal[\"login\", \"enable\", \"dot1x\"]]\n\"\"\"List of authentication types to verify\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        not_matching = []\n        for k, v in command_output.items():\n            auth_type = k.replace(\"AuthenMethods\", \"\")\n            if auth_type not in self.inputs.types:\n                # We do not need to verify this accounting type\n                continue\n            if auth_type == \"login\":\n                if \"login\" not in v:\n                    self.result.is_failure(\"AAA authentication methods are not configured for login console\")\n                    return\n                if v[\"login\"][\"methods\"] != self.inputs.methods:\n                    self.result.is_failure(f\"AAA authentication methods {self.inputs.methods} are not matching for login console\")\n                    return\n            for methods in v.values():\n                if methods[\"methods\"] != self.inputs.methods:\n                    not_matching.append(auth_type)\n        if not not_matching:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"AAA authentication methods {self.inputs.methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAuthenMethods.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/aaa.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    methods: List[AAAAuthMethod]\n\"\"\"List of AAA authentication methods. Methods should be in the right order\"\"\"\n    types: Set[Literal[\"login\", \"enable\", \"dot1x\"]]\n\"\"\"List of authentication types to verify\"\"\"\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAuthenMethods.Input.methods","title":"methods  <code>instance-attribute</code>","text":"<pre><code>methods: List[AAAAuthMethod]\n</code></pre> <p>List of AAA authentication methods. Methods should be in the right order</p>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAuthenMethods.Input.types","title":"types  <code>instance-attribute</code>","text":"<pre><code>types: Set[Literal['login', 'enable', 'dot1x']]\n</code></pre> <p>List of authentication types to verify</p>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAuthzMethods","title":"VerifyAuthzMethods","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the AAA authorization method lists for different authorization types (commands, exec).</p> Expected Results <ul> <li>success: The test will pass if the provided AAA authorization method list is matching in the configured authorization types.</li> <li>failure: The test will fail if the provided AAA authorization method list is NOT matching in the configured authorization types.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyAuthzMethods(AntaTest):\n\"\"\"\n    Verifies the AAA authorization method lists for different authorization types (commands, exec).\n\n    Expected Results:\n        * success: The test will pass if the provided AAA authorization method list is matching in the configured authorization types.\n        * failure: The test will fail if the provided AAA authorization method list is NOT matching in the configured authorization types.\n    \"\"\"\n\n    name = \"VerifyAuthzMethods\"\n    description = \"Verifies the AAA authorization method lists for different authorization types (commands, exec).\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show aaa methods authorization\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        methods: List[AAAAuthMethod]\n\"\"\"List of AAA authorization methods. Methods should be in the right order\"\"\"\n        types: Set[Literal[\"commands\", \"exec\"]]\n\"\"\"List of authorization types to verify\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        not_matching = []\n        for k, v in command_output.items():\n            authz_type = k.replace(\"AuthzMethods\", \"\")\n            if authz_type not in self.inputs.types:\n                # We do not need to verify this accounting type\n                continue\n            for methods in v.values():\n                if methods[\"methods\"] != self.inputs.methods:\n                    not_matching.append(authz_type)\n        if not not_matching:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"AAA authorization methods {self.inputs.methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAuthzMethods.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/aaa.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    methods: List[AAAAuthMethod]\n\"\"\"List of AAA authorization methods. Methods should be in the right order\"\"\"\n    types: Set[Literal[\"commands\", \"exec\"]]\n\"\"\"List of authorization types to verify\"\"\"\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAuthzMethods.Input.methods","title":"methods  <code>instance-attribute</code>","text":"<pre><code>methods: List[AAAAuthMethod]\n</code></pre> <p>List of AAA authorization methods. Methods should be in the right order</p>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAuthzMethods.Input.types","title":"types  <code>instance-attribute</code>","text":"<pre><code>types: Set[Literal['commands', 'exec']]\n</code></pre> <p>List of authorization types to verify</p>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsServerGroups","title":"VerifyTacacsServerGroups","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if the provided TACACS server group(s) are configured.</p> Expected Results <ul> <li>success: The test will pass if the provided TACACS server group(s) are configured.</li> <li>failure: The test will fail if one or all the provided TACACS server group(s) are NOT configured.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyTacacsServerGroups(AntaTest):\n\"\"\"\n    Verifies if the provided TACACS server group(s) are configured.\n\n    Expected Results:\n        * success: The test will pass if the provided TACACS server group(s) are configured.\n        * failure: The test will fail if one or all the provided TACACS server group(s) are NOT configured.\n    \"\"\"\n\n    name = \"VerifyTacacsServerGroups\"\n    description = \"Verifies if the provided TACACS server group(s) are configured.\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show tacacs\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        groups: List[str]\n\"\"\"List of TACACS server group\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        tacacs_groups = command_output[\"groups\"]\n        if not tacacs_groups:\n            self.result.is_failure(\"No TACACS server group(s) are configured\")\n            return\n        not_configured = [group for group in self.inputs.groups if group not in tacacs_groups]\n        if not not_configured:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"TACACS server group(s) {not_configured} are not configured\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsServerGroups.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/aaa.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    groups: List[str]\n\"\"\"List of TACACS server group\"\"\"\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsServerGroups.Input.groups","title":"groups  <code>instance-attribute</code>","text":"<pre><code>groups: List[str]\n</code></pre> <p>List of TACACS server group</p>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsServers","title":"VerifyTacacsServers","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies TACACS servers are configured for a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the provided TACACS servers are configured in the specified VRF.</li> <li>failure: The test will fail if the provided TACACS servers are NOT configured in the specified VRF.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyTacacsServers(AntaTest):\n\"\"\"\n    Verifies TACACS servers are configured for a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the provided TACACS servers are configured in the specified VRF.\n        * failure: The test will fail if the provided TACACS servers are NOT configured in the specified VRF.\n    \"\"\"\n\n    name = \"VerifyTacacsServers\"\n    description = \"Verifies TACACS servers are configured for a specified VRF.\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show tacacs\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        servers: List[IPv4Address]\n\"\"\"List of TACACS servers\"\"\"\n        vrf: str = \"default\"\n\"\"\"The name of the VRF to transport TACACS messages\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        tacacs_servers = command_output[\"tacacsServers\"]\n        if not tacacs_servers:\n            self.result.is_failure(\"No TACACS servers are configured\")\n            return\n        not_configured = [\n            str(server)\n            for server in self.inputs.servers\n            if not any(\n                str(server) == tacacs_server[\"serverInfo\"][\"hostname\"] and self.inputs.vrf == tacacs_server[\"serverInfo\"][\"vrf\"] for tacacs_server in tacacs_servers\n            )\n        ]\n        if not not_configured:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"TACACS servers {not_configured} are not configured in VRF {self.inputs.vrf}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsServers.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/aaa.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    servers: List[IPv4Address]\n\"\"\"List of TACACS servers\"\"\"\n    vrf: str = \"default\"\n\"\"\"The name of the VRF to transport TACACS messages\"\"\"\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsServers.Input.servers","title":"servers  <code>instance-attribute</code>","text":"<pre><code>servers: List[IPv4Address]\n</code></pre> <p>List of TACACS servers</p>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsServers.Input.vrf","title":"vrf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vrf: str = 'default'\n</code></pre> <p>The name of the VRF to transport TACACS messages</p>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsSourceIntf","title":"VerifyTacacsSourceIntf","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies TACACS source-interface for a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the provided TACACS source-interface is configured in the specified VRF.</li> <li>failure: The test will fail if the provided TACACS source-interface is NOT configured in the specified VRF.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyTacacsSourceIntf(AntaTest):\n\"\"\"\n    Verifies TACACS source-interface for a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the provided TACACS source-interface is configured in the specified VRF.\n        * failure: The test will fail if the provided TACACS source-interface is NOT configured in the specified VRF.\n    \"\"\"\n\n    name = \"VerifyTacacsSourceIntf\"\n    description = \"Verifies TACACS source-interface for a specified VRF.\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show tacacs\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        intf: str\n\"\"\"Source-interface to use as source IP of TACACS messages\"\"\"\n        vrf: str = \"default\"\n\"\"\"The name of the VRF to transport TACACS messages\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        try:\n            if command_output[\"srcIntf\"][self.inputs.vrf] == self.inputs.intf:\n                self.result.is_success()\n            else:\n                self.result.is_failure(f\"Wrong source-interface configured in VRF {self.inputs.vrf}\")\n        except KeyError:\n            self.result.is_failure(f\"Source-interface {self.inputs.intf} is not configured in VRF {self.inputs.vrf}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsSourceIntf.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/aaa.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    intf: str\n\"\"\"Source-interface to use as source IP of TACACS messages\"\"\"\n    vrf: str = \"default\"\n\"\"\"The name of the VRF to transport TACACS messages\"\"\"\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsSourceIntf.Input.intf","title":"intf  <code>instance-attribute</code>","text":"<pre><code>intf: str\n</code></pre> <p>Source-interface to use as source IP of TACACS messages</p>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsSourceIntf.Input.vrf","title":"vrf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vrf: str = 'default'\n</code></pre> <p>The name of the VRF to transport TACACS messages</p>"},{"location":"api/tests.configuration/","title":"Configuration","text":""},{"location":"api/tests.configuration/#anta-catalog-for-configuration-tests","title":"ANTA catalog for configuration tests","text":"<p>Test functions related to the device configuration</p>"},{"location":"api/tests.configuration/#anta.tests.configuration.VerifyRunningConfigDiffs","title":"VerifyRunningConfigDiffs","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies there is no difference between the running-config and the startup-config</p> Source code in <code>anta/tests/configuration.py</code> <pre><code>class VerifyRunningConfigDiffs(AntaTest):\n\"\"\"\n    Verifies there is no difference between the running-config and the startup-config\n    \"\"\"\n\n    name = \"VerifyRunningConfigDiffs\"\n    description = \"Verifies there is no difference between the running-config and the startup-config\"\n    categories = [\"configuration\"]\n    commands = [AntaCommand(command=\"show running-config diffs\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].output\n        if command_output is None or command_output == \"\":\n            self.result.is_success()\n        else:\n            self.result.is_failure()\n            self.result.is_failure(str(command_output))\n</code></pre>"},{"location":"api/tests.configuration/#anta.tests.configuration.VerifyZeroTouch","title":"VerifyZeroTouch","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies ZeroTouch is disabled</p> Source code in <code>anta/tests/configuration.py</code> <pre><code>class VerifyZeroTouch(AntaTest):\n\"\"\"\n    Verifies ZeroTouch is disabled\n    \"\"\"\n\n    name = \"VerifyZeroTouch\"\n    description = \"Verifies ZeroTouch is disabled\"\n    categories = [\"configuration\"]\n    commands = [AntaCommand(command=\"show zerotouch\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].output\n        assert isinstance(command_output, dict)\n        if command_output[\"mode\"] == \"disabled\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"ZTP is NOT disabled\")\n</code></pre>"},{"location":"api/tests.connectivity/","title":"Connectivity","text":""},{"location":"api/tests.connectivity/#anta-catalog-for-connectivity-tests","title":"ANTA catalog for connectivity tests","text":"<p>Test functions related to various connectivity checks</p>"},{"location":"api/tests.connectivity/#anta.tests.connectivity.VerifyLLDPNeighbors","title":"VerifyLLDPNeighbors","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies that the provided LLDP neighbors are present and connected with the correct configuration.</p> Expected Results <ul> <li>success: The test will pass if each of the provided LLDP neighbors is present and connected to the specified port and device.</li> <li>failure: The test will fail if any of the following conditions are met:<ul> <li>The provided LLDP neighbor is not found.</li> <li>The system name or port of the LLDP neighbor does not match the provided information.</li> </ul> </li> </ul> Source code in <code>anta/tests/connectivity.py</code> <pre><code>class VerifyLLDPNeighbors(AntaTest):\n\"\"\"\n    This test verifies that the provided LLDP neighbors are present and connected with the correct configuration.\n\n    Expected Results:\n        * success: The test will pass if each of the provided LLDP neighbors is present and connected to the specified port and device.\n        * failure: The test will fail if any of the following conditions are met:\n            - The provided LLDP neighbor is not found.\n            - The system name or port of the LLDP neighbor does not match the provided information.\n    \"\"\"\n\n    name = \"VerifyLLDPNeighbors\"\n    description = \"Verifies that the provided LLDP neighbors are present and connected with the correct configuration.\"\n    categories = [\"connectivity\"]\n    commands = [AntaCommand(command=\"show lldp neighbors detail\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        neighbors: List[Neighbor]\n\"\"\"List of LLDP neighbors\"\"\"\n\n        class Neighbor(BaseModel):\n\"\"\"LLDP neighbor\"\"\"\n\n            port: Interface\n\"\"\"LLDP port\"\"\"\n            neighbor_device: str\n\"\"\"LLDP neighbor device\"\"\"\n            neighbor_port: Interface\n\"\"\"LLDP neighbor port\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n\n        self.result.is_success()\n\n        no_lldp_neighbor = []\n        wrong_lldp_neighbor = []\n\n        for neighbor in self.inputs.neighbors:\n            if len(lldp_neighbor_info := command_output[\"lldpNeighbors\"][neighbor.port][\"lldpNeighborInfo\"]) == 0:\n                no_lldp_neighbor.append(neighbor.port)\n\n            elif (\n                lldp_neighbor_info[0][\"systemName\"] != neighbor.neighbor_device\n                or lldp_neighbor_info[0][\"neighborInterfaceInfo\"][\"interfaceId_v2\"] != neighbor.neighbor_port\n            ):\n                wrong_lldp_neighbor.append(neighbor.port)\n\n        if no_lldp_neighbor:\n            self.result.is_failure(f\"The following port(s) have no LLDP neighbor: {no_lldp_neighbor}\")\n\n        if wrong_lldp_neighbor:\n            self.result.is_failure(f\"The following port(s) have the wrong LLDP neighbor: {wrong_lldp_neighbor}\")\n</code></pre>"},{"location":"api/tests.connectivity/#anta.tests.connectivity.VerifyLLDPNeighbors.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/connectivity.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    neighbors: List[Neighbor]\n\"\"\"List of LLDP neighbors\"\"\"\n\n    class Neighbor(BaseModel):\n\"\"\"LLDP neighbor\"\"\"\n\n        port: Interface\n\"\"\"LLDP port\"\"\"\n        neighbor_device: str\n\"\"\"LLDP neighbor device\"\"\"\n        neighbor_port: Interface\n\"\"\"LLDP neighbor port\"\"\"\n</code></pre>"},{"location":"api/tests.connectivity/#anta.tests.connectivity.VerifyLLDPNeighbors.Input.neighbors","title":"neighbors  <code>instance-attribute</code>","text":"<pre><code>neighbors: List[Neighbor]\n</code></pre> <p>List of LLDP neighbors</p>"},{"location":"api/tests.connectivity/#anta.tests.connectivity.VerifyLLDPNeighbors.Input.Neighbor","title":"Neighbor","text":"<p>             Bases: <code>BaseModel</code></p> <p>LLDP neighbor</p> Source code in <code>anta/tests/connectivity.py</code> <pre><code>class Neighbor(BaseModel):\n\"\"\"LLDP neighbor\"\"\"\n\n    port: Interface\n\"\"\"LLDP port\"\"\"\n    neighbor_device: str\n\"\"\"LLDP neighbor device\"\"\"\n    neighbor_port: Interface\n\"\"\"LLDP neighbor port\"\"\"\n</code></pre>"},{"location":"api/tests.connectivity/#anta.tests.connectivity.VerifyLLDPNeighbors.Input.Neighbor.neighbor_device","title":"neighbor_device  <code>instance-attribute</code>","text":"<pre><code>neighbor_device: str\n</code></pre> <p>LLDP neighbor device</p>"},{"location":"api/tests.connectivity/#anta.tests.connectivity.VerifyLLDPNeighbors.Input.Neighbor.neighbor_port","title":"neighbor_port  <code>instance-attribute</code>","text":"<pre><code>neighbor_port: Interface\n</code></pre> <p>LLDP neighbor port</p>"},{"location":"api/tests.connectivity/#anta.tests.connectivity.VerifyLLDPNeighbors.Input.Neighbor.port","title":"port  <code>instance-attribute</code>","text":"<pre><code>port: Interface\n</code></pre> <p>LLDP port</p>"},{"location":"api/tests.connectivity/#anta.tests.connectivity.VerifyReachability","title":"VerifyReachability","text":"<p>             Bases: <code>AntaTest</code></p> <p>Test network reachability to one or many destination IP(s).</p> Expected Results <ul> <li>success: The test will pass if all destination IP(s) are reachable.</li> <li>failure: The test will fail if one or many destination IP(s) are unreachable.</li> </ul> Source code in <code>anta/tests/connectivity.py</code> <pre><code>class VerifyReachability(AntaTest):\n\"\"\"\n    Test network reachability to one or many destination IP(s).\n\n    Expected Results:\n        * success: The test will pass if all destination IP(s) are reachable.\n        * failure: The test will fail if one or many destination IP(s) are unreachable.\n    \"\"\"\n\n    name = \"VerifyReachability\"\n    description = \"Test the network reachability to one or many destination IP(s).\"\n    categories = [\"connectivity\"]\n    commands = [AntaTemplate(template=\"ping vrf {vrf} {destination} source {source} repeat 2\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        hosts: List[Host]\n\"\"\"List of hosts to ping\"\"\"\n\n        class Host(BaseModel):\n\"\"\"Remote host to ping\"\"\"\n\n            destination: IPv4Address\n\"\"\"IPv4 address to ping\"\"\"\n            source: Union[IPv4Address, Interface]\n\"\"\"IPv4 address source IP or Egress interface to use\"\"\"\n            vrf: str = \"default\"\n\"\"\"VRF context\"\"\"\n\n    def render(self, template: AntaTemplate) -&gt; list[AntaCommand]:\n        return [template.render(destination=host.destination, source=host.source, vrf=host.vrf) for host in self.inputs.hosts]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        failures = []\n        for command in self.instance_commands:\n            if command.params and \"source\" in command.params and \"destination\" in command.params:\n                src, dst = command.params[\"source\"], command.params[\"destination\"]\n            if \"2 received\" not in command.json_output[\"messages\"][0]:\n                failures.append((str(src), str(dst)))\n        if not failures:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Connectivity test failed for the following source-destination pairs: {failures}\")\n</code></pre>"},{"location":"api/tests.connectivity/#anta.tests.connectivity.VerifyReachability.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/connectivity.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    hosts: List[Host]\n\"\"\"List of hosts to ping\"\"\"\n\n    class Host(BaseModel):\n\"\"\"Remote host to ping\"\"\"\n\n        destination: IPv4Address\n\"\"\"IPv4 address to ping\"\"\"\n        source: Union[IPv4Address, Interface]\n\"\"\"IPv4 address source IP or Egress interface to use\"\"\"\n        vrf: str = \"default\"\n\"\"\"VRF context\"\"\"\n</code></pre>"},{"location":"api/tests.connectivity/#anta.tests.connectivity.VerifyReachability.Input.hosts","title":"hosts  <code>instance-attribute</code>","text":"<pre><code>hosts: List[Host]\n</code></pre> <p>List of hosts to ping</p>"},{"location":"api/tests.connectivity/#anta.tests.connectivity.VerifyReachability.Input.Host","title":"Host","text":"<p>             Bases: <code>BaseModel</code></p> <p>Remote host to ping</p> Source code in <code>anta/tests/connectivity.py</code> <pre><code>class Host(BaseModel):\n\"\"\"Remote host to ping\"\"\"\n\n    destination: IPv4Address\n\"\"\"IPv4 address to ping\"\"\"\n    source: Union[IPv4Address, Interface]\n\"\"\"IPv4 address source IP or Egress interface to use\"\"\"\n    vrf: str = \"default\"\n\"\"\"VRF context\"\"\"\n</code></pre>"},{"location":"api/tests.connectivity/#anta.tests.connectivity.VerifyReachability.Input.Host.destination","title":"destination  <code>instance-attribute</code>","text":"<pre><code>destination: IPv4Address\n</code></pre> <p>IPv4 address to ping</p>"},{"location":"api/tests.connectivity/#anta.tests.connectivity.VerifyReachability.Input.Host.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: Union[IPv4Address, Interface]\n</code></pre> <p>IPv4 address source IP or Egress interface to use</p>"},{"location":"api/tests.connectivity/#anta.tests.connectivity.VerifyReachability.Input.Host.vrf","title":"vrf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vrf: str = 'default'\n</code></pre> <p>VRF context</p>"},{"location":"api/tests.field_notices/","title":"Field Notices","text":""},{"location":"api/tests.field_notices/#anta-catalog-for-field-notices-tests","title":"ANTA catalog for Field Notices tests","text":"<p>Test functions to flag field notices</p>"},{"location":"api/tests.field_notices/#anta.tests.field_notices.VerifyFieldNotice44Resolution","title":"VerifyFieldNotice44Resolution","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the device is using an Aboot version that fix the bug discussed in the field notice 44 (Aboot manages system settings prior to EOS initialization).</p> <p>https://www.arista.com/en/support/advisories-notices/field-notice/8756-field-notice-44</p> Source code in <code>anta/tests/field_notices.py</code> <pre><code>class VerifyFieldNotice44Resolution(AntaTest):\n\"\"\"\n    Verifies the device is using an Aboot version that fix the bug discussed\n    in the field notice 44 (Aboot manages system settings prior to EOS initialization).\n\n    https://www.arista.com/en/support/advisories-notices/field-notice/8756-field-notice-44\n    \"\"\"\n\n    name = \"VerifyFieldNotice44Resolution\"\n    description = (\n        \"Verifies the device is using an Aboot version that fix the bug discussed in the field notice 44 (Aboot manages system settings prior to EOS initialization)\"\n    )\n    categories = [\"field notices\", \"software\"]\n    commands = [AntaCommand(command=\"show version detail\")]\n\n    # TODO maybe implement ONLY ON PLATFORMS instead\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n\n        devices = [\n            \"DCS-7010T-48\",\n            \"DCS-7010T-48-DC\",\n            \"DCS-7050TX-48\",\n            \"DCS-7050TX-64\",\n            \"DCS-7050TX-72\",\n            \"DCS-7050TX-72Q\",\n            \"DCS-7050TX-96\",\n            \"DCS-7050TX2-128\",\n            \"DCS-7050SX-64\",\n            \"DCS-7050SX-72\",\n            \"DCS-7050SX-72Q\",\n            \"DCS-7050SX2-72Q\",\n            \"DCS-7050SX-96\",\n            \"DCS-7050SX2-128\",\n            \"DCS-7050QX-32S\",\n            \"DCS-7050QX2-32S\",\n            \"DCS-7050SX3-48YC12\",\n            \"DCS-7050CX3-32S\",\n            \"DCS-7060CX-32S\",\n            \"DCS-7060CX2-32S\",\n            \"DCS-7060SX2-48YC6\",\n            \"DCS-7160-48YC6\",\n            \"DCS-7160-48TC6\",\n            \"DCS-7160-32CQ\",\n            \"DCS-7280SE-64\",\n            \"DCS-7280SE-68\",\n            \"DCS-7280SE-72\",\n            \"DCS-7150SC-24-CLD\",\n            \"DCS-7150SC-64-CLD\",\n            \"DCS-7020TR-48\",\n            \"DCS-7020TRA-48\",\n            \"DCS-7020SR-24C2\",\n            \"DCS-7020SRG-24C2\",\n            \"DCS-7280TR-48C6\",\n            \"DCS-7280TRA-48C6\",\n            \"DCS-7280SR-48C6\",\n            \"DCS-7280SRA-48C6\",\n            \"DCS-7280SRAM-48C6\",\n            \"DCS-7280SR2K-48C6-M\",\n            \"DCS-7280SR2-48YC6\",\n            \"DCS-7280SR2A-48YC6\",\n            \"DCS-7280SRM-40CX2\",\n            \"DCS-7280QR-C36\",\n            \"DCS-7280QRA-C36S\",\n        ]\n        variants = [\"-SSD-F\", \"-SSD-R\", \"-M-F\", \"-M-R\", \"-F\", \"-R\"]\n\n        model = command_output[\"modelName\"]\n        # TODO this list could be a regex\n        for variant in variants:\n            model = model.replace(variant, \"\")\n        if model not in devices:\n            self.result.is_skipped(\"device is not impacted by FN044\")\n            return\n\n        for component in command_output[\"details\"][\"components\"]:\n            if component[\"name\"] == \"Aboot\":\n                aboot_version = component[\"version\"].split(\"-\")[2]\n        self.result.is_success()\n        if aboot_version.startswith(\"4.0.\") and int(aboot_version.split(\".\")[2]) &lt; 7:\n            self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n        elif aboot_version.startswith(\"4.1.\") and int(aboot_version.split(\".\")[2]) &lt; 1:\n            self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n        elif aboot_version.startswith(\"6.0.\") and int(aboot_version.split(\".\")[2]) &lt; 9:\n            self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n        elif aboot_version.startswith(\"6.1.\") and int(aboot_version.split(\".\")[2]) &lt; 7:\n            self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n</code></pre>"},{"location":"api/tests.field_notices/#anta.tests.field_notices.VerifyFieldNotice72Resolution","title":"VerifyFieldNotice72Resolution","text":"<p>             Bases: <code>AntaTest</code></p> <p>Checks if the device is potentially exposed to Field Notice 72, and if the issue has been mitigated.</p> <p>https://www.arista.com/en/support/advisories-notices/field-notice/17410-field-notice-0072</p> Source code in <code>anta/tests/field_notices.py</code> <pre><code>class VerifyFieldNotice72Resolution(AntaTest):\n\"\"\"\n    Checks if the device is potentially exposed to Field Notice 72, and if the issue has been mitigated.\n\n    https://www.arista.com/en/support/advisories-notices/field-notice/17410-field-notice-0072\n    \"\"\"\n\n    name = \"VerifyFieldNotice72Resolution\"\n    description = \"Verifies if the device has exposeure to FN72, and if the issue has been mitigated\"\n    categories = [\"field notices\", \"software\"]\n    commands = [AntaCommand(command=\"show version detail\")]\n\n    # TODO maybe implement ONLY ON PLATFORMS instead\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n\n        devices = [\"DCS-7280SR3-48YC8\", \"DCS-7280SR3K-48YC8\"]\n        variants = [\"-SSD-F\", \"-SSD-R\", \"-M-F\", \"-M-R\", \"-F\", \"-R\"]\n        model = command_output[\"modelName\"]\n\n        for variant in variants:\n            model = model.replace(variant, \"\")\n        if model not in devices:\n            self.result.is_skipped(\"Platform is not impacted by FN072\")\n            return\n\n        serial = command_output[\"serialNumber\"]\n        number = int(serial[3:7])\n\n        if \"JPE\" not in serial and \"JAS\" not in serial:\n            self.result.is_skipped(\"Device not exposed\")\n            return\n\n        if model == \"DCS-7280SR3-48YC8\" and \"JPE\" in serial and number &gt;= 2131:\n            self.result.is_skipped(\"Device not exposed\")\n            return\n\n        if model == \"DCS-7280SR3-48YC8\" and \"JAS\" in serial and number &gt;= 2041:\n            self.result.is_skipped(\"Device not exposed\")\n            return\n\n        if model == \"DCS-7280SR3K-48YC8\" and \"JPE\" in serial and number &gt;= 2134:\n            self.result.is_skipped(\"Device not exposed\")\n            return\n\n        if model == \"DCS-7280SR3K-48YC8\" and \"JAS\" in serial and number &gt;= 2041:\n            self.result.is_skipped(\"Device not exposed\")\n            return\n\n        # Because each of the if checks above will return if taken, we only run the long\n        # check if we get this far\n        for entry in command_output[\"details\"][\"components\"]:\n            if entry[\"name\"] == \"FixedSystemvrm1\":\n                if int(entry[\"version\"]) &lt; 7:\n                    self.result.is_failure(\"Device is exposed to FN72\")\n                else:\n                    self.result.is_success(\"FN72 is mitigated\")\n                return\n        # We should never hit this point\n        self.result.is_error(message=\"Error in running test - FixedSystemvrm1 not found\")\n        return\n</code></pre>"},{"location":"api/tests.hardware/","title":"Hardware","text":""},{"location":"api/tests.hardware/#anta-catalog-for-hardware-tests","title":"ANTA catalog for hardware tests","text":"<p>Test functions related to the hardware or environment</p>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyAdverseDrops","title":"VerifyAdverseDrops","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies if there are no adverse drops on DCS7280E and DCS7500E.</p> Expected Results <ul> <li>success: The test will pass if there are no adverse drops.</li> <li>failure: The test will fail if there are adverse drops.</li> </ul> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyAdverseDrops(AntaTest):\n\"\"\"\n    This test verifies if there are no adverse drops on DCS7280E and DCS7500E.\n\n    Expected Results:\n      * success: The test will pass if there are no adverse drops.\n      * failure: The test will fail if there are adverse drops.\n    \"\"\"\n\n    name = \"VerifyAdverseDrops\"\n    description = \"Verifies there are no adverse drops on DCS7280E and DCS7500E\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show hardware counter drop\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        total_adverse_drop = command_output[\"totalAdverseDrops\"] if \"totalAdverseDrops\" in command_output.keys() else \"\"\n        if total_adverse_drop == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device totalAdverseDrops counter is: '{total_adverse_drop}'\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentCooling","title":"VerifyEnvironmentCooling","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies the fans status.</p> Expected Results <ul> <li>success: The test will pass if the fans status are within the accepted states list.</li> <li>failure: The test will fail if some fans status is not within the accepted states list.</li> </ul> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyEnvironmentCooling(AntaTest):\n\"\"\"\n    This test verifies the fans status.\n\n    Expected Results:\n      * success: The test will pass if the fans status are within the accepted states list.\n      * failure: The test will fail if some fans status is not within the accepted states list.\n    \"\"\"\n\n    name = \"VerifyEnvironmentCooling\"\n    description = \"Verifies if the fans status are within the accepted states list.\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show system environment cooling\", ofmt=\"json\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        states: List[str]\n\"\"\"Accepted states list for fan status\"\"\"\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        self.result.is_success()\n        # First go through power supplies fans\n        for power_supply in command_output.get(\"powerSupplySlots\", []):\n            for fan in power_supply.get(\"fans\", []):\n                if (state := fan[\"status\"]) not in self.inputs.states:\n                    self.result.is_failure(f\"Fan {fan['label']} on PowerSupply {power_supply['label']} is: '{state}'\")\n        # Then go through fan trays\n        for fan_tray in command_output.get(\"fanTraySlots\", []):\n            for fan in fan_tray.get(\"fans\", []):\n                if (state := fan[\"status\"]) not in self.inputs.states:\n                    self.result.is_failure(f\"Fan {fan['label']} on Fan Tray {fan_tray['label']} is: '{state}'\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentCooling.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    states: List[str]\n\"\"\"Accepted states list for fan status\"\"\"\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentCooling.Input.states","title":"states  <code>instance-attribute</code>","text":"<pre><code>states: List[str]\n</code></pre> <p>Accepted states list for fan status</p>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentPower","title":"VerifyEnvironmentPower","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies the power supplies status.</p> Expected Results <ul> <li>success: The test will pass if the power supplies status are within the accepted states list.</li> <li>failure: The test will fail if some power supplies status is not within the accepted states list.</li> </ul> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyEnvironmentPower(AntaTest):\n\"\"\"\n    This test verifies the power supplies status.\n\n    Expected Results:\n      * success: The test will pass if the power supplies status are within the accepted states list.\n      * failure: The test will fail if some power supplies status is not within the accepted states list.\n    \"\"\"\n\n    name = \"VerifyEnvironmentPower\"\n    description = \"Verifies if the power supplies status are within the accepted states list.\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show system environment power\", ofmt=\"json\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        states: List[str]\n\"\"\"Accepted states list for power supplies status\"\"\"\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        power_supplies = command_output[\"powerSupplies\"] if \"powerSupplies\" in command_output.keys() else \"{}\"\n        wrong_power_supplies = {\n            powersupply: {\"state\": value[\"state\"]} for powersupply, value in dict(power_supplies).items() if value[\"state\"] not in self.inputs.states\n        }\n        if not wrong_power_supplies:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following power supplies status are not in the accepted states list: {wrong_power_supplies}\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentPower.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    states: List[str]\n\"\"\"Accepted states list for power supplies status\"\"\"\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentPower.Input.states","title":"states  <code>instance-attribute</code>","text":"<pre><code>states: List[str]\n</code></pre> <p>Accepted states list for power supplies status</p>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentSystemCooling","title":"VerifyEnvironmentSystemCooling","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies the device\u2019s system cooling.</p> Expected Results <ul> <li>success: The test will pass if the system cooling status is OK: \u2018coolingOk\u2019.</li> <li>failure: The test will fail if the system cooling status is NOT OK.</li> </ul> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyEnvironmentSystemCooling(AntaTest):\n\"\"\"\n    This test verifies the device's system cooling.\n\n    Expected Results:\n      * success: The test will pass if the system cooling status is OK: 'coolingOk'.\n      * failure: The test will fail if the system cooling status is NOT OK.\n    \"\"\"\n\n    name = \"VerifyEnvironmentSystemCooling\"\n    description = \"Verifies the system cooling status.\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show system environment cooling\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        sys_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n        self.result.is_success()\n        if sys_status != \"coolingOk\":\n            self.result.is_failure(f\"Device system cooling is not OK: '{sys_status}'\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTemperature","title":"VerifyTemperature","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies if the device temperature is within acceptable limits.</p> Expected Results <ul> <li>success: The test will pass if the device temperature is currently OK: \u2018temperatureOk\u2019.</li> <li>failure: The test will fail if the device temperature is NOT OK.</li> </ul> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyTemperature(AntaTest):\n\"\"\"\n    This test verifies if the device temperature is within acceptable limits.\n\n    Expected Results:\n      * success: The test will pass if the device temperature is currently OK: 'temperatureOk'.\n      * failure: The test will fail if the device temperature is NOT OK.\n    \"\"\"\n\n    name = \"VerifyTemperature\"\n    description = \"Verifies if the device temperature is within the acceptable range.\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show system environment temperature\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        temperature_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n        if temperature_status == \"temperatureOk\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device temperature exceeds acceptable limits. Current system status: '{temperature_status}'\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTransceiversManufacturers","title":"VerifyTransceiversManufacturers","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies if all the transceivers come from approved manufacturers.</p> Expected Results <ul> <li>success: The test will pass if all transceivers are from approved manufacturers.</li> <li>failure: The test will fail if some transceivers are from unapproved manufacturers.</li> </ul> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyTransceiversManufacturers(AntaTest):\n\"\"\"\n    This test verifies if all the transceivers come from approved manufacturers.\n\n    Expected Results:\n      * success: The test will pass if all transceivers are from approved manufacturers.\n      * failure: The test will fail if some transceivers are from unapproved manufacturers.\n    \"\"\"\n\n    name = \"VerifyTransceiversManufacturers\"\n    description = \"Verifies the transceiver's manufacturer against a list of approved manufacturers.\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show inventory\", ofmt=\"json\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        manufacturers: List[str]\n\"\"\"List of approved transceivers manufacturers\"\"\"\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        wrong_manufacturers = {\n            interface: value[\"mfgName\"] for interface, value in command_output[\"xcvrSlots\"].items() if value[\"mfgName\"] not in self.inputs.manufacturers\n        }\n        if not wrong_manufacturers:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Some transceivers are from unapproved manufacturers: {wrong_manufacturers}\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTransceiversManufacturers.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    manufacturers: List[str]\n\"\"\"List of approved transceivers manufacturers\"\"\"\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTransceiversManufacturers.Input.manufacturers","title":"manufacturers  <code>instance-attribute</code>","text":"<pre><code>manufacturers: List[str]\n</code></pre> <p>List of approved transceivers manufacturers</p>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTransceiversTemperature","title":"VerifyTransceiversTemperature","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies if all the transceivers are operating at an acceptable temperature.</p> Expected Results <ul> <li>success: The test will pass if all transceivers status are OK: \u2018ok\u2019.</li> <li>failure: The test will fail if some transceivers are NOT OK.</li> </ul> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyTransceiversTemperature(AntaTest):\n\"\"\"\n    This test verifies if all the transceivers are operating at an acceptable temperature.\n\n    Expected Results:\n          * success: The test will pass if all transceivers status are OK: 'ok'.\n          * failure: The test will fail if some transceivers are NOT OK.\n    \"\"\"\n\n    name = \"VerifyTransceiversTemperature\"\n    description = \"Verifies that all transceivers are operating within the acceptable temperature range.\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show system environment temperature transceiver\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        sensors = command_output[\"tempSensors\"] if \"tempSensors\" in command_output.keys() else \"\"\n        wrong_sensors = {\n            sensor[\"name\"]: {\n                \"hwStatus\": sensor[\"hwStatus\"],\n                \"alertCount\": sensor[\"alertCount\"],\n            }\n            for sensor in sensors\n            if sensor[\"hwStatus\"] != \"ok\" or sensor[\"alertCount\"] != 0\n        }\n        if not wrong_sensors:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following sensors are operating outside the acceptable temperature range or have raised alerts: {wrong_sensors}\")\n</code></pre>"},{"location":"api/tests.interfaces/","title":"Interfaces","text":""},{"location":"api/tests.interfaces/#anta-catalog-for-interfaces-tests","title":"ANTA catalog for interfaces tests","text":"<p>Test functions related to the device interfaces</p>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyIPProxyARP","title":"VerifyIPProxyARP","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if Proxy-ARP is enabled for the provided list of interface(s).</p> Expected Results <ul> <li>success: The test will pass if Proxy-ARP is enabled on the specified interface(s).</li> <li>failure: The test will fail if Proxy-ARP is disabled on the specified interface(s).</li> </ul> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyIPProxyARP(AntaTest):\n\"\"\"\n    Verifies if Proxy-ARP is enabled for the provided list of interface(s).\n\n    Expected Results:\n        * success: The test will pass if Proxy-ARP is enabled on the specified interface(s).\n        * failure: The test will fail if Proxy-ARP is disabled on the specified interface(s).\n    \"\"\"\n\n    name = \"VerifyIPProxyARP\"\n    description = \"Verifies if Proxy-ARP is enabled for the provided list of interface(s).\"\n    categories = [\"interfaces\"]\n    commands = [AntaTemplate(template=\"show ip interface {intf}\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        interfaces: List[str]\n\"\"\"List of interfaces to be tested\"\"\"\n\n    def render(self, template: AntaTemplate) -&gt; list[AntaCommand]:\n        return [template.render(intf=intf) for intf in self.inputs.interfaces]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        disabled_intf = []\n        for command in self.instance_commands:\n            if command.params and \"intf\" in command.params:\n                intf = command.params[\"intf\"]\n            if not command.json_output[\"interfaces\"][intf][\"proxyArp\"]:\n                disabled_intf.append(intf)\n        if disabled_intf:\n            self.result.is_failure(f\"The following interface(s) have Proxy-ARP disabled: {disabled_intf}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyIPProxyARP.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    interfaces: List[str]\n\"\"\"List of interfaces to be tested\"\"\"\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyIPProxyARP.Input.interfaces","title":"interfaces  <code>instance-attribute</code>","text":"<pre><code>interfaces: List[str]\n</code></pre> <p>List of interfaces to be tested</p>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyIllegalLACP","title":"VerifyIllegalLACP","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies there is no illegal LACP packets received.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyIllegalLACP(AntaTest):\n\"\"\"\n    Verifies there is no illegal LACP packets received.\n    \"\"\"\n\n    name = \"VerifyIllegalLACP\"\n    description = \"Verifies there is no illegal LACP packets received.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show lacp counters all-ports\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        po_with_illegal_lacp: list[dict[str, dict[str, int]]] = []\n        for portchannel, portchannel_dict in command_output[\"portChannels\"].items():\n            po_with_illegal_lacp.extend(\n                {portchannel: interface} for interface, interface_dict in portchannel_dict[\"interfaces\"].items() if interface_dict[\"illegalRxCount\"] != 0\n            )\n        if not po_with_illegal_lacp:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"The following port-channels have recieved illegal lacp packets on the \" f\"following ports: {po_with_illegal_lacp}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceDiscards","title":"VerifyInterfaceDiscards","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies interfaces packet discard counters are equal to zero.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyInterfaceDiscards(AntaTest):\n\"\"\"\n    Verifies interfaces packet discard counters are equal to zero.\n    \"\"\"\n\n    name = \"VerifyInterfaceDiscards\"\n    description = \"Verifies interfaces packet discard counters are equal to zero.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show interfaces counters discards\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        wrong_interfaces: list[dict[str, dict[str, int]]] = []\n        for interface, outer_v in command_output[\"interfaces\"].items():\n            wrong_interfaces.extend({interface: outer_v} for counter, value in outer_v.items() if value &gt; 0)\n        if not wrong_interfaces:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following interfaces have non 0 discard counter(s): {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceErrDisabled","title":"VerifyInterfaceErrDisabled","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies there is no interface in error disable state.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyInterfaceErrDisabled(AntaTest):\n\"\"\"\n    Verifies there is no interface in error disable state.\n    \"\"\"\n\n    name = \"VerifyInterfaceErrDisabled\"\n    description = \"Verifies there is no interface in error disable state.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show interfaces status\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        errdisabled_interfaces = [interface for interface, value in command_output[\"interfaceStatuses\"].items() if value[\"linkStatus\"] == \"errdisabled\"]\n        if errdisabled_interfaces:\n            self.result.is_failure(f\"The following interfaces are in error disabled state: {errdisabled_interfaces}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceErrors","title":"VerifyInterfaceErrors","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies that interfaces error counters are equal to zero.</p> Expected Results <ul> <li>success: The test will pass if all interfaces have error counters equal to zero.</li> <li>failure: The test will fail if one or more interfaces have non-zero error counters.</li> </ul> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyInterfaceErrors(AntaTest):\n\"\"\"\n    This test verifies that interfaces error counters are equal to zero.\n\n    Expected Results:\n        * success: The test will pass if all interfaces have error counters equal to zero.\n        * failure: The test will fail if one or more interfaces have non-zero error counters.\n    \"\"\"\n\n    name = \"VerifyInterfaceErrors\"\n    description = \"Verifies that interfaces error counters are equal to zero.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show interfaces counters errors\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        wrong_interfaces: list[dict[str, dict[str, int]]] = []\n        for interface, counters in command_output[\"interfaceErrorCounters\"].items():\n            if any(value &gt; 0 for value in counters.values()) and not any(interface in wrong_interface for wrong_interface in wrong_interfaces):\n                wrong_interfaces.append({interface: counters})\n        if not wrong_interfaces:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following interface(s) have non-zero error counters: {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceUtilization","title":"VerifyInterfaceUtilization","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies interfaces utilization is below 75%.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyInterfaceUtilization(AntaTest):\n\"\"\"\n    Verifies interfaces utilization is below 75%.\n    \"\"\"\n\n    name = \"VerifyInterfaceUtilization\"\n    description = \"Verifies interfaces utilization is below 75%.\"\n    categories = [\"interfaces\"]\n    # TODO - move from text to json if possible\n    commands = [AntaCommand(command=\"show interfaces counters rates\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].text_output\n        wrong_interfaces = {}\n        for line in command_output.split(\"\\n\")[1:]:\n            if len(line) &gt; 0:\n                if line.split()[-5] == \"-\" or line.split()[-2] == \"-\":\n                    pass\n                elif float(line.split()[-5].replace(\"%\", \"\")) &gt; 75.0:\n                    wrong_interfaces[line.split()[0]] = line.split()[-5]\n                elif float(line.split()[-2].replace(\"%\", \"\")) &gt; 75.0:\n                    wrong_interfaces[line.split()[0]] = line.split()[-2]\n        if not wrong_interfaces:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following interfaces have a usage &gt; 75%: {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfacesStatus","title":"VerifyInterfacesStatus","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies if the provided list of interfaces are all up/up.</p> Expected Results <ul> <li>success: The test will pass if the provided interfaces are all up/up.</li> <li>failure: The test will fail if one or many interfaces are not up/up.</li> </ul> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyInterfacesStatus(AntaTest):\n\"\"\"\n    This test verifies if the provided list of interfaces are all up/up.\n\n    Expected Results:\n        * success: The test will pass if the provided interfaces are all up/up.\n        * failure: The test will fail if one or many interfaces are not up/up.\n    \"\"\"\n\n    name = \"VerifyInterfacesStatus\"\n    description = \"Verifies if the provided list of interfaces are all up/up.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show interfaces description\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        interfaces: List[Interface]\n\"\"\"List of interfaces to validate\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n\n        self.result.is_success()\n\n        intf_not_configured = []\n        intf_down = []\n\n        for interface in self.inputs.interfaces:\n            intf_status = get_value(command_output[\"interfaceDescriptions\"], interface)\n            if intf_status is None:\n                intf_not_configured.append(interface)\n            elif not re.match(r\"connected|up\", intf_status[\"lineProtocolStatus\"]) and not re.match(r\"connected|up\", intf_status[\"interfaceStatus\"]):\n                intf_down.append(interface)\n\n        if intf_not_configured:\n            self.result.is_failure(f\"The following interface(s) are not configured: {intf_not_configured}\")\n\n        if intf_down:\n            self.result.is_failure(f\"The following interface(s) are not up/up: {intf_down}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfacesStatus.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    interfaces: List[Interface]\n\"\"\"List of interfaces to validate\"\"\"\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfacesStatus.Input.interfaces","title":"interfaces  <code>instance-attribute</code>","text":"<pre><code>interfaces: List[Interface]\n</code></pre> <p>List of interfaces to validate</p>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyL2MTU","title":"VerifyL2MTU","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the global layer 2 Maximum Transfer Unit (MTU) for all L2 interfaces.</p> <p>Test that L2 interfaces are configured with the correct MTU. It supports Ethernet, Port Channel and VLAN interfaces. You can define a global MTU to check and also an MTU per interface and also ignored some interfaces.</p> Expected Results <ul> <li>success: The test will pass if all layer 2 interfaces have the proper MTU configured.</li> <li>failure: The test will fail if one or many layer 2 interfaces have the wrong MTU configured.</li> </ul> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyL2MTU(AntaTest):\n\"\"\"\n    Verifies the global layer 2 Maximum Transfer Unit (MTU) for all L2 interfaces.\n\n    Test that L2 interfaces are configured with the correct MTU. It supports Ethernet, Port Channel and VLAN interfaces.\n    You can define a global MTU to check and also an MTU per interface and also ignored some interfaces.\n\n    Expected Results:\n        * success: The test will pass if all layer 2 interfaces have the proper MTU configured.\n        * failure: The test will fail if one or many layer 2 interfaces have the wrong MTU configured.\n    \"\"\"\n\n    name = \"VerifyL2MTU\"\n    description = \"Verifies the global layer 2 Maximum Transfer Unit (MTU) for all layer 2 interfaces.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show interfaces\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        mtu: int = 9214\n\"\"\"Default MTU we should have configured on all non-excluded interfaces\"\"\"\n        ignored_interfaces: List[str] = [\"Management\", \"Loopback\", \"Vxlan\", \"Tunnel\"]\n\"\"\"A list of L2 interfaces to ignore\"\"\"\n        specific_mtu: List[Dict[str, int]] = []\n\"\"\"A list of dictionary of L2 interfaces with their specific MTU configured\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        # Parameter to save incorrect interface settings\n        wrong_l2mtu_intf: list[dict[str, int]] = []\n        command_output = self.instance_commands[0].json_output\n        # Set list of interfaces with specific settings\n        specific_interfaces: list[str] = []\n        if self.inputs.specific_mtu:\n            for d in self.inputs.specific_mtu:\n                specific_interfaces.extend(d)\n        for interface, values in command_output[\"interfaces\"].items():\n            if re.findall(r\"[a-z]+\", interface, re.IGNORECASE)[0] not in self.inputs.ignored_interfaces and values[\"forwardingModel\"] == \"bridged\":\n                if interface in specific_interfaces:\n                    wrong_l2mtu_intf.extend({interface: values[\"mtu\"]} for custom_data in self.inputs.specific_mtu if values[\"mtu\"] != custom_data[interface])\n                # Comparison with generic setting\n                elif values[\"mtu\"] != self.inputs.mtu:\n                    wrong_l2mtu_intf.append({interface: values[\"mtu\"]})\n        if wrong_l2mtu_intf:\n            self.result.is_failure(f\"Some L2 interfaces do not have correct MTU configured:\\n{wrong_l2mtu_intf}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyL2MTU.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    mtu: int = 9214\n\"\"\"Default MTU we should have configured on all non-excluded interfaces\"\"\"\n    ignored_interfaces: List[str] = [\"Management\", \"Loopback\", \"Vxlan\", \"Tunnel\"]\n\"\"\"A list of L2 interfaces to ignore\"\"\"\n    specific_mtu: List[Dict[str, int]] = []\n\"\"\"A list of dictionary of L2 interfaces with their specific MTU configured\"\"\"\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyL2MTU.Input.ignored_interfaces","title":"ignored_interfaces  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignored_interfaces: List[str] = ['Management', 'Loopback', 'Vxlan', 'Tunnel']\n</code></pre> <p>A list of L2 interfaces to ignore</p>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyL2MTU.Input.mtu","title":"mtu  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mtu: int = 9214\n</code></pre> <p>Default MTU we should have configured on all non-excluded interfaces</p>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyL2MTU.Input.specific_mtu","title":"specific_mtu  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>specific_mtu: List[Dict[str, int]] = []\n</code></pre> <p>A list of dictionary of L2 interfaces with their specific MTU configured</p>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyL3MTU","title":"VerifyL3MTU","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the global layer 3 Maximum Transfer Unit (MTU) for all L3 interfaces.</p> <p>Test that L3 interfaces are configured with the correct MTU. It supports Ethernet, Port Channel and VLAN interfaces. You can define a global MTU to check and also an MTU per interface and also ignored some interfaces.</p> Expected Results <ul> <li>success: The test will pass if all layer 3 interfaces have the proper MTU configured.</li> <li>failure: The test will fail if one or many layer 3 interfaces have the wrong MTU configured.</li> </ul> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyL3MTU(AntaTest):\n\"\"\"\n    Verifies the global layer 3 Maximum Transfer Unit (MTU) for all L3 interfaces.\n\n    Test that L3 interfaces are configured with the correct MTU. It supports Ethernet, Port Channel and VLAN interfaces.\n    You can define a global MTU to check and also an MTU per interface and also ignored some interfaces.\n\n    Expected Results:\n        * success: The test will pass if all layer 3 interfaces have the proper MTU configured.\n        * failure: The test will fail if one or many layer 3 interfaces have the wrong MTU configured.\n    \"\"\"\n\n    name = \"VerifyL3MTU\"\n    description = \"Verifies the global layer 3 Maximum Transfer Unit (MTU) for all layer 3 interfaces.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show interfaces\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        mtu: int = 1500\n\"\"\"Default MTU we should have configured on all non-excluded interfaces\"\"\"\n        ignored_interfaces: List[str] = [\"Management\", \"Loopback\", \"Vxlan\", \"Tunnel\"]\n\"\"\"A list of L3 interfaces to ignore\"\"\"\n        specific_mtu: List[Dict[str, int]] = []\n\"\"\"A list of dictionary of L3 interfaces with their specific MTU configured\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        # Parameter to save incorrect interface settings\n        wrong_l3mtu_intf: list[dict[str, int]] = []\n        command_output = self.instance_commands[0].json_output\n        # Set list of interfaces with specific settings\n        specific_interfaces: list[str] = []\n        if self.inputs.specific_mtu:\n            for d in self.inputs.specific_mtu:\n                specific_interfaces.extend(d)\n        for interface, values in command_output[\"interfaces\"].items():\n            if re.findall(r\"[a-z]+\", interface, re.IGNORECASE)[0] not in self.inputs.ignored_interfaces and values[\"forwardingModel\"] == \"routed\":\n                if interface in specific_interfaces:\n                    wrong_l3mtu_intf.extend({interface: values[\"mtu\"]} for custom_data in self.inputs.specific_mtu if values[\"mtu\"] != custom_data[interface])\n                # Comparison with generic setting\n                elif values[\"mtu\"] != self.inputs.mtu:\n                    wrong_l3mtu_intf.append({interface: values[\"mtu\"]})\n        if wrong_l3mtu_intf:\n            self.result.is_failure(f\"Some interfaces do not have correct MTU configured:\\n{wrong_l3mtu_intf}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyL3MTU.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    mtu: int = 1500\n\"\"\"Default MTU we should have configured on all non-excluded interfaces\"\"\"\n    ignored_interfaces: List[str] = [\"Management\", \"Loopback\", \"Vxlan\", \"Tunnel\"]\n\"\"\"A list of L3 interfaces to ignore\"\"\"\n    specific_mtu: List[Dict[str, int]] = []\n\"\"\"A list of dictionary of L3 interfaces with their specific MTU configured\"\"\"\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyL3MTU.Input.ignored_interfaces","title":"ignored_interfaces  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignored_interfaces: List[str] = ['Management', 'Loopback', 'Vxlan', 'Tunnel']\n</code></pre> <p>A list of L3 interfaces to ignore</p>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyL3MTU.Input.mtu","title":"mtu  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mtu: int = 1500\n</code></pre> <p>Default MTU we should have configured on all non-excluded interfaces</p>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyL3MTU.Input.specific_mtu","title":"specific_mtu  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>specific_mtu: List[Dict[str, int]] = []\n</code></pre> <p>A list of dictionary of L3 interfaces with their specific MTU configured</p>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyLoopbackCount","title":"VerifyLoopbackCount","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the number of loopback interfaces on the device is the one we expect and if none of the loopback is down.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyLoopbackCount(AntaTest):\n\"\"\"\n    Verifies the number of loopback interfaces on the device is the one we expect and if none of the loopback is down.\n    \"\"\"\n\n    name = \"VerifyLoopbackCount\"\n    description = \"Verifies the number of loopback interfaces on the device is the one we expect and if none of the loopback is down.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show ip interface brief\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        number: conint(ge=0)  # type: ignore\n\"\"\"Number of loopback interfaces expected to be present\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        loopback_count = 0\n        down_loopback_interfaces = []\n        for interface in command_output[\"interfaces\"]:\n            interface_dict = command_output[\"interfaces\"][interface]\n            if \"Loopback\" in interface:\n                loopback_count += 1\n                if not (interface_dict[\"lineProtocolStatus\"] == \"up\" and interface_dict[\"interfaceStatus\"] == \"connected\"):\n                    down_loopback_interfaces.append(interface)\n        if loopback_count == self.inputs.number and len(down_loopback_interfaces) == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure()\n            if loopback_count != self.inputs.number:\n                self.result.is_failure(f\"Found {loopback_count} Loopbacks when expecting {self.inputs.number}\")\n            elif len(down_loopback_interfaces) != 0:\n                self.result.is_failure(f\"The following Loopbacks are not up: {down_loopback_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyLoopbackCount.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    number: conint(ge=0)  # type: ignore\n\"\"\"Number of loopback interfaces expected to be present\"\"\"\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyLoopbackCount.Input.number","title":"number  <code>instance-attribute</code>","text":"<pre><code>number: conint(ge=0)\n</code></pre> <p>Number of loopback interfaces expected to be present</p>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyPortChannels","title":"VerifyPortChannels","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies there is no inactive port in port channels.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyPortChannels(AntaTest):\n\"\"\"\n    Verifies there is no inactive port in port channels.\n    \"\"\"\n\n    name = \"VerifyPortChannels\"\n    description = \"Verifies there is no inactive port in port channels.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show port-channel\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        po_with_invactive_ports: list[dict[str, str]] = []\n        for portchannel, portchannel_dict in command_output[\"portChannels\"].items():\n            if len(portchannel_dict[\"inactivePorts\"]) != 0:\n                po_with_invactive_ports.extend({portchannel: portchannel_dict[\"inactivePorts\"]})\n        if not po_with_invactive_ports:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following port-channels have inactive port(s): {po_with_invactive_ports}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifySVI","title":"VerifySVI","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies there is no interface vlan down.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifySVI(AntaTest):\n\"\"\"\n    Verifies there is no interface vlan down.\n    \"\"\"\n\n    name = \"VerifySVI\"\n    description = \"Verifies there is no interface vlan down.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show ip interface brief\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        down_svis = []\n        for interface in command_output[\"interfaces\"]:\n            interface_dict = command_output[\"interfaces\"][interface]\n            if \"Vlan\" in interface:\n                if not (interface_dict[\"lineProtocolStatus\"] == \"up\" and interface_dict[\"interfaceStatus\"] == \"connected\"):\n                    down_svis.append(interface)\n        if len(down_svis) == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following SVIs are not up: {down_svis}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyStormControlDrops","title":"VerifyStormControlDrops","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the device did not drop packets due its to storm-control configuration.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyStormControlDrops(AntaTest):\n\"\"\"\n    Verifies the device did not drop packets due its to storm-control configuration.\n    \"\"\"\n\n    name = \"VerifyStormControlDrops\"\n    description = \"Verifies the device did not drop packets due its to storm-control configuration.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show storm-control\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        storm_controlled_interfaces: dict[str, dict[str, Any]] = {}\n        for interface, interface_dict in command_output[\"interfaces\"].items():\n            for traffic_type, traffic_type_dict in interface_dict[\"trafficTypes\"].items():\n                if \"drop\" in traffic_type_dict and traffic_type_dict[\"drop\"] != 0:\n                    storm_controlled_interface_dict = storm_controlled_interfaces.setdefault(interface, {})\n                    storm_controlled_interface_dict.update({traffic_type: traffic_type_dict[\"drop\"]})\n        if not storm_controlled_interfaces:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following interfaces have none 0 storm-control drop counters {storm_controlled_interfaces}\")\n</code></pre>"},{"location":"api/tests.logging/","title":"Logging","text":""},{"location":"api/tests.logging/#anta-catalog-for-logging-tests","title":"ANTA catalog for logging tests","text":"<p>Test functions related to the EOS various logging settings</p> <p>NOTE: \u2018show logging\u2019 does not support json output yet</p>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingAccounting","title":"VerifyLoggingAccounting","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if AAA accounting logs are generated.</p> Expected Results <ul> <li>success: The test will pass if AAA accounting logs are generated.</li> <li>failure: The test will fail if AAA accounting logs are NOT generated.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingAccounting(AntaTest):\n\"\"\"\n    Verifies if AAA accounting logs are generated.\n\n    Expected Results:\n        * success: The test will pass if AAA accounting logs are generated.\n        * failure: The test will fail if AAA accounting logs are NOT generated.\n    \"\"\"\n\n    name = \"VerifyLoggingAccounting\"\n    description = \"Verifies if AAA accounting logs are generated.\"\n    categories = [\"logging\"]\n    commands = [AntaCommand(command=\"show aaa accounting logs | tail\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        pattern = r\"cmd=show aaa accounting logs\"\n        output = self.instance_commands[0].text_output\n        if re.search(pattern, output):\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"AAA accounting logs are not generated\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingErrors","title":"VerifyLoggingErrors","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies there are no syslog messages with a severity of ERRORS or higher.</p> Expected Results <ul> <li>success: The test will pass if there are NO syslog messages with a severity of ERRORS or higher.</li> <li>failure: The test will fail if ERRORS or higher syslog messages are present.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingErrors(AntaTest):\n\"\"\"\n    This test verifies there are no syslog messages with a severity of ERRORS or higher.\n\n    Expected Results:\n      * success: The test will pass if there are NO syslog messages with a severity of ERRORS or higher.\n      * failure: The test will fail if ERRORS or higher syslog messages are present.\n    \"\"\"\n\n    name = \"VerifyLoggingWarning\"\n    description = \"This test verifies there are no syslog messages with a severity of ERRORS or higher.\"\n    categories = [\"logging\"]\n    commands = [AntaCommand(command=\"show logging threshold errors\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyLoggingWarning validation\n        \"\"\"\n        command_output = self.instance_commands[0].text_output\n\n        if len(command_output) == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"Device has reported syslog messages with a severity of ERRORS or higher\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingErrors.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyLoggingWarning validation</p> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyLoggingWarning validation\n    \"\"\"\n    command_output = self.instance_commands[0].text_output\n\n    if len(command_output) == 0:\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"Device has reported syslog messages with a severity of ERRORS or higher\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingHostname","title":"VerifyLoggingHostname","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if logs are generated with the device FQDN.</p> Expected Results <ul> <li>success: The test will pass if logs are generated with the device FQDN.</li> <li>failure: The test will fail if logs are NOT generated with the device FQDN.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingHostname(AntaTest):\n\"\"\"\n    Verifies if logs are generated with the device FQDN.\n\n    Expected Results:\n        * success: The test will pass if logs are generated with the device FQDN.\n        * failure: The test will fail if logs are NOT generated with the device FQDN.\n    \"\"\"\n\n    name = \"VerifyLoggingHostname\"\n    description = \"Verifies if logs are generated with the device FQDN.\"\n    categories = [\"logging\"]\n    commands = [\n        AntaCommand(command=\"show hostname\"),\n        AntaCommand(command=\"send log level informational message ANTA VerifyLoggingHostname validation\"),\n        AntaCommand(command=\"show logging informational last 30 seconds | grep ANTA\", ofmt=\"text\"),\n    ]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        output_hostname = self.instance_commands[0].json_output\n        output_logging = self.instance_commands[2].text_output\n        fqdn = output_hostname[\"fqdn\"]\n        lines = output_logging.strip().split(\"\\n\")[::-1]\n        log_pattern = r\"ANTA VerifyLoggingHostname validation\"\n        last_line_with_pattern = \"\"\n        for line in lines:\n            if re.search(log_pattern, line):\n                last_line_with_pattern = line\n                break\n        if fqdn in last_line_with_pattern:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"Logs are not generated with the device FQDN\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingHosts","title":"VerifyLoggingHosts","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies logging hosts (syslog servers) for a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the provided syslog servers are configured in the specified VRF.</li> <li>failure: The test will fail if the provided syslog servers are NOT configured in the specified VRF.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingHosts(AntaTest):\n\"\"\"\n    Verifies logging hosts (syslog servers) for a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the provided syslog servers are configured in the specified VRF.\n        * failure: The test will fail if the provided syslog servers are NOT configured in the specified VRF.\n    \"\"\"\n\n    name = \"VerifyLoggingHosts\"\n    description = \"Verifies logging hosts (syslog servers) for a specified VRF.\"\n    categories = [\"logging\"]\n    commands = [AntaCommand(command=\"show logging\", ofmt=\"text\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        hosts: List[IPv4Address]\n\"\"\"List of hosts (syslog servers) IP addresses\"\"\"\n        vrf: str = \"default\"\n\"\"\"The name of the VRF to transport log messages\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        output = self.instance_commands[0].text_output\n        not_configured = []\n        for host in self.inputs.hosts:\n            pattern = rf\"Logging to '{str(host)}'.*VRF {self.inputs.vrf}\"\n            if not re.search(pattern, _get_logging_states(self.logger, output)):\n                not_configured.append(str(host))\n\n        if not not_configured:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Syslog servers {not_configured} are not configured in VRF {self.inputs.vrf}\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingHosts.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/logging.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    hosts: List[IPv4Address]\n\"\"\"List of hosts (syslog servers) IP addresses\"\"\"\n    vrf: str = \"default\"\n\"\"\"The name of the VRF to transport log messages\"\"\"\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingHosts.Input.hosts","title":"hosts  <code>instance-attribute</code>","text":"<pre><code>hosts: List[IPv4Address]\n</code></pre> <p>List of hosts (syslog servers) IP addresses</p>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingHosts.Input.vrf","title":"vrf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vrf: str = 'default'\n</code></pre> <p>The name of the VRF to transport log messages</p>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingLogsGeneration","title":"VerifyLoggingLogsGeneration","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if logs are generated.</p> Expected Results <ul> <li>success: The test will pass if logs are generated.</li> <li>failure: The test will fail if logs are NOT generated.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingLogsGeneration(AntaTest):\n\"\"\"\n    Verifies if logs are generated.\n\n    Expected Results:\n        * success: The test will pass if logs are generated.\n        * failure: The test will fail if logs are NOT generated.\n    \"\"\"\n\n    name = \"VerifyLoggingLogsGeneration\"\n    description = \"Verifies if logs are generated.\"\n    categories = [\"logging\"]\n    commands = [\n        AntaCommand(command=\"send log level informational message ANTA VerifyLoggingLogsGeneration validation\"),\n        AntaCommand(command=\"show logging informational last 30 seconds | grep ANTA\", ofmt=\"text\"),\n    ]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        log_pattern = r\"ANTA VerifyLoggingLogsGeneration validation\"\n        output = self.instance_commands[1].text_output\n        lines = output.strip().split(\"\\n\")[::-1]\n        for line in lines:\n            if re.search(log_pattern, line):\n                self.result.is_success()\n                return\n        self.result.is_failure(\"Logs are not generated\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingPersistent","title":"VerifyLoggingPersistent","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if logging persistent is enabled and logs are saved in flash.</p> Expected Results <ul> <li>success: The test will pass if logging persistent is enabled and logs are in flash.</li> <li>failure: The test will fail if logging persistent is disabled or no logs are saved in flash.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingPersistent(AntaTest):\n\"\"\"\n    Verifies if logging persistent is enabled and logs are saved in flash.\n\n    Expected Results:\n        * success: The test will pass if logging persistent is enabled and logs are in flash.\n        * failure: The test will fail if logging persistent is disabled or no logs are saved in flash.\n    \"\"\"\n\n    name = \"VerifyLoggingPersistent\"\n    description = \"Verifies if logging persistent is enabled and logs are saved in flash.\"\n    categories = [\"logging\"]\n    commands = [\n        AntaCommand(command=\"show logging\", ofmt=\"text\"),\n        AntaCommand(command=\"dir flash:/persist/messages\", ofmt=\"text\"),\n    ]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        self.result.is_success()\n        log_output = self.instance_commands[0].text_output\n        dir_flash_output = self.instance_commands[1].text_output\n        if \"Persistent logging: disabled\" in _get_logging_states(self.logger, log_output):\n            self.result.is_failure(\"Persistent logging is disabled\")\n            return\n        pattern = r\"-rw-\\s+(\\d+)\"\n        persist_logs = re.search(pattern, dir_flash_output)\n        if not persist_logs or int(persist_logs.group(1)) == 0:\n            self.result.is_failure(\"No persistent logs are saved in flash\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingSourceIntf","title":"VerifyLoggingSourceIntf","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies logging source-interface for a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the provided logging source-interface is configured in the specified VRF.</li> <li>failure: The test will fail if the provided logging source-interface is NOT configured in the specified VRF.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingSourceIntf(AntaTest):\n\"\"\"\n    Verifies logging source-interface for a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the provided logging source-interface is configured in the specified VRF.\n        * failure: The test will fail if the provided logging source-interface is NOT configured in the specified VRF.\n    \"\"\"\n\n    name = \"VerifyLoggingSourceInt\"\n    description = \"Verifies logging source-interface for a specified VRF.\"\n    categories = [\"logging\"]\n    commands = [AntaCommand(command=\"show logging\", ofmt=\"text\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        interface: str\n\"\"\"Source-interface to use as source IP of log messages\"\"\"\n        vrf: str = \"default\"\n\"\"\"The name of the VRF to transport log messages\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        output = self.instance_commands[0].text_output\n        pattern = rf\"Logging source-interface '{self.inputs.interface}'.*VRF {self.inputs.vrf}\"\n        if re.search(pattern, _get_logging_states(self.logger, output)):\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Source-interface '{self.inputs.interface}' is not configured in VRF {self.inputs.vrf}\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingSourceIntf.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/logging.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    interface: str\n\"\"\"Source-interface to use as source IP of log messages\"\"\"\n    vrf: str = \"default\"\n\"\"\"The name of the VRF to transport log messages\"\"\"\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingSourceIntf.Input.interface","title":"interface  <code>instance-attribute</code>","text":"<pre><code>interface: str\n</code></pre> <p>Source-interface to use as source IP of log messages</p>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingSourceIntf.Input.vrf","title":"vrf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vrf: str = 'default'\n</code></pre> <p>The name of the VRF to transport log messages</p>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingTimestamp","title":"VerifyLoggingTimestamp","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if logs are generated with the approprate timestamp.</p> Expected Results <ul> <li>success: The test will pass if logs are generated with the appropriated timestamp.</li> <li>failure: The test will fail if logs are NOT generated with the appropriated timestamp.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingTimestamp(AntaTest):\n\"\"\"\n    Verifies if logs are generated with the approprate timestamp.\n\n    Expected Results:\n        * success: The test will pass if logs are generated with the appropriated timestamp.\n        * failure: The test will fail if logs are NOT generated with the appropriated timestamp.\n    \"\"\"\n\n    name = \"VerifyLoggingTimestamp\"\n    description = \"Verifies if logs are generated with the appropriate timestamp.\"\n    categories = [\"logging\"]\n    commands = [\n        AntaCommand(command=\"send log level informational message ANTA VerifyLoggingTimestamp validation\"),\n        AntaCommand(command=\"show logging informational last 30 seconds | grep ANTA\", ofmt=\"text\"),\n    ]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        log_pattern = r\"ANTA VerifyLoggingTimestamp validation\"\n        timestamp_pattern = r\"\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{6}-\\d{2}:\\d{2}\"\n        output = self.instance_commands[1].text_output\n        lines = output.strip().split(\"\\n\")[::-1]\n        last_line_with_pattern = \"\"\n        for line in lines:\n            if re.search(log_pattern, line):\n                last_line_with_pattern = line\n                break\n        if re.search(timestamp_pattern, last_line_with_pattern):\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"Logs are not generated with the appropriate timestamp format\")\n</code></pre>"},{"location":"api/tests/","title":"Overview","text":""},{"location":"api/tests/#anta-tests-landing-page","title":"ANTA Tests landing page","text":"<p>This section describes all the available tests provided by ANTA package.</p> <ul> <li>AAA</li> <li>Configuration</li> <li>Connectivity</li> <li>Field Notice</li> <li>Hardware</li> <li>Interfaces</li> <li>Logging</li> <li>MLAG</li> <li>Multicast</li> <li>Profiles</li> <li>Routing Generic</li> <li>Routing BGP</li> <li>Routing OSPF</li> <li>Security</li> <li>SNMP</li> <li>Software</li> <li>STP</li> <li>System</li> <li>VXLAN</li> </ul> <p>All these tests can be imported in a catalog to be used by the anta cli or in your own framework</p>"},{"location":"api/tests.mlag/","title":"MLAG","text":""},{"location":"api/tests.mlag/#anta-catalog-for-mlag-tests","title":"ANTA catalog for mlag tests","text":"<p>Test functions related to Multi-chassis Link Aggregation (MLAG)</p>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagConfigSanity","title":"VerifyMlagConfigSanity","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies there are no MLAG config-sanity inconsistencies.</p> Expected Results <ul> <li>success: The test will pass if there are NO MLAG config-sanity inconsistencies.</li> <li>failure: The test will fail if there are MLAG config-sanity inconsistencies.</li> <li>skipped: The test will be skipped if MLAG is \u2018disabled\u2019.</li> <li>error: The test will give an error if \u2018mlagActive\u2019 is not found in the JSON response.</li> </ul> Source code in <code>anta/tests/mlag.py</code> <pre><code>class VerifyMlagConfigSanity(AntaTest):\n\"\"\"\n    This test verifies there are no MLAG config-sanity inconsistencies.\n\n    Expected Results:\n        * success: The test will pass if there are NO MLAG config-sanity inconsistencies.\n        * failure: The test will fail if there are MLAG config-sanity inconsistencies.\n        * skipped: The test will be skipped if MLAG is 'disabled'.\n        * error: The test will give an error if 'mlagActive' is not found in the JSON response.\n    \"\"\"\n\n    name = \"VerifyMlagConfigSanity\"\n    description = \"This test verifies there are no MLAG config-sanity inconsistencies.\"\n    categories = [\"mlag\"]\n    commands = [AntaCommand(command=\"show mlag config-sanity\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        if (mlag_status := get_value(command_output, \"mlagActive\")) is None:\n            self.result.is_error(message=\"Incorrect JSON response - 'mlagActive' state was not found\")\n            return\n        if mlag_status is False:\n            self.result.is_skipped(\"MLAG is disabled\")\n            return\n        keys_to_verify = [\"globalConfiguration\", \"interfaceConfiguration\"]\n        verified_output = {key: get_value(command_output, key) for key in keys_to_verify}\n        if not any(verified_output.values()):\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"MLAG config-sanity returned inconsistencies: {verified_output}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagDualPrimary","title":"VerifyMlagDualPrimary","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies the dual-primary detection and its parameters of the MLAG configuration.</p> Expected Results <ul> <li>success: The test will pass if the dual-primary detection is enabled and its parameters are configured properly.</li> <li>failure: The test will fail if the dual-primary detection is NOT enabled or its parameters are NOT configured properly.</li> <li>skipped: The test will be skipped if MLAG is \u2018disabled\u2019.</li> </ul> Source code in <code>anta/tests/mlag.py</code> <pre><code>class VerifyMlagDualPrimary(AntaTest):\n\"\"\"\n    This test verifies the dual-primary detection and its parameters of the MLAG configuration.\n\n    Expected Results:\n        * success: The test will pass if the dual-primary detection is enabled and its parameters are configured properly.\n        * failure: The test will fail if the dual-primary detection is NOT enabled or its parameters are NOT configured properly.\n        * skipped: The test will be skipped if MLAG is 'disabled'.\n    \"\"\"\n\n    name = \"VerifyMlagDualPrimary\"\n    description = \"This test verifies the dual-primary detection and its parameters of the MLAG configuration.\"\n    categories = [\"mlag\"]\n    commands = [AntaCommand(command=\"show mlag detail\", ofmt=\"json\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        detection_delay: conint(ge=0)  # type: ignore\n\"\"\"Delay detection (seconds)\"\"\"\n        errdisabled: bool = False\n\"\"\"Errdisabled all interfaces when dual-primary is detected\"\"\"\n        recovery_delay: conint(ge=0)  # type: ignore\n\"\"\"Delay (seconds) after dual-primary detection resolves until non peer-link ports that are part of an MLAG are enabled\"\"\"\n        recovery_delay_non_mlag: conint(ge=0)  # type: ignore\n\"\"\"Delay (seconds) after dual-primary detection resolves until ports that are not part of an MLAG are enabled\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        errdisabled_action = \"errdisableAllInterfaces\" if self.inputs.errdisabled else \"none\"\n        command_output = self.instance_commands[0].json_output\n        if command_output[\"state\"] == \"disabled\":\n            self.result.is_skipped(\"MLAG is disabled\")\n            return\n        if command_output[\"dualPrimaryDetectionState\"] == \"disabled\":\n            self.result.is_failure(\"Dual-primary detection is disabled\")\n            return\n        keys_to_verify = [\"detail.dualPrimaryDetectionDelay\", \"detail.dualPrimaryAction\", \"dualPrimaryMlagRecoveryDelay\", \"dualPrimaryNonMlagRecoveryDelay\"]\n        verified_output = {key: get_value(command_output, key) for key in keys_to_verify}\n        if (\n            verified_output[\"detail.dualPrimaryDetectionDelay\"] == self.inputs.detection_delay\n            and verified_output[\"detail.dualPrimaryAction\"] == errdisabled_action\n            and verified_output[\"dualPrimaryMlagRecoveryDelay\"] == self.inputs.recovery_delay\n            and verified_output[\"dualPrimaryNonMlagRecoveryDelay\"] == self.inputs.recovery_delay_non_mlag\n        ):\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The dual-primary parameters are not configured properly: {verified_output}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagDualPrimary.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/mlag.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    detection_delay: conint(ge=0)  # type: ignore\n\"\"\"Delay detection (seconds)\"\"\"\n    errdisabled: bool = False\n\"\"\"Errdisabled all interfaces when dual-primary is detected\"\"\"\n    recovery_delay: conint(ge=0)  # type: ignore\n\"\"\"Delay (seconds) after dual-primary detection resolves until non peer-link ports that are part of an MLAG are enabled\"\"\"\n    recovery_delay_non_mlag: conint(ge=0)  # type: ignore\n\"\"\"Delay (seconds) after dual-primary detection resolves until ports that are not part of an MLAG are enabled\"\"\"\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagDualPrimary.Input.detection_delay","title":"detection_delay  <code>instance-attribute</code>","text":"<pre><code>detection_delay: conint(ge=0)\n</code></pre> <p>Delay detection (seconds)</p>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagDualPrimary.Input.errdisabled","title":"errdisabled  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>errdisabled: bool = False\n</code></pre> <p>Errdisabled all interfaces when dual-primary is detected</p>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagDualPrimary.Input.recovery_delay","title":"recovery_delay  <code>instance-attribute</code>","text":"<pre><code>recovery_delay: conint(ge=0)\n</code></pre> <p>Delay (seconds) after dual-primary detection resolves until non peer-link ports that are part of an MLAG are enabled</p>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagDualPrimary.Input.recovery_delay_non_mlag","title":"recovery_delay_non_mlag  <code>instance-attribute</code>","text":"<pre><code>recovery_delay_non_mlag: conint(ge=0)\n</code></pre> <p>Delay (seconds) after dual-primary detection resolves until ports that are not part of an MLAG are enabled</p>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagInterfaces","title":"VerifyMlagInterfaces","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies there are no inactive or active-partial MLAG ports.</p> Expected Results <ul> <li>success: The test will pass if there are NO inactive or active-partial MLAG ports.</li> <li>failure: The test will fail if there are inactive or active-partial MLAG ports.</li> <li>skipped: The test will be skipped if MLAG is \u2018disabled\u2019.</li> </ul> Source code in <code>anta/tests/mlag.py</code> <pre><code>class VerifyMlagInterfaces(AntaTest):\n\"\"\"\n    This test verifies there are no inactive or active-partial MLAG ports.\n\n    Expected Results:\n        * success: The test will pass if there are NO inactive or active-partial MLAG ports.\n        * failure: The test will fail if there are inactive or active-partial MLAG ports.\n        * skipped: The test will be skipped if MLAG is 'disabled'.\n    \"\"\"\n\n    name = \"VerifyMlagInterfaces\"\n    description = \"This test verifies there are no inactive or active-partial MLAG ports.\"\n    categories = [\"mlag\"]\n    commands = [AntaCommand(command=\"show mlag\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        if command_output[\"state\"] == \"disabled\":\n            self.result.is_skipped(\"MLAG is disabled\")\n            return\n        if command_output[\"mlagPorts\"][\"Inactive\"] == 0 and command_output[\"mlagPorts\"][\"Active-partial\"] == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"MLAG status is not OK: {command_output['mlagPorts']}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagReloadDelay","title":"VerifyMlagReloadDelay","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies the reload-delay parameters of the MLAG configuration.</p> Expected Results <ul> <li>success: The test will pass if the reload-delay parameters are configured properly.</li> <li>failure: The test will fail if the reload-delay parameters are NOT configured properly.</li> <li>skipped: The test will be skipped if MLAG is \u2018disabled\u2019.</li> </ul> Source code in <code>anta/tests/mlag.py</code> <pre><code>class VerifyMlagReloadDelay(AntaTest):\n\"\"\"\n    This test verifies the reload-delay parameters of the MLAG configuration.\n\n    Expected Results:\n        * success: The test will pass if the reload-delay parameters are configured properly.\n        * failure: The test will fail if the reload-delay parameters are NOT configured properly.\n        * skipped: The test will be skipped if MLAG is 'disabled'.\n    \"\"\"\n\n    name = \"VerifyMlagReloadDelay\"\n    description = \"This test verifies the reload-delay parameters of the MLAG configuration.\"\n    categories = [\"mlag\"]\n    commands = [AntaCommand(command=\"show mlag\", ofmt=\"json\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        reload_delay: conint(ge=0)  # type: ignore\n\"\"\"Delay (seconds) after reboot until non peer-link ports that are part of an MLAG are enabled\"\"\"\n        reload_delay_non_mlag: conint(ge=0)  # type: ignore\n\"\"\"Delay (seconds) after reboot until ports that are not part of an MLAG are enabled\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        if command_output[\"state\"] == \"disabled\":\n            self.result.is_skipped(\"MLAG is disabled\")\n            return\n        keys_to_verify = [\"reloadDelay\", \"reloadDelayNonMlag\"]\n        verified_output = {key: get_value(command_output, key) for key in keys_to_verify}\n        if verified_output[\"reloadDelay\"] == self.inputs.reload_delay and verified_output[\"reloadDelayNonMlag\"] == self.inputs.reload_delay_non_mlag:\n            self.result.is_success()\n\n        else:\n            self.result.is_failure(f\"The reload-delay parameters are not configured properly: {verified_output}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagReloadDelay.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/mlag.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    reload_delay: conint(ge=0)  # type: ignore\n\"\"\"Delay (seconds) after reboot until non peer-link ports that are part of an MLAG are enabled\"\"\"\n    reload_delay_non_mlag: conint(ge=0)  # type: ignore\n\"\"\"Delay (seconds) after reboot until ports that are not part of an MLAG are enabled\"\"\"\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagReloadDelay.Input.reload_delay","title":"reload_delay  <code>instance-attribute</code>","text":"<pre><code>reload_delay: conint(ge=0)\n</code></pre> <p>Delay (seconds) after reboot until non peer-link ports that are part of an MLAG are enabled</p>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagReloadDelay.Input.reload_delay_non_mlag","title":"reload_delay_non_mlag  <code>instance-attribute</code>","text":"<pre><code>reload_delay_non_mlag: conint(ge=0)\n</code></pre> <p>Delay (seconds) after reboot until ports that are not part of an MLAG are enabled</p>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagStatus","title":"VerifyMlagStatus","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies the health status of the MLAG configuration.</p> Expected Results <ul> <li>success: The test will pass if the MLAG state is \u2018active\u2019, negotiation status is \u2018connected\u2019,            peer-link status and local interface status are \u2018up\u2019.</li> <li>failure: The test will fail if the MLAG state is not \u2018active\u2019, negotiation status is not \u2018connected\u2019,            peer-link status or local interface status are not \u2018up\u2019.</li> <li>skipped: The test will be skipped if MLAG is \u2018disabled\u2019.</li> </ul> Source code in <code>anta/tests/mlag.py</code> <pre><code>class VerifyMlagStatus(AntaTest):\n\"\"\"\n    This test verifies the health status of the MLAG configuration.\n\n    Expected Results:\n        * success: The test will pass if the MLAG state is 'active', negotiation status is 'connected',\n                   peer-link status and local interface status are 'up'.\n        * failure: The test will fail if the MLAG state is not 'active', negotiation status is not 'connected',\n                   peer-link status or local interface status are not 'up'.\n        * skipped: The test will be skipped if MLAG is 'disabled'.\n    \"\"\"\n\n    name = \"VerifyMlagStatus\"\n    description = \"This test verifies the health status of the MLAG configuration.\"\n    categories = [\"mlag\"]\n    commands = [AntaCommand(command=\"show mlag\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        if command_output[\"state\"] == \"disabled\":\n            self.result.is_skipped(\"MLAG is disabled\")\n            return\n        keys_to_verify = [\"state\", \"negStatus\", \"localIntfStatus\", \"peerLinkStatus\"]\n        verified_output = {key: get_value(command_output, key) for key in keys_to_verify}\n        if (\n            verified_output[\"state\"] == \"active\"\n            and verified_output[\"negStatus\"] == \"connected\"\n            and verified_output[\"localIntfStatus\"] == \"up\"\n            and verified_output[\"peerLinkStatus\"] == \"up\"\n        ):\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"MLAG status is not OK: {verified_output}\")\n</code></pre>"},{"location":"api/tests.multicast/","title":"Multicast","text":""},{"location":"api/tests.multicast/#anta-catalog-for-multicast-tests","title":"ANTA catalog for multicast tests","text":"<p>Test functions related to multicast</p>"},{"location":"api/tests.multicast/#anta.tests.multicast.VerifyIGMPSnoopingGlobal","title":"VerifyIGMPSnoopingGlobal","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the IGMP snooping global configuration.</p> Source code in <code>anta/tests/multicast.py</code> <pre><code>class VerifyIGMPSnoopingGlobal(AntaTest):\n\"\"\"\n    Verifies the IGMP snooping global configuration.\n    \"\"\"\n\n    name = \"VerifyIGMPSnoopingGlobal\"\n    description = \"Verifies the IGMP snooping global configuration.\"\n    categories = [\"multicast\", \"igmp\"]\n    commands = [AntaCommand(command=\"show ip igmp snooping\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        enabled: bool\n\"\"\"Expected global IGMP snooping configuration (True=enabled, False=disabled)\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        self.result.is_success()\n        igmp_state = command_output[\"igmpSnoopingState\"]\n        if igmp_state != \"enabled\" if self.inputs.enabled else igmp_state != \"disabled\":\n            self.result.is_failure(f\"IGMP state is not valid: {igmp_state}\")\n</code></pre>"},{"location":"api/tests.multicast/#anta.tests.multicast.VerifyIGMPSnoopingGlobal.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/multicast.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    enabled: bool\n\"\"\"Expected global IGMP snooping configuration (True=enabled, False=disabled)\"\"\"\n</code></pre>"},{"location":"api/tests.multicast/#anta.tests.multicast.VerifyIGMPSnoopingGlobal.Input.enabled","title":"enabled  <code>instance-attribute</code>","text":"<pre><code>enabled: bool\n</code></pre> <p>Expected global IGMP snooping configuration (True=enabled, False=disabled)</p>"},{"location":"api/tests.multicast/#anta.tests.multicast.VerifyIGMPSnoopingVlans","title":"VerifyIGMPSnoopingVlans","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the IGMP snooping configuration for some VLANs.</p> Source code in <code>anta/tests/multicast.py</code> <pre><code>class VerifyIGMPSnoopingVlans(AntaTest):\n\"\"\"\n    Verifies the IGMP snooping configuration for some VLANs.\n    \"\"\"\n\n    name = \"VerifyIGMPSnoopingVlans\"\n    description = \"Verifies the IGMP snooping configuration for some VLANs.\"\n    categories = [\"multicast\", \"igmp\"]\n    commands = [AntaCommand(command=\"show ip igmp snooping\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        vlans: Dict[Vlan, bool]\n\"\"\"Dictionary of VLANs with associated IGMP configuration status (True=enabled, False=disabled)\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        self.result.is_success()\n        for vlan, enabled in self.inputs.vlans.items():\n            if str(vlan) not in command_output[\"vlans\"]:\n                self.result.is_failure(f\"Supplied vlan {vlan} is not present on the device.\")\n                continue\n\n            igmp_state = command_output[\"vlans\"][str(vlan)][\"igmpSnoopingState\"]\n            if igmp_state != \"enabled\" if enabled else igmp_state != \"disabled\":\n                self.result.is_failure(f\"IGMP state for vlan {vlan} is {igmp_state}\")\n</code></pre>"},{"location":"api/tests.multicast/#anta.tests.multicast.VerifyIGMPSnoopingVlans.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/multicast.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    vlans: Dict[Vlan, bool]\n\"\"\"Dictionary of VLANs with associated IGMP configuration status (True=enabled, False=disabled)\"\"\"\n</code></pre>"},{"location":"api/tests.multicast/#anta.tests.multicast.VerifyIGMPSnoopingVlans.Input.vlans","title":"vlans  <code>instance-attribute</code>","text":"<pre><code>vlans: Dict[Vlan, bool]\n</code></pre> <p>Dictionary of VLANs with associated IGMP configuration status (True=enabled, False=disabled)</p>"},{"location":"api/tests.profiles/","title":"Profiles","text":""},{"location":"api/tests.profiles/#anta-catalog-for-profiles-tests","title":"ANTA catalog for profiles tests","text":"<p>Test functions related to ASIC profiles</p>"},{"location":"api/tests.profiles/#anta.tests.profiles.VerifyTcamProfile","title":"VerifyTcamProfile","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the device is using the configured TCAM profile.</p> Source code in <code>anta/tests/profiles.py</code> <pre><code>class VerifyTcamProfile(AntaTest):\n\"\"\"\n    Verifies the device is using the configured TCAM profile.\n    \"\"\"\n\n    name = \"VerifyTcamProfile\"\n    description = \"Verify that the assigned TCAM profile is actually running on the device\"\n    categories = [\"profiles\"]\n    commands = [AntaCommand(command=\"show hardware tcam profile\", ofmt=\"json\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        profile: str\n\"\"\"Expected TCAM profile\"\"\"\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        if command_output[\"pmfProfiles\"][\"FixedSystem\"][\"status\"] == command_output[\"pmfProfiles\"][\"FixedSystem\"][\"config\"] == self.inputs.profile:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Incorrect profile running on device: {command_output['pmfProfiles']['FixedSystem']['status']}\")\n</code></pre>"},{"location":"api/tests.profiles/#anta.tests.profiles.VerifyTcamProfile.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/profiles.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    profile: str\n\"\"\"Expected TCAM profile\"\"\"\n</code></pre>"},{"location":"api/tests.profiles/#anta.tests.profiles.VerifyTcamProfile.Input.profile","title":"profile  <code>instance-attribute</code>","text":"<pre><code>profile: str\n</code></pre> <p>Expected TCAM profile</p>"},{"location":"api/tests.profiles/#anta.tests.profiles.VerifyUnifiedForwardingTableMode","title":"VerifyUnifiedForwardingTableMode","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the device is using the expected Unified Forwarding Table mode.</p> Source code in <code>anta/tests/profiles.py</code> <pre><code>class VerifyUnifiedForwardingTableMode(AntaTest):\n\"\"\"\n    Verifies the device is using the expected Unified Forwarding Table mode.\n    \"\"\"\n\n    name = \"VerifyUnifiedForwardingTableMode\"\n    description = \"\"\n    categories = [\"profiles\"]\n    commands = [AntaCommand(command=\"show platform trident forwarding-table partition\", ofmt=\"json\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        mode: Literal[0, 1, 2, 3, 4, \"flexible\"]\n\"\"\"Expected UFT mode\"\"\"\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        if command_output[\"uftMode\"] == str(self.inputs.mode):\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device is not running correct UFT mode (expected: {self.inputs.mode} / running: {command_output['uftMode']})\")\n</code></pre>"},{"location":"api/tests.profiles/#anta.tests.profiles.VerifyUnifiedForwardingTableMode.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/profiles.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    mode: Literal[0, 1, 2, 3, 4, \"flexible\"]\n\"\"\"Expected UFT mode\"\"\"\n</code></pre>"},{"location":"api/tests.profiles/#anta.tests.profiles.VerifyUnifiedForwardingTableMode.Input.mode","title":"mode  <code>instance-attribute</code>","text":"<pre><code>mode: Literal[0, 1, 2, 3, 4, 'flexible']\n</code></pre> <p>Expected UFT mode</p>"},{"location":"api/tests.routing.bgp/","title":"BGP","text":""},{"location":"api/tests.routing.bgp/#anta-catalog-for-routing-bgp-tests","title":"ANTA catalog for routing-bgp tests","text":"<p>BGP test functions</p>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPEVPNCount","title":"VerifyBGPEVPNCount","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies all EVPN BGP sessions are established (default VRF) and the actual number of BGP EVPN neighbors is the one we expect (default VRF).</p> <ul> <li>self.result = \u201csuccess\u201d if all EVPN BGP sessions are Established and if the actual                      number of BGP EVPN neighbors is the one we expect.</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPEVPNCount(AntaTest):\n\"\"\"\n    Verifies all EVPN BGP sessions are established (default VRF)\n    and the actual number of BGP EVPN neighbors is the one we expect (default VRF).\n\n    * self.result = \"success\" if all EVPN BGP sessions are Established and if the actual\n                         number of BGP EVPN neighbors is the one we expect.\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPEVPNCount\"\n    description = \"Verifies all EVPN BGP sessions are established (default VRF) and the actual number of BGP EVPN neighbors is the one we expect (default VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaCommand(command=\"show bgp evpn summary\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        number: int\n\"\"\"The expected number of BGP EVPN neighbors in the default VRF\"\"\"\n\n    @check_bgp_family_enable(\"evpn\")\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        peers = command_output[\"vrfs\"][\"default\"][\"peers\"]\n        non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n        if not non_established_peers and len(peers) == self.inputs.number:\n            self.result.is_success()\n        else:\n            self.result.is_failure()\n            if len(peers) != self.inputs.number:\n                self.result.is_failure(f\"Expecting {self.inputs.number} BGP EVPN peers and got {len(peers)}\")\n            if non_established_peers:\n                self.result.is_failure(f\"The following EVPN peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPEVPNCount.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    number: int\n\"\"\"The expected number of BGP EVPN neighbors in the default VRF\"\"\"\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPEVPNCount.Input.number","title":"number  <code>instance-attribute</code>","text":"<pre><code>number: int\n</code></pre> <p>The expected number of BGP EVPN neighbors in the default VRF</p>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPEVPNState","title":"VerifyBGPEVPNState","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies all EVPN BGP sessions are established (default VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if no BGP EVPN peers are returned by the device</li> <li>self.result = \u201csuccess\u201d if all EVPN BGP sessions are established.</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPEVPNState(AntaTest):\n\"\"\"\n    Verifies all EVPN BGP sessions are established (default VRF).\n\n    * self.result = \"skipped\" if no BGP EVPN peers are returned by the device\n    * self.result = \"success\" if all EVPN BGP sessions are established.\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPEVPNState\"\n    description = \"Verifies all EVPN BGP sessions are established (default VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaCommand(command=\"show bgp evpn summary\")]\n\n    @check_bgp_family_enable(\"evpn\")\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        bgp_vrfs = command_output[\"vrfs\"]\n        peers = bgp_vrfs[\"default\"][\"peers\"]\n        non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n        if not non_established_peers:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following EVPN peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv4UnicastCount","title":"VerifyBGPIPv4UnicastCount","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies all IPv4 unicast BGP sessions are established and all BGP messages queues for these sessions are empty and the actual number of BGP IPv4 unicast neighbors is the one we expect in all VRFs specified as input.</p> <ul> <li>self.result = \u201csuccess\u201d if all IPv4 unicast BGP sessions are established                      and if all BGP messages queues for these sessions are empty                      and if the actual number of BGP IPv4 unicast neighbors is equal to `number                      in all VRFs specified as input.</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPIPv4UnicastCount(AntaTest):\n\"\"\"\n    Verifies all IPv4 unicast BGP sessions are established\n    and all BGP messages queues for these sessions are empty\n    and the actual number of BGP IPv4 unicast neighbors is the one we expect\n    in all VRFs specified as input.\n\n    * self.result = \"success\" if all IPv4 unicast BGP sessions are established\n                         and if all BGP messages queues for these sessions are empty\n                         and if the actual number of BGP IPv4 unicast neighbors is equal to `number\n                         in all VRFs specified as input.\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPIPv4UnicastCount\"\n    description = (\n        \"Verifies all IPv4 unicast BGP sessions are established and all their BGP messages queues are empty and \"\n        \" the actual number of BGP IPv4 unicast neighbors is the one we expect.\"\n    )\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaTemplate(template=\"show bgp ipv4 unicast summary vrf {vrf}\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        vrfs: Dict[str, int]\n\"\"\"VRFs associated with neighbors count to verify\"\"\"\n\n    def render(self, template: AntaTemplate) -&gt; list[AntaCommand]:\n        return [template.render(vrf=vrf) for vrf in self.inputs.vrfs]\n\n    @check_bgp_family_enable(\"ipv4\")\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        self.result.is_success()\n        for command in self.instance_commands:\n            if command.params and \"vrf\" in command.params:\n                vrf = command.params[\"vrf\"]\n                count = self.inputs.vrfs[vrf]\n                if vrf not in command.json_output[\"vrfs\"]:\n                    self.result.is_failure(f\"VRF {vrf} is not configured\")\n                    return\n                peers = command.json_output[\"vrfs\"][vrf][\"peers\"]\n                state_issue = _check_bgp_vrfs(command.json_output[\"vrfs\"])\n                if len(peers) != count:\n                    self.result.is_failure(f\"Expecting {count} BGP peer(s) in vrf {vrf} but got {len(peers)} peer(s)\")\n                if state_issue:\n                    self.result.is_failure(f\"The following IPv4 peer(s) are not established: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv4UnicastCount.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    vrfs: Dict[str, int]\n\"\"\"VRFs associated with neighbors count to verify\"\"\"\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv4UnicastCount.Input.vrfs","title":"vrfs  <code>instance-attribute</code>","text":"<pre><code>vrfs: Dict[str, int]\n</code></pre> <p>VRFs associated with neighbors count to verify</p>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv4UnicastState","title":"VerifyBGPIPv4UnicastState","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if no BGP vrf are returned by the device</li> <li>self.result = \u201csuccess\u201d if all IPv4 unicast BGP sessions are established (for all VRF)                      and all BGP messages queues for these sessions are empty (for all VRF).</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPIPv4UnicastState(AntaTest):\n\"\"\"\n    Verifies all IPv4 unicast BGP sessions are established (for all VRF)\n    and all BGP messages queues for these sessions are empty (for all VRF).\n\n    * self.result = \"skipped\" if no BGP vrf are returned by the device\n    * self.result = \"success\" if all IPv4 unicast BGP sessions are established (for all VRF)\n                         and all BGP messages queues for these sessions are empty (for all VRF).\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPIPv4UnicastState\"\n    description = \"Verifies all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaCommand(command=\"show bgp ipv4 unicast summary vrf all\")]\n\n    @check_bgp_family_enable(\"ipv4\")\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        state_issue = _check_bgp_vrfs(command_output[\"vrfs\"])\n        if not state_issue:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Some IPv4 Unicast BGP Peer are not up: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv6UnicastState","title":"VerifyBGPIPv6UnicastState","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if no BGP vrf are returned by the device</li> <li>self.result = \u201csuccess\u201d if all IPv6 unicast BGP sessions are established (for all VRF)                      and all BGP messages queues for these sessions are empty (for all VRF).</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPIPv6UnicastState(AntaTest):\n\"\"\"\n    Verifies all IPv6 unicast BGP sessions are established (for all VRF)\n    and all BGP messages queues for these sessions are empty (for all VRF).\n\n    * self.result = \"skipped\" if no BGP vrf are returned by the device\n    * self.result = \"success\" if all IPv6 unicast BGP sessions are established (for all VRF)\n                         and all BGP messages queues for these sessions are empty (for all VRF).\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPIPv6UnicastState\"\n    description = \"Verifies all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaCommand(command=\"show bgp ipv6 unicast summary vrf all\")]\n\n    @check_bgp_family_enable(\"ipv6\")\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        state_issue = _check_bgp_vrfs(command_output[\"vrfs\"])\n        if not state_issue:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Some IPv4 Unicast BGP Peer are not up: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPRTCCount","title":"VerifyBGPRTCCount","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies all RTC BGP sessions are established (default VRF) and the actual number of BGP RTC neighbors is the one we expect (default VRF).</p> <ul> <li>self.result = \u201csuccess\u201d if all RTC BGP sessions are Established and if the actual                      number of BGP RTC neighbors is the one we expect.</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPRTCCount(AntaTest):\n\"\"\"\n    Verifies all RTC BGP sessions are established (default VRF)\n    and the actual number of BGP RTC neighbors is the one we expect (default VRF).\n\n    * self.result = \"success\" if all RTC BGP sessions are Established and if the actual\n                         number of BGP RTC neighbors is the one we expect.\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPRTCCount\"\n    description = \"Verifies all RTC BGP sessions are established (default VRF) and the actual number of BGP RTC neighbors is the one we expect (default VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaCommand(command=\"show bgp rt-membership summary\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        number: int\n\"\"\"The expected number of BGP RTC neighbors in the default VRF\"\"\"\n\n    @check_bgp_family_enable(\"rtc\")\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        peers = command_output[\"vrfs\"][\"default\"][\"peers\"]\n        non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n        if not non_established_peers and len(peers) == self.inputs.number:\n            self.result.is_success()\n        else:\n            self.result.is_failure()\n            if len(peers) != self.inputs.number:\n                self.result.is_failure(f\"Expecting {self.inputs.number} BGP RTC peers and got {len(peers)}\")\n            if non_established_peers:\n                self.result.is_failure(f\"The following RTC peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPRTCCount.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    number: int\n\"\"\"The expected number of BGP RTC neighbors in the default VRF\"\"\"\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPRTCCount.Input.number","title":"number  <code>instance-attribute</code>","text":"<pre><code>number: int\n</code></pre> <p>The expected number of BGP RTC neighbors in the default VRF</p>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPRTCState","title":"VerifyBGPRTCState","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies all RTC BGP sessions are established (default VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if no BGP RTC peers are returned by the device</li> <li>self.result = \u201csuccess\u201d if all RTC BGP sessions are established.</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPRTCState(AntaTest):\n\"\"\"\n    Verifies all RTC BGP sessions are established (default VRF).\n\n    * self.result = \"skipped\" if no BGP RTC peers are returned by the device\n    * self.result = \"success\" if all RTC BGP sessions are established.\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPRTCState\"\n    description = \"Verifies all RTC BGP sessions are established (default VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaCommand(command=\"show bgp rt-membership summary\")]\n\n    @check_bgp_family_enable(\"rtc\")\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        bgp_vrfs = command_output[\"vrfs\"]\n        peers = bgp_vrfs[\"default\"][\"peers\"]\n        non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n        if not non_established_peers:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following RTC peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.generic/","title":"Generic","text":""},{"location":"api/tests.routing.generic/#anta-catalog-for-routing-generic-tests","title":"ANTA catalog for routing-generic tests","text":"<p>Generic routing test functions</p>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyBFD","title":"VerifyBFD","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies there is no BFD peer in down state (all VRF, IPv4 neighbors).</p> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>class VerifyBFD(AntaTest):\n\"\"\"\n    Verifies there is no BFD peer in down state (all VRF, IPv4 neighbors).\n    \"\"\"\n\n    name = \"VerifyBFD\"\n    description = \"Verifies there is no BFD peer in down state (all VRF, IPv4 neighbors).\"\n    categories = [\"routing\", \"generic\"]\n    # revision 1 as later revision introduce additional nesting for type\n    commands = [AntaCommand(command=\"show bfd peers\", revision=1)]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        self.result.is_success()\n        for _, vrf_data in command_output[\"vrfs\"].items():\n            for _, neighbor_data in vrf_data[\"ipv4Neighbors\"].items():\n                for peer, peer_data in neighbor_data[\"peerStats\"].items():\n                    if (peer_status := peer_data[\"status\"]) != \"up\":\n                        failure_message = f\"bfd state for peer '{peer}' is {peer_status} (expected up).\"\n                        if (peer_l3intf := peer_data.get(\"l3intf\")) is not None and peer_l3intf != \"\":\n                            failure_message += f\" Interface: {peer_l3intf}.\"\n                        self.result.is_failure(failure_message)\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingProtocolModel","title":"VerifyRoutingProtocolModel","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the configured routing protocol model is the one we expect. And if there is no mismatch between the configured and operating routing protocol model.</p> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>class VerifyRoutingProtocolModel(AntaTest):\n\"\"\"\n    Verifies the configured routing protocol model is the one we expect.\n    And if there is no mismatch between the configured and operating routing protocol model.\n    \"\"\"\n\n    name = \"VerifyRoutingProtocolModel\"\n    description = (\n        \"Verifies the configured routing protocol model is the expected one and if there is no mismatch between the configured and operating routing protocol model.\"\n    )\n    categories = [\"routing\", \"generic\"]\n    commands = [AntaCommand(command=\"show ip route summary\", revision=3)]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        model: Literal[\"multi-agent\", \"ribd\"] = \"multi-agent\"\n\"\"\"Expected routing protocol model\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        configured_model = command_output[\"protoModelStatus\"][\"configuredProtoModel\"]\n        operating_model = command_output[\"protoModelStatus\"][\"operatingProtoModel\"]\n        if configured_model == operating_model == self.inputs.model:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"routing model is misconfigured: configured: {configured_model} - operating: {operating_model} - expected: {self.inputs.model}\")\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingProtocolModel.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    model: Literal[\"multi-agent\", \"ribd\"] = \"multi-agent\"\n\"\"\"Expected routing protocol model\"\"\"\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingProtocolModel.Input.model","title":"model  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model: Literal['multi-agent', 'ribd'] = 'multi-agent'\n</code></pre> <p>Expected routing protocol model</p>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingTableEntry","title":"VerifyRoutingTableEntry","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies that the provided routes are present in the routing table of a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the provided routes are present in the routing table.</li> <li>failure: The test will fail if one or many provided routes are missing from the routing table.</li> </ul> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>class VerifyRoutingTableEntry(AntaTest):\n\"\"\"\n    This test verifies that the provided routes are present in the routing table of a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the provided routes are present in the routing table.\n        * failure: The test will fail if one or many provided routes are missing from the routing table.\n    \"\"\"\n\n    name = \"VerifyRoutingTableEntry\"\n    description = \"Verifies that the provided routes are present in the routing table of a specified VRF.\"\n    categories = [\"routing\", \"generic\"]\n    commands = [AntaTemplate(template=\"show ip route vrf {vrf} {route}\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        vrf: str = \"default\"\n\"\"\"VRF context\"\"\"\n        routes: List[IPv4Address]\n\"\"\"Routes to verify\"\"\"\n\n    def render(self, template: AntaTemplate) -&gt; list[AntaCommand]:\n        return [template.render(vrf=self.inputs.vrf, route=route) for route in self.inputs.routes]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        missing_routes = []\n\n        for command in self.instance_commands:\n            if command.params and \"vrf\" in command.params and \"route\" in command.params:\n                vrf, route = command.params[\"vrf\"], command.params[\"route\"]\n                if len(routes := command.json_output[\"vrfs\"][vrf][\"routes\"]) == 0 or route != ip_interface(list(routes)[0]).ip:\n                    missing_routes.append(str(route))\n\n        if not missing_routes:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following route(s) are missing from the routing table of VRF {self.inputs.vrf}: {missing_routes}\")\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingTableEntry.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    vrf: str = \"default\"\n\"\"\"VRF context\"\"\"\n    routes: List[IPv4Address]\n\"\"\"Routes to verify\"\"\"\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingTableEntry.Input.routes","title":"routes  <code>instance-attribute</code>","text":"<pre><code>routes: List[IPv4Address]\n</code></pre> <p>Routes to verify</p>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingTableEntry.Input.vrf","title":"vrf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vrf: str = 'default'\n</code></pre> <p>VRF context</p>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingTableSize","title":"VerifyRoutingTableSize","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the size of the IP routing table (default VRF). Should be between the two provided thresholds.</p> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>class VerifyRoutingTableSize(AntaTest):\n\"\"\"\n    Verifies the size of the IP routing table (default VRF).\n    Should be between the two provided thresholds.\n    \"\"\"\n\n    name = \"VerifyRoutingTableSize\"\n    description = \"Verifies the size of the IP routing table (default VRF). Should be between the two provided thresholds.\"\n    categories = [\"routing\", \"generic\"]\n    commands = [AntaCommand(command=\"show ip route summary\", revision=3)]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        minimum: int\n\"\"\"Expected minimum routing table (default VRF) size\"\"\"\n        maximum: int\n\"\"\"Expected maximum routing table (default VRF) size\"\"\"\n\n        @model_validator(mode=\"after\")  # type: ignore\n        def check_min_max(self) -&gt; AntaTest.Input:\n\"\"\"Validate that maximum is greater than minimum\"\"\"\n            if self.minimum &gt; self.maximum:\n                raise ValueError(f\"Minimum {self.minimum} is greater than maximum {self.maximum}\")\n            return self\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        total_routes = int(command_output[\"vrfs\"][\"default\"][\"totalRoutes\"])\n        if self.inputs.minimum &lt;= total_routes &lt;= self.inputs.maximum:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"routing-table has {total_routes} routes and not between min ({self.inputs.minimum}) and maximum ({self.inputs.maximum})\")\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingTableSize.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    minimum: int\n\"\"\"Expected minimum routing table (default VRF) size\"\"\"\n    maximum: int\n\"\"\"Expected maximum routing table (default VRF) size\"\"\"\n\n    @model_validator(mode=\"after\")  # type: ignore\n    def check_min_max(self) -&gt; AntaTest.Input:\n\"\"\"Validate that maximum is greater than minimum\"\"\"\n        if self.minimum &gt; self.maximum:\n            raise ValueError(f\"Minimum {self.minimum} is greater than maximum {self.maximum}\")\n        return self\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingTableSize.Input.maximum","title":"maximum  <code>instance-attribute</code>","text":"<pre><code>maximum: int\n</code></pre> <p>Expected maximum routing table (default VRF) size</p>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingTableSize.Input.minimum","title":"minimum  <code>instance-attribute</code>","text":"<pre><code>minimum: int\n</code></pre> <p>Expected minimum routing table (default VRF) size</p>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingTableSize.Input.check_min_max","title":"check_min_max","text":"<pre><code>check_min_max() -&gt; AntaTest.Input\n</code></pre> <p>Validate that maximum is greater than minimum</p> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>@model_validator(mode=\"after\")  # type: ignore\ndef check_min_max(self) -&gt; AntaTest.Input:\n\"\"\"Validate that maximum is greater than minimum\"\"\"\n    if self.minimum &gt; self.maximum:\n        raise ValueError(f\"Minimum {self.minimum} is greater than maximum {self.maximum}\")\n    return self\n</code></pre>"},{"location":"api/tests.routing.ospf/","title":"OSPF","text":""},{"location":"api/tests.routing.ospf/#anta-catalog-for-routing-ospf-tests","title":"ANTA catalog for routing-ospf tests","text":"<p>OSPF test functions</p>"},{"location":"api/tests.routing.ospf/#anta.tests.routing.ospf.VerifyOSPFNeighborCount","title":"VerifyOSPFNeighborCount","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the number of OSPF neighbors in FULL state is the one we expect.</p> Source code in <code>anta/tests/routing/ospf.py</code> <pre><code>class VerifyOSPFNeighborCount(AntaTest):\n\"\"\"\n    Verifies the number of OSPF neighbors in FULL state is the one we expect.\n    \"\"\"\n\n    name = \"VerifyOSPFNeighborCount\"\n    description = \"Verifies the number of OSPF neighbors in FULL state is the one we expect.\"\n    categories = [\"routing\", \"ospf\"]\n    commands = [AntaCommand(command=\"show ip ospf neighbor\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        number: int\n\"\"\"The expected number of OSPF neighbors in FULL state\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        if (neighbor_count := _count_ospf_neighbor(command_output)) == 0:\n            self.result.is_skipped(\"no OSPF neighbor found\")\n            return\n        self.result.is_success()\n        if neighbor_count != self.inputs.number:\n            self.result.is_failure(f\"device has {neighbor_count} neighbors (expected {self.inputs.number})\")\n        not_full_neighbors = _get_not_full_ospf_neighbors(command_output)\n        print(not_full_neighbors)\n        if not_full_neighbors:\n            self.result.is_failure(f\"Some neighbors are not correctly configured: {not_full_neighbors}.\")\n</code></pre>"},{"location":"api/tests.routing.ospf/#anta.tests.routing.ospf.VerifyOSPFNeighborCount.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/routing/ospf.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    number: int\n\"\"\"The expected number of OSPF neighbors in FULL state\"\"\"\n</code></pre>"},{"location":"api/tests.routing.ospf/#anta.tests.routing.ospf.VerifyOSPFNeighborCount.Input.number","title":"number  <code>instance-attribute</code>","text":"<pre><code>number: int\n</code></pre> <p>The expected number of OSPF neighbors in FULL state</p>"},{"location":"api/tests.routing.ospf/#anta.tests.routing.ospf.VerifyOSPFNeighborState","title":"VerifyOSPFNeighborState","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies all OSPF neighbors are in FULL state.</p> Source code in <code>anta/tests/routing/ospf.py</code> <pre><code>class VerifyOSPFNeighborState(AntaTest):\n\"\"\"\n    Verifies all OSPF neighbors are in FULL state.\n    \"\"\"\n\n    name = \"VerifyOSPFNeighborState\"\n    description = \"Verifies all OSPF neighbors are in FULL state.\"\n    categories = [\"routing\", \"ospf\"]\n    commands = [AntaCommand(command=\"show ip ospf neighbor\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        if _count_ospf_neighbor(command_output) == 0:\n            self.result.is_skipped(\"no OSPF neighbor found\")\n            return\n        self.result.is_success()\n        not_full_neighbors = _get_not_full_ospf_neighbors(command_output)\n        if not_full_neighbors:\n            self.result.is_failure(f\"Some neighbors are not correctly configured: {not_full_neighbors}.\")\n</code></pre>"},{"location":"api/tests.security/","title":"Security","text":""},{"location":"api/tests.security/#anta-catalog-for-security-tests","title":"ANTA catalog for security tests","text":"<p>Test functions related to the EOS various security settings</p>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIHttpStatus","title":"VerifyAPIHttpStatus","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if eAPI HTTP server is disabled globally.</p> Expected Results <ul> <li>success: The test will pass if eAPI HTTP server is disabled globally.</li> <li>failure: The test will fail if eAPI HTTP server is NOT disabled globally.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifyAPIHttpStatus(AntaTest):\n\"\"\"\n    Verifies if eAPI HTTP server is disabled globally.\n\n    Expected Results:\n        * success: The test will pass if eAPI HTTP server is disabled globally.\n        * failure: The test will fail if eAPI HTTP server is NOT disabled globally.\n    \"\"\"\n\n    name = \"VerifyAPIHttpStatus\"\n    description = \"Verifies if eAPI HTTP server is disabled globally.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management api http-commands\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        if command_output[\"enabled\"] and not command_output[\"httpServer\"][\"running\"]:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"eAPI HTTP server is enabled globally\")\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIHttpsSSL","title":"VerifyAPIHttpsSSL","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if eAPI HTTPS server SSL profile is configured and valid.</p> Expected results <ul> <li>success: The test will pass if the eAPI HTTPS server SSL profile is configured and valid.</li> <li>failure: The test will fail if the eAPI HTTPS server SSL profile is NOT configured, misconfigured or invalid.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifyAPIHttpsSSL(AntaTest):\n\"\"\"\n    Verifies if eAPI HTTPS server SSL profile is configured and valid.\n\n    Expected results:\n        * success: The test will pass if the eAPI HTTPS server SSL profile is configured and valid.\n        * failure: The test will fail if the eAPI HTTPS server SSL profile is NOT configured, misconfigured or invalid.\n    \"\"\"\n\n    name = \"VerifyAPIHttpsSSL\"\n    description = \"Verifies if eAPI HTTPS server SSL profile is configured and valid.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management api http-commands\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        profile: str\n\"\"\"SSL profile to verify\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        try:\n            if command_output[\"sslProfile\"][\"name\"] == self.inputs.profile and command_output[\"sslProfile\"][\"state\"] == \"valid\":\n                self.result.is_success()\n            else:\n                self.result.is_failure(f\"eAPI HTTPS server SSL profile ({self.inputs.profile}) is misconfigured or invalid\")\n\n        except KeyError:\n            self.result.is_failure(f\"eAPI HTTPS server SSL profile ({self.inputs.profile}) is not configured\")\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIHttpsSSL.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/security.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    profile: str\n\"\"\"SSL profile to verify\"\"\"\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIHttpsSSL.Input.profile","title":"profile  <code>instance-attribute</code>","text":"<pre><code>profile: str\n</code></pre> <p>SSL profile to verify</p>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIIPv4Acl","title":"VerifyAPIIPv4Acl","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if eAPI has the right number IPv4 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if eAPI has the provided number of IPv4 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if eAPI has not the right number of IPv4 ACL(s) in the specified VRF.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifyAPIIPv4Acl(AntaTest):\n\"\"\"\n    Verifies if eAPI has the right number IPv4 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if eAPI has the provided number of IPv4 ACL(s) in the specified VRF.\n        * failure: The test will fail if eAPI has not the right number of IPv4 ACL(s) in the specified VRF.\n    \"\"\"\n\n    name = \"VerifyAPIIPv4Acl\"\n    description = \"Verifies if eAPI has the right number IPv4 ACL(s) configured for a specified VRF.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management api http-commands ip access-list summary\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        number: conint(ge=0)  # type:ignore\n\"\"\"The number of expected IPv4 ACL(s)\"\"\"\n        vrf: str = \"default\"\n\"\"\"The name of the VRF in which to check for eAPI\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n        ipv4_acl_number = len(ipv4_acl_list)\n        not_configured_acl_list = []\n        if ipv4_acl_number != self.inputs.number:\n            self.result.is_failure(f\"Expected {self.inputs.number} eAPI IPv4 ACL(s) in vrf {self.inputs.vrf} but got {ipv4_acl_number}\")\n            return\n        for ipv4_acl in ipv4_acl_list:\n            if self.inputs.vrf not in ipv4_acl[\"configuredVrfs\"] or self.inputs.vrf not in ipv4_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv4_acl[\"name\"])\n        if not_configured_acl_list:\n            self.result.is_failure(f\"eAPI IPv4 ACL(s) not configured or active in vrf {self.inputs.vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIIPv4Acl.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/security.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    number: conint(ge=0)  # type:ignore\n\"\"\"The number of expected IPv4 ACL(s)\"\"\"\n    vrf: str = \"default\"\n\"\"\"The name of the VRF in which to check for eAPI\"\"\"\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIIPv4Acl.Input.number","title":"number  <code>instance-attribute</code>","text":"<pre><code>number: conint(ge=0)\n</code></pre> <p>The number of expected IPv4 ACL(s)</p>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIIPv4Acl.Input.vrf","title":"vrf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vrf: str = 'default'\n</code></pre> <p>The name of the VRF in which to check for eAPI</p>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIIPv6Acl","title":"VerifyAPIIPv6Acl","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if eAPI has the right number IPv6 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if eAPI has the provided number of IPv6 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if eAPI has not the right number of IPv6 ACL(s) in the specified VRF.</li> <li>skipped: The test will be skipped if the number of IPv6 ACL(s) or VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifyAPIIPv6Acl(AntaTest):\n\"\"\"\n    Verifies if eAPI has the right number IPv6 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if eAPI has the provided number of IPv6 ACL(s) in the specified VRF.\n        * failure: The test will fail if eAPI has not the right number of IPv6 ACL(s) in the specified VRF.\n        * skipped: The test will be skipped if the number of IPv6 ACL(s) or VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifyAPIIPv6Acl\"\n    description = \"Verifies if eAPI has the right number IPv6 ACL(s) configured for a specified VRF.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management api http-commands ipv6 access-list summary\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        number: conint(ge=0)  # type:ignore\n\"\"\"The number of expected IPv6 ACL(s)\"\"\"\n        vrf: str = \"default\"\n\"\"\"The name of the VRF in which to check for eAPI\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n        ipv6_acl_number = len(ipv6_acl_list)\n        not_configured_acl_list = []\n        if ipv6_acl_number != self.inputs.number:\n            self.result.is_failure(f\"Expected {self.inputs.number} eAPI IPv6 ACL(s) in vrf {self.inputs.vrf} but got {ipv6_acl_number}\")\n            return\n        for ipv6_acl in ipv6_acl_list:\n            if self.inputs.vrf not in ipv6_acl[\"configuredVrfs\"] or self.inputs.vrf not in ipv6_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv6_acl[\"name\"])\n        if not_configured_acl_list:\n            self.result.is_failure(f\"eAPI IPv6 ACL(s) not configured or active in vrf {self.inputs.vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIIPv6Acl.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/security.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    number: conint(ge=0)  # type:ignore\n\"\"\"The number of expected IPv6 ACL(s)\"\"\"\n    vrf: str = \"default\"\n\"\"\"The name of the VRF in which to check for eAPI\"\"\"\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIIPv6Acl.Input.number","title":"number  <code>instance-attribute</code>","text":"<pre><code>number: conint(ge=0)\n</code></pre> <p>The number of expected IPv6 ACL(s)</p>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIIPv6Acl.Input.vrf","title":"vrf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vrf: str = 'default'\n</code></pre> <p>The name of the VRF in which to check for eAPI</p>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHIPv4Acl","title":"VerifySSHIPv4Acl","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if the SSHD agent has the right number IPv4 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if the SSHD agent has the provided number of IPv4 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if the SSHD agent has not the right number of IPv4 ACL(s) in the specified VRF.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifySSHIPv4Acl(AntaTest):\n\"\"\"\n    Verifies if the SSHD agent has the right number IPv4 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if the SSHD agent has the provided number of IPv4 ACL(s) in the specified VRF.\n        * failure: The test will fail if the SSHD agent has not the right number of IPv4 ACL(s) in the specified VRF.\n    \"\"\"\n\n    name = \"VerifySSHIPv4Acl\"\n    description = \"Verifies if the SSHD agent has IPv4 ACL(s) configured.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management ssh ip access-list summary\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        number: conint(ge=0)  # type:ignore\n\"\"\"The number of expected IPv4 ACL(s)\"\"\"\n        vrf: str = \"default\"\n\"\"\"The name of the VRF in which to check for the SSHD agent\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n        ipv4_acl_number = len(ipv4_acl_list)\n        not_configured_acl_list = []\n        if ipv4_acl_number != self.inputs.number:\n            self.result.is_failure(f\"Expected {self.inputs.number} SSH IPv4 ACL(s) in vrf {self.inputs.vrf} but got {ipv4_acl_number}\")\n            return\n        for ipv4_acl in ipv4_acl_list:\n            if self.inputs.vrf not in ipv4_acl[\"configuredVrfs\"] or self.inputs.vrf not in ipv4_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv4_acl[\"name\"])\n        if not_configured_acl_list:\n            self.result.is_failure(f\"SSH IPv4 ACL(s) not configured or active in vrf {self.inputs.vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHIPv4Acl.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/security.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    number: conint(ge=0)  # type:ignore\n\"\"\"The number of expected IPv4 ACL(s)\"\"\"\n    vrf: str = \"default\"\n\"\"\"The name of the VRF in which to check for the SSHD agent\"\"\"\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHIPv4Acl.Input.number","title":"number  <code>instance-attribute</code>","text":"<pre><code>number: conint(ge=0)\n</code></pre> <p>The number of expected IPv4 ACL(s)</p>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHIPv4Acl.Input.vrf","title":"vrf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vrf: str = 'default'\n</code></pre> <p>The name of the VRF in which to check for the SSHD agent</p>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHIPv6Acl","title":"VerifySSHIPv6Acl","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if the SSHD agent has the right number IPv6 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if the SSHD agent has the provided number of IPv6 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if the SSHD agent has not the right number of IPv6 ACL(s) in the specified VRF.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifySSHIPv6Acl(AntaTest):\n\"\"\"\n    Verifies if the SSHD agent has the right number IPv6 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if the SSHD agent has the provided number of IPv6 ACL(s) in the specified VRF.\n        * failure: The test will fail if the SSHD agent has not the right number of IPv6 ACL(s) in the specified VRF.\n    \"\"\"\n\n    name = \"VerifySSHIPv6Acl\"\n    description = \"Verifies if the SSHD agent has IPv6 ACL(s) configured.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management ssh ipv6 access-list summary\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        number: conint(ge=0)  # type:ignore\n\"\"\"The number of expected IPv6 ACL(s)\"\"\"\n        vrf: str = \"default\"\n\"\"\"The name of the VRF in which to check for the SSHD agent\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n        ipv6_acl_number = len(ipv6_acl_list)\n        not_configured_acl_list = []\n        if ipv6_acl_number != self.inputs.number:\n            self.result.is_failure(f\"Expected {self.inputs.number} SSH IPv6 ACL(s) in vrf {self.inputs.vrf} but got {ipv6_acl_number}\")\n            return\n        for ipv6_acl in ipv6_acl_list:\n            if self.inputs.vrf not in ipv6_acl[\"configuredVrfs\"] or self.inputs.vrf not in ipv6_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv6_acl[\"name\"])\n        if not_configured_acl_list:\n            self.result.is_failure(f\"SSH IPv6 ACL(s) not configured or active in vrf {self.inputs.vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHIPv6Acl.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/security.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    number: conint(ge=0)  # type:ignore\n\"\"\"The number of expected IPv6 ACL(s)\"\"\"\n    vrf: str = \"default\"\n\"\"\"The name of the VRF in which to check for the SSHD agent\"\"\"\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHIPv6Acl.Input.number","title":"number  <code>instance-attribute</code>","text":"<pre><code>number: conint(ge=0)\n</code></pre> <p>The number of expected IPv6 ACL(s)</p>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHIPv6Acl.Input.vrf","title":"vrf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vrf: str = 'default'\n</code></pre> <p>The name of the VRF in which to check for the SSHD agent</p>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHStatus","title":"VerifySSHStatus","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if the SSHD agent is disabled in the default VRF.</p> Expected Results <ul> <li>success: The test will pass if the SSHD agent is disabled in the default VRF.</li> <li>failure: The test will fail if the SSHD agent is NOT disabled in the default VRF.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifySSHStatus(AntaTest):\n\"\"\"\n    Verifies if the SSHD agent is disabled in the default VRF.\n\n    Expected Results:\n        * success: The test will pass if the SSHD agent is disabled in the default VRF.\n        * failure: The test will fail if the SSHD agent is NOT disabled in the default VRF.\n    \"\"\"\n\n    name = \"VerifySSHStatus\"\n    description = \"Verifies if the SSHD agent is disabled in the default VRF.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management ssh\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].text_output\n\n        line = [line for line in command_output.split(\"\\n\") if line.startswith(\"SSHD status\")][0]\n        status = line.split(\"is \")[1]\n\n        if status == \"disabled\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(line)\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyTelnetStatus","title":"VerifyTelnetStatus","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if Telnet is disabled in the default VRF.</p> Expected Results <ul> <li>success: The test will pass if Telnet is disabled in the default VRF.</li> <li>failure: The test will fail if Telnet is NOT disabled in the default VRF.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifyTelnetStatus(AntaTest):\n\"\"\"\n    Verifies if Telnet is disabled in the default VRF.\n\n    Expected Results:\n        * success: The test will pass if Telnet is disabled in the default VRF.\n        * failure: The test will fail if Telnet is NOT disabled in the default VRF.\n    \"\"\"\n\n    name = \"VerifyTelnetStatus\"\n    description = \"Verifies if Telnet is disabled in the default VRF.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management telnet\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        if command_output[\"serverState\"] == \"disabled\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"Telnet status for Default VRF is enabled\")\n</code></pre>"},{"location":"api/tests.snmp/","title":"SNMP","text":""},{"location":"api/tests.snmp/#anta-catalog-for-snmp-tests","title":"ANTA catalog for SNMP tests","text":"<p>Test functions related to the EOS various SNMP settings</p>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpIPv4Acl","title":"VerifySnmpIPv4Acl","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if the SNMP agent has the right number IPv4 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if the SNMP agent has the provided number of IPv4 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if the SNMP agent has not the right number of IPv4 ACL(s) in the specified VRF.</li> </ul> Source code in <code>anta/tests/snmp.py</code> <pre><code>class VerifySnmpIPv4Acl(AntaTest):\n\"\"\"\n    Verifies if the SNMP agent has the right number IPv4 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if the SNMP agent has the provided number of IPv4 ACL(s) in the specified VRF.\n        * failure: The test will fail if the SNMP agent has not the right number of IPv4 ACL(s) in the specified VRF.\n    \"\"\"\n\n    name = \"VerifySnmpIPv4Acl\"\n    description = \"Verifies if the SNMP agent has IPv4 ACL(s) configured.\"\n    categories = [\"snmp\"]\n    commands = [AntaCommand(command=\"show snmp ipv4 access-list summary\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        number: conint(ge=0)  # type:ignore\n\"\"\"The number of expected IPv4 ACL(s)\"\"\"\n        vrf: str = \"default\"\n\"\"\"The name of the VRF in which to check for the SNMP agent\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n        ipv4_acl_number = len(ipv4_acl_list)\n        not_configured_acl_list = []\n        if ipv4_acl_number != self.inputs.number:\n            self.result.is_failure(f\"Expected {self.inputs.number} SNMP IPv4 ACL(s) in vrf {self.inputs.vrf} but got {ipv4_acl_number}\")\n            return\n        for ipv4_acl in ipv4_acl_list:\n            if self.inputs.vrf not in ipv4_acl[\"configuredVrfs\"] or self.inputs.vrf not in ipv4_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv4_acl[\"name\"])\n        if not_configured_acl_list:\n            self.result.is_failure(f\"SNMP IPv4 ACL(s) not configured or active in vrf {self.inputs.vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpIPv4Acl.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/snmp.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    number: conint(ge=0)  # type:ignore\n\"\"\"The number of expected IPv4 ACL(s)\"\"\"\n    vrf: str = \"default\"\n\"\"\"The name of the VRF in which to check for the SNMP agent\"\"\"\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpIPv4Acl.Input.number","title":"number  <code>instance-attribute</code>","text":"<pre><code>number: conint(ge=0)\n</code></pre> <p>The number of expected IPv4 ACL(s)</p>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpIPv4Acl.Input.vrf","title":"vrf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vrf: str = 'default'\n</code></pre> <p>The name of the VRF in which to check for the SNMP agent</p>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpIPv6Acl","title":"VerifySnmpIPv6Acl","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if the SNMP agent has the right number IPv6 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if the SNMP agent has the provided number of IPv6 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if the SNMP agent has not the right number of IPv6 ACL(s) in the specified VRF.</li> </ul> Source code in <code>anta/tests/snmp.py</code> <pre><code>class VerifySnmpIPv6Acl(AntaTest):\n\"\"\"\n    Verifies if the SNMP agent has the right number IPv6 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if the SNMP agent has the provided number of IPv6 ACL(s) in the specified VRF.\n        * failure: The test will fail if the SNMP agent has not the right number of IPv6 ACL(s) in the specified VRF.\n    \"\"\"\n\n    name = \"VerifySnmpIPv6Acl\"\n    description = \"Verifies if the SNMP agent has IPv6 ACL(s) configured.\"\n    categories = [\"snmp\"]\n    commands = [AntaCommand(command=\"show snmp ipv6 access-list summary\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        number: conint(ge=0)  # type:ignore\n\"\"\"The number of expected IPv6 ACL(s)\"\"\"\n        vrf: str = \"default\"\n\"\"\"The name of the VRF in which to check for the SNMP agent\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n        ipv6_acl_number = len(ipv6_acl_list)\n        not_configured_acl_list = []\n        if ipv6_acl_number != self.inputs.number:\n            self.result.is_failure(f\"Expected {self.inputs.number} SNMP IPv6 ACL(s) in vrf {self.inputs.vrf} but got {ipv6_acl_number}\")\n            return\n        for ipv6_acl in ipv6_acl_list:\n            if self.inputs.vrf not in ipv6_acl[\"configuredVrfs\"] or self.inputs.vrf not in ipv6_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv6_acl[\"name\"])\n        if not_configured_acl_list:\n            self.result.is_failure(f\"SNMP IPv6 ACL(s) not configured or active in vrf {self.inputs.vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpIPv6Acl.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/snmp.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    number: conint(ge=0)  # type:ignore\n\"\"\"The number of expected IPv6 ACL(s)\"\"\"\n    vrf: str = \"default\"\n\"\"\"The name of the VRF in which to check for the SNMP agent\"\"\"\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpIPv6Acl.Input.number","title":"number  <code>instance-attribute</code>","text":"<pre><code>number: conint(ge=0)\n</code></pre> <p>The number of expected IPv6 ACL(s)</p>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpIPv6Acl.Input.vrf","title":"vrf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vrf: str = 'default'\n</code></pre> <p>The name of the VRF in which to check for the SNMP agent</p>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpStatus","title":"VerifySnmpStatus","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies whether the SNMP agent is enabled in a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the SNMP agent is enabled in the specified VRF.</li> <li>failure: The test will fail if the SNMP agent is disabled in the specified VRF.</li> </ul> Source code in <code>anta/tests/snmp.py</code> <pre><code>class VerifySnmpStatus(AntaTest):\n\"\"\"\n    Verifies whether the SNMP agent is enabled in a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the SNMP agent is enabled in the specified VRF.\n        * failure: The test will fail if the SNMP agent is disabled in the specified VRF.\n    \"\"\"\n\n    name = \"VerifySnmpStatus\"\n    description = \"Verifies if the SNMP agent is enabled.\"\n    categories = [\"snmp\"]\n    commands = [AntaCommand(command=\"show snmp\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        vrf: str = \"default\"\n\"\"\"The name of the VRF in which to check for the SNMP agent\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        if command_output[\"enabled\"] and self.inputs.vrf in command_output[\"vrfs\"][\"snmpVrfs\"]:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"SNMP agent disabled in vrf {self.inputs.vrf}\")\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpStatus.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/snmp.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    vrf: str = \"default\"\n\"\"\"The name of the VRF in which to check for the SNMP agent\"\"\"\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpStatus.Input.vrf","title":"vrf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vrf: str = 'default'\n</code></pre> <p>The name of the VRF in which to check for the SNMP agent</p>"},{"location":"api/tests.software/","title":"Software","text":""},{"location":"api/tests.software/#anta-catalog-for-software-tests","title":"ANTA catalog for software tests","text":"<p>Test functions related to the EOS software</p>"},{"location":"api/tests.software/#anta.tests.software.VerifyEOSExtensions","title":"VerifyEOSExtensions","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies all EOS extensions installed on the device are enabled for boot persistence.</p> Source code in <code>anta/tests/software.py</code> <pre><code>class VerifyEOSExtensions(AntaTest):\n\"\"\"\n    Verifies all EOS extensions installed on the device are enabled for boot persistence.\n    \"\"\"\n\n    name = \"VerifyEOSExtensions\"\n    description = \"Verifies all EOS extensions installed on the device are enabled for boot persistence.\"\n    categories = [\"software\"]\n    commands = [AntaCommand(command=\"show extensions\"), AntaCommand(command=\"show boot-extensions\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        boot_extensions = []\n        show_extensions_command_output = self.instance_commands[0].json_output\n        show_boot_extensions_command_output = self.instance_commands[1].json_output\n        installed_extensions = [\n            extension for extension, extension_data in show_extensions_command_output[\"extensions\"].items() if extension_data[\"status\"] == \"installed\"\n        ]\n        for extension in show_boot_extensions_command_output[\"extensions\"]:\n            extension = extension.strip(\"\\n\")\n            if extension != \"\":\n                boot_extensions.append(extension)\n        installed_extensions.sort()\n        boot_extensions.sort()\n        if installed_extensions == boot_extensions:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Missing EOS extensions: installed {installed_extensions} / configured: {boot_extensions}\")\n</code></pre>"},{"location":"api/tests.software/#anta.tests.software.VerifyEOSVersion","title":"VerifyEOSVersion","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the device is running one of the allowed EOS version.</p> Source code in <code>anta/tests/software.py</code> <pre><code>class VerifyEOSVersion(AntaTest):\n\"\"\"\n    Verifies the device is running one of the allowed EOS version.\n    \"\"\"\n\n    name = \"VerifyEOSVersion\"\n    description = \"Verifies the device is running one of the allowed EOS version.\"\n    categories = [\"software\"]\n    commands = [AntaCommand(command=\"show version\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        versions: List[str]\n\"\"\"List of allowed EOS versions\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        if command_output[\"version\"] in self.inputs.versions:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f'device is running version {command_output[\"version\"]} not in expected versions: {self.inputs.versions}')\n</code></pre>"},{"location":"api/tests.software/#anta.tests.software.VerifyEOSVersion.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/software.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    versions: List[str]\n\"\"\"List of allowed EOS versions\"\"\"\n</code></pre>"},{"location":"api/tests.software/#anta.tests.software.VerifyEOSVersion.Input.versions","title":"versions  <code>instance-attribute</code>","text":"<pre><code>versions: List[str]\n</code></pre> <p>List of allowed EOS versions</p>"},{"location":"api/tests.software/#anta.tests.software.VerifyTerminAttrVersion","title":"VerifyTerminAttrVersion","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the device is running one of the allowed TerminAttr version.</p> Source code in <code>anta/tests/software.py</code> <pre><code>class VerifyTerminAttrVersion(AntaTest):\n\"\"\"\n    Verifies the device is running one of the allowed TerminAttr version.\n    \"\"\"\n\n    name = \"VerifyTerminAttrVersion\"\n    description = \"Verifies the device is running one of the allowed TerminAttr version.\"\n    categories = [\"software\"]\n    commands = [AntaCommand(command=\"show version detail\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        versions: List[str]\n\"\"\"List of allowed TerminAttr versions\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        command_output_data = command_output[\"details\"][\"packages\"][\"TerminAttr-core\"][\"version\"]\n        if command_output_data in self.inputs.versions:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"device is running TerminAttr version {command_output_data} and is not in the allowed list: {self.inputs.versions}\")\n</code></pre>"},{"location":"api/tests.software/#anta.tests.software.VerifyTerminAttrVersion.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/software.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    versions: List[str]\n\"\"\"List of allowed TerminAttr versions\"\"\"\n</code></pre>"},{"location":"api/tests.software/#anta.tests.software.VerifyTerminAttrVersion.Input.versions","title":"versions  <code>instance-attribute</code>","text":"<pre><code>versions: List[str]\n</code></pre> <p>List of allowed TerminAttr versions</p>"},{"location":"api/tests.stp/","title":"STP","text":""},{"location":"api/tests.stp/#anta-catalog-for-stp-tests","title":"ANTA catalog for STP tests","text":"<p>Test functions related to various Spanning Tree Protocol (STP) settings</p>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPBlockedPorts","title":"VerifySTPBlockedPorts","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies there is no STP blocked ports.</p> Expected Results <ul> <li>success: The test will pass if there are NO ports blocked by STP.</li> <li>failure: The test will fail if there are ports blocked by STP.</li> </ul> Source code in <code>anta/tests/stp.py</code> <pre><code>class VerifySTPBlockedPorts(AntaTest):\n\"\"\"\n    Verifies there is no STP blocked ports.\n\n    Expected Results:\n        * success: The test will pass if there are NO ports blocked by STP.\n        * failure: The test will fail if there are ports blocked by STP.\n    \"\"\"\n\n    name = \"VerifySTPBlockedPorts\"\n    description = \"Verifies there is no STP blocked ports.\"\n    categories = [\"stp\"]\n    commands = [AntaCommand(command=\"show spanning-tree blockedports\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        if not (stp_instances := command_output[\"spanningTreeInstances\"]):\n            self.result.is_success()\n        else:\n            for key, value in stp_instances.items():\n                stp_instances[key] = value.pop(\"spanningTreeBlockedPorts\")\n            self.result.is_failure(f\"The following ports are blocked by STP: {stp_instances}\")\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPCounters","title":"VerifySTPCounters","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies there is no errors in STP BPDU packets.</p> Expected Results <ul> <li>success: The test will pass if there are NO STP BPDU packet errors under all interfaces participating in STP.</li> <li>failure: The test will fail if there are STP BPDU packet errors on one or many interface(s).</li> </ul> Source code in <code>anta/tests/stp.py</code> <pre><code>class VerifySTPCounters(AntaTest):\n\"\"\"\n    Verifies there is no errors in STP BPDU packets.\n\n    Expected Results:\n        * success: The test will pass if there are NO STP BPDU packet errors under all interfaces participating in STP.\n        * failure: The test will fail if there are STP BPDU packet errors on one or many interface(s).\n    \"\"\"\n\n    name = \"VerifySTPCounters\"\n    description = \"Verifies there is no errors in STP BPDU packets.\"\n    categories = [\"stp\"]\n    commands = [AntaCommand(command=\"show spanning-tree counters\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        interfaces_with_errors = [\n            interface for interface, counters in command_output[\"interfaces\"].items() if counters[\"bpduTaggedError\"] or counters[\"bpduOtherError\"] != 0\n        ]\n        if interfaces_with_errors:\n            self.result.is_failure(f\"The following interfaces have STP BPDU packet errors: {interfaces_with_errors}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPForwardingPorts","title":"VerifySTPForwardingPorts","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies that all interfaces are in a forwarding state for a provided list of VLAN(s).</p> Expected Results <ul> <li>success: The test will pass if all interfaces are in a forwarding state for the specified VLAN(s).</li> <li>failure: The test will fail if one or many interfaces are NOT in a forwarding state in the specified VLAN(s).</li> </ul> Source code in <code>anta/tests/stp.py</code> <pre><code>class VerifySTPForwardingPorts(AntaTest):\n\"\"\"\n    Verifies that all interfaces are in a forwarding state for a provided list of VLAN(s).\n\n    Expected Results:\n        * success: The test will pass if all interfaces are in a forwarding state for the specified VLAN(s).\n        * failure: The test will fail if one or many interfaces are NOT in a forwarding state in the specified VLAN(s).\n    \"\"\"\n\n    name = \"VerifySTPForwardingPorts\"\n    description = \"Verifies that all interfaces are forwarding for a provided list of VLAN(s).\"\n    categories = [\"stp\"]\n    commands = [AntaTemplate(template=\"show spanning-tree topology vlan {vlan} status\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        vlans: List[Vlan]\n\"\"\"List of VLAN on which to verify forwarding states\"\"\"\n\n    def render(self, template: AntaTemplate) -&gt; list[AntaCommand]:\n        return [template.render(vlan=vlan) for vlan in self.inputs.vlans]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        not_configured = []\n        not_forwarding = []\n        for command in self.instance_commands:\n            if command.params and \"vlan\" in command.params:\n                vlan_id = command.params[\"vlan\"]\n            if not (topologies := get_value(command.json_output, \"topologies\")):\n                not_configured.append(vlan_id)\n            else:\n                for value in topologies.values():\n                    if int(vlan_id) in value[\"vlans\"]:\n                        interfaces_not_forwarding = [interface for interface, state in value[\"interfaces\"].items() if state[\"state\"] != \"forwarding\"]\n                if interfaces_not_forwarding:\n                    not_forwarding.append({f\"VLAN {vlan_id}\": interfaces_not_forwarding})\n        if not_configured:\n            self.result.is_failure(f\"STP instance is not configured for the following VLAN(s): {not_configured}\")\n        if not_forwarding:\n            self.result.is_failure(f\"The following VLAN(s) have interface(s) that are not in a fowarding state: {not_forwarding}\")\n        if not not_configured and not interfaces_not_forwarding:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPForwardingPorts.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/stp.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    vlans: List[Vlan]\n\"\"\"List of VLAN on which to verify forwarding states\"\"\"\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPForwardingPorts.Input.vlans","title":"vlans  <code>instance-attribute</code>","text":"<pre><code>vlans: List[Vlan]\n</code></pre> <p>List of VLAN on which to verify forwarding states</p>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPMode","title":"VerifySTPMode","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the configured STP mode for a provided list of VLAN(s).</p> Expected Results <ul> <li>success: The test will pass if the STP mode is configured properly in the specified VLAN(s).</li> <li>failure: The test will fail if the STP mode is NOT configured properly for one or more specified VLAN(s).</li> </ul> Source code in <code>anta/tests/stp.py</code> <pre><code>class VerifySTPMode(AntaTest):\n\"\"\"\n    Verifies the configured STP mode for a provided list of VLAN(s).\n\n    Expected Results:\n        * success: The test will pass if the STP mode is configured properly in the specified VLAN(s).\n        * failure: The test will fail if the STP mode is NOT configured properly for one or more specified VLAN(s).\n    \"\"\"\n\n    name = \"VerifySTPMode\"\n    description = \"Verifies the configured STP mode for a provided list of VLAN(s).\"\n    categories = [\"stp\"]\n    commands = [AntaTemplate(template=\"show spanning-tree vlan {vlan}\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        mode: Literal[\"mstp\", \"rstp\", \"rapidPvst\"] = \"mstp\"\n\"\"\"STP mode to verify\"\"\"\n        vlans: List[Vlan]\n\"\"\"List of VLAN on which to verify STP mode\"\"\"\n\n    def render(self, template: AntaTemplate) -&gt; list[AntaCommand]:\n        return [template.render(vlan=vlan) for vlan in self.inputs.vlans]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        not_configured = []\n        wrong_stp_mode = []\n        for command in self.instance_commands:\n            if command.params and \"vlan\" in command.params:\n                vlan_id = command.params[\"vlan\"]\n            if not (stp_mode := get_value(command.json_output, f\"spanningTreeVlanInstances.{vlan_id}.spanningTreeVlanInstance.protocol\")):\n                not_configured.append(vlan_id)\n            elif stp_mode != self.inputs.mode:\n                wrong_stp_mode.append(vlan_id)\n        if not_configured:\n            self.result.is_failure(f\"STP mode '{self.inputs.mode}' not configured for the following VLAN(s): {not_configured}\")\n        if wrong_stp_mode:\n            self.result.is_failure(f\"Wrong STP mode configured for the following VLAN(s): {wrong_stp_mode}\")\n        if not not_configured and not wrong_stp_mode:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPMode.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/stp.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    mode: Literal[\"mstp\", \"rstp\", \"rapidPvst\"] = \"mstp\"\n\"\"\"STP mode to verify\"\"\"\n    vlans: List[Vlan]\n\"\"\"List of VLAN on which to verify STP mode\"\"\"\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPMode.Input.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mode: Literal['mstp', 'rstp', 'rapidPvst'] = 'mstp'\n</code></pre> <p>STP mode to verify</p>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPMode.Input.vlans","title":"vlans  <code>instance-attribute</code>","text":"<pre><code>vlans: List[Vlan]\n</code></pre> <p>List of VLAN on which to verify STP mode</p>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPRootPriority","title":"VerifySTPRootPriority","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the STP root priority for a provided list of VLAN or MST instance ID(s).</p> Expected Results <ul> <li>success: The test will pass if the STP root priority is configured properly for the specified VLAN or MST instance ID(s).</li> <li>failure: The test will fail if the STP root priority is NOT configured properly for the specified VLAN or MST instance ID(s).</li> </ul> Source code in <code>anta/tests/stp.py</code> <pre><code>class VerifySTPRootPriority(AntaTest):\n\"\"\"\n    Verifies the STP root priority for a provided list of VLAN or MST instance ID(s).\n\n    Expected Results:\n        * success: The test will pass if the STP root priority is configured properly for the specified VLAN or MST instance ID(s).\n        * failure: The test will fail if the STP root priority is NOT configured properly for the specified VLAN or MST instance ID(s).\n    \"\"\"\n\n    name = \"VerifySTPRootPriority\"\n    description = \"Verifies the STP root priority for a provided list of VLAN or MST instance ID(s).\"\n    categories = [\"stp\"]\n    commands = [AntaCommand(command=\"show spanning-tree root detail\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        priority: int\n\"\"\"STP root priority to verify\"\"\"\n        instances: List[Vlan] = []\n\"\"\"List of VLAN or MST instance ID(s). If empty, ALL VLAN or MST instance ID(s) will be verified.\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        if not (stp_instances := command_output[\"instances\"]):\n            self.result.is_failure(\"No STP instances configured\")\n            return\n        for instance in stp_instances:\n            if instance.startswith(\"MST\"):\n                prefix = \"MST\"\n                break\n            if instance.startswith(\"VL\"):\n                prefix = \"VL\"\n                break\n        check_instances = [f\"{prefix}{instance_id}\" for instance_id in self.inputs.instances] if self.inputs.instances else command_output[\"instances\"].keys()\n        wrong_priority_instances = [\n            instance for instance in check_instances if get_value(command_output, f\"instances.{instance}.rootBridge.priority\") != self.inputs.priority\n        ]\n        if wrong_priority_instances:\n            self.result.is_failure(f\"The following instance(s) have the wrong STP root priority configured: {wrong_priority_instances}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPRootPriority.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/stp.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    priority: int\n\"\"\"STP root priority to verify\"\"\"\n    instances: List[Vlan] = []\n\"\"\"List of VLAN or MST instance ID(s). If empty, ALL VLAN or MST instance ID(s) will be verified.\"\"\"\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPRootPriority.Input.instances","title":"instances  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>instances: List[Vlan] = []\n</code></pre> <p>List of VLAN or MST instance ID(s). If empty, ALL VLAN or MST instance ID(s) will be verified.</p>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPRootPriority.Input.priority","title":"priority  <code>instance-attribute</code>","text":"<pre><code>priority: int\n</code></pre> <p>STP root priority to verify</p>"},{"location":"api/tests.system/","title":"System","text":""},{"location":"api/tests.system/#anta-catalog-for-system-tests","title":"ANTA catalog for system tests","text":"<p>Test functions related to system-level features and protocols</p>"},{"location":"api/tests.system/#anta.tests.system.VerifyAgentLogs","title":"VerifyAgentLogs","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies that no agent crash reports are present on the device.</p> Expected Results <ul> <li>success: The test will pass if there is NO agent crash reported.</li> <li>failure: The test will fail if any agent crashes are reported.</li> </ul> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyAgentLogs(AntaTest):\n\"\"\"\n    This test verifies that no agent crash reports are present on the device.\n\n    Expected Results:\n      * success: The test will pass if there is NO agent crash reported.\n      * failure: The test will fail if any agent crashes are reported.\n    \"\"\"\n\n    name = \"VerifyAgentLogs\"\n    description = \"This test verifies that no agent crash reports are present on the device.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show agent logs crash\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].text_output\n        if len(command_output) == 0:\n            self.result.is_success()\n        else:\n            pattern = re.compile(r\"^===&gt; (.*?) &lt;===$\", re.MULTILINE)\n            agents = \"\\n * \".join(pattern.findall(command_output))\n            self.result.is_failure(f\"Device has reported agent crashes:\\n * {agents}\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyCPUUtilization","title":"VerifyCPUUtilization","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies whether the CPU utilization is below 75%.</p> Expected Results <ul> <li>success: The test will pass if the CPU utilization is below 75%.</li> <li>failure: The test will fail if the CPU utilization is over 75%.</li> </ul> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyCPUUtilization(AntaTest):\n\"\"\"\n    This test verifies whether the CPU utilization is below 75%.\n\n    Expected Results:\n      * success: The test will pass if the CPU utilization is below 75%.\n      * failure: The test will fail if the CPU utilization is over 75%.\n    \"\"\"\n\n    name = \"VerifyCPUUtilization\"\n    description = \"This test verifies whether the CPU utilization is below 75%.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show processes top once\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        command_output_data = command_output[\"cpuInfo\"][\"%Cpu(s)\"][\"idle\"]\n        if command_output_data &gt; 25:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device has reported a high CPU utilization: {100 - command_output_data}%\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyCoredump","title":"VerifyCoredump","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies if there are core dump files in the /var/core directory.</p> Expected Results <ul> <li>success: The test will pass if there are NO core dump(s) in /var/core.</li> <li>failure: The test will fail if there are core dump(s) in /var/core.</li> </ul> Note <ul> <li>This test will NOT check for minidump(s) generated by certain agents in /var/core/minidump.</li> </ul> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyCoredump(AntaTest):\n\"\"\"\n    This test verifies if there are core dump files in the /var/core directory.\n\n    Expected Results:\n      * success: The test will pass if there are NO core dump(s) in /var/core.\n      * failure: The test will fail if there are core dump(s) in /var/core.\n\n    Note:\n      * This test will NOT check for minidump(s) generated by certain agents in /var/core/minidump.\n    \"\"\"\n\n    name = \"VerifyCoredump\"\n    description = \"This test verifies if there are core dump files in the /var/core directory.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show system coredump\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        core_files = command_output[\"coreFiles\"]\n        if \"minidump\" in core_files:\n            core_files.remove(\"minidump\")\n        if not core_files:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Core dump(s) have been found: {core_files}\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyFileSystemUtilization","title":"VerifyFileSystemUtilization","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies that no partition is utilizing more than 75% of its disk space.</p> Expected Results <ul> <li>success: The test will pass if all partitions are using less than 75% of its disk space.</li> <li>failure: The test will fail if any partitions are using more than 75% of its disk space.</li> </ul> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyFileSystemUtilization(AntaTest):\n\"\"\"\n    This test verifies that no partition is utilizing more than 75% of its disk space.\n\n    Expected Results:\n      * success: The test will pass if all partitions are using less than 75% of its disk space.\n      * failure: The test will fail if any partitions are using more than 75% of its disk space.\n    \"\"\"\n\n    name = \"VerifyFileSystemUtilization\"\n    description = \"This test verifies that no partition is utilizing more than 75% of its disk space.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"bash timeout 10 df -h\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].text_output\n        self.result.is_success()\n        for line in command_output.split(\"\\n\")[1:]:\n            if \"loop\" not in line and len(line) &gt; 0 and (percentage := int(line.split()[4].replace(\"%\", \"\"))) &gt; 75:\n                self.result.is_failure(f\"Mount point {line} is higher than 75%: reported {percentage}%\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyMemoryUtilization","title":"VerifyMemoryUtilization","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies whether the memory utilization is below 75%.</p> Expected Results <ul> <li>success: The test will pass if the memory utilization is below 75%.</li> <li>failure: The test will fail if the memory utilization is over 75%.</li> </ul> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyMemoryUtilization(AntaTest):\n\"\"\"\n    This test verifies whether the memory utilization is below 75%.\n\n    Expected Results:\n      * success: The test will pass if the memory utilization is below 75%.\n      * failure: The test will fail if the memory utilization is over 75%.\n    \"\"\"\n\n    name = \"VerifyMemoryUtilization\"\n    description = \"This test verifies whether the memory utilization is below 75%.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show version\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        memory_usage = command_output[\"memFree\"] / command_output[\"memTotal\"]\n        if memory_usage &gt; 0.25:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device has reported a high memory usage: {(1 - memory_usage)*100:.2f}%\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyNTP","title":"VerifyNTP","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies that the Network Time Protocol (NTP) is synchronized.</p> Expected Results <ul> <li>success: The test will pass if the NTP is synchronised.</li> <li>failure: The test will fail if the NTP is NOT synchronised.</li> </ul> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyNTP(AntaTest):\n\"\"\"\n    This test verifies that the Network Time Protocol (NTP) is synchronized.\n\n    Expected Results:\n      * success: The test will pass if the NTP is synchronised.\n      * failure: The test will fail if the NTP is NOT synchronised.\n    \"\"\"\n\n    name = \"VerifyNTP\"\n    description = \"This test verifies if NTP is synchronised.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show ntp status\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].text_output\n        if command_output.split(\"\\n\")[0].split(\" \")[0] == \"synchronised\":\n            self.result.is_success()\n        else:\n            data = command_output.split(\"\\n\")[0]\n            self.result.is_failure(f\"NTP server is not synchronized: '{data}'\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyReloadCause","title":"VerifyReloadCause","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies the last reload cause of the device.</p> Expected results <ul> <li>success: The test will pass if there are NO reload causes or if the last reload was caused by the user or after an FPGA upgrade.</li> <li>failure: The test will fail if the last reload was NOT caused by the user or after an FPGA upgrade.</li> <li>error: The test will report an error if the reload cause is NOT available.</li> </ul> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyReloadCause(AntaTest):\n\"\"\"\n    This test verifies the last reload cause of the device.\n\n    Expected results:\n      * success: The test will pass if there are NO reload causes or if the last reload was caused by the user or after an FPGA upgrade.\n      * failure: The test will fail if the last reload was NOT caused by the user or after an FPGA upgrade.\n      * error: The test will report an error if the reload cause is NOT available.\n    \"\"\"\n\n    name = \"VerifyReloadCause\"\n    description = \"This test verifies the last reload cause of the device.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show reload cause\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        if \"resetCauses\" not in command_output.keys():\n            self.result.is_error(message=\"No reload causes available\")\n            return\n        if len(command_output[\"resetCauses\"]) == 0:\n            # No reload causes\n            self.result.is_success()\n            return\n        reset_causes = command_output[\"resetCauses\"]\n        command_output_data = reset_causes[0].get(\"description\")\n        if command_output_data in [\n            \"Reload requested by the user.\",\n            \"Reload requested after FPGA upgrade\",\n        ]:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Reload cause is: '{command_output_data}'\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyUptime","title":"VerifyUptime","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies if the device uptime is higher than the provided minimum uptime value.</p> Expected Results <ul> <li>success: The test will pass if the device uptime is higher than the provided value.</li> <li>failure: The test will fail if the device uptime is lower than the provided value.</li> </ul> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyUptime(AntaTest):\n\"\"\"\n    This test verifies if the device uptime is higher than the provided minimum uptime value.\n\n    Expected Results:\n      * success: The test will pass if the device uptime is higher than the provided value.\n      * failure: The test will fail if the device uptime is lower than the provided value.\n    \"\"\"\n\n    name = \"VerifyUptime\"\n    description = \"This test verifies if the device uptime is higher than the provided minimum uptime value.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show uptime\")]\n\n    class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n        minimum: conint(ge=0)  # type: ignore\n\"\"\"Minimum uptime in seconds\"\"\"\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        if command_output[\"upTime\"] &gt; self.inputs.minimum:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device uptime is {command_output['upTime']} seconds\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyUptime.Input","title":"Input","text":"<p>             Bases: <code>Input</code></p> Source code in <code>anta/tests/system.py</code> <pre><code>class Input(AntaTest.Input):  # pylint: disable=missing-class-docstring\n    minimum: conint(ge=0)  # type: ignore\n\"\"\"Minimum uptime in seconds\"\"\"\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyUptime.Input.minimum","title":"minimum  <code>instance-attribute</code>","text":"<pre><code>minimum: conint(ge=0)\n</code></pre> <p>Minimum uptime in seconds</p>"},{"location":"api/tests.vxlan/","title":"VXLAN","text":""},{"location":"api/tests.vxlan/#anta-catalog-for-vxlan-tests","title":"ANTA catalog for VXLAN tests","text":"<p>Test functions related to VXLAN</p>"},{"location":"api/tests.vxlan/#anta.tests.vxlan.VerifyVxlan1Interface","title":"VerifyVxlan1Interface","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies if the Vxlan1 interface is configured and \u2018up/up\u2019.</p> <p>Warning</p> <p>The name of this test has been updated from \u2018VerifyVxlan\u2019 for better representation.</p> Expected Results <ul> <li>success: The test will pass if the Vxlan1 interface is configured with line protocol status and interface status \u2018up\u2019.</li> <li>failure: The test will fail if the Vxlan1 interface line protocol status or interface status are not \u2018up\u2019.</li> <li>skipped: The test will be skipped if the Vxlan1 interface is not configured.</li> </ul> Source code in <code>anta/tests/vxlan.py</code> <pre><code>class VerifyVxlan1Interface(AntaTest):\n\"\"\"\n    This test verifies if the Vxlan1 interface is configured and 'up/up'.\n\n    !!! warning\n        The name of this test has been updated from 'VerifyVxlan' for better representation.\n\n    Expected Results:\n      * success: The test will pass if the Vxlan1 interface is configured with line protocol status and interface status 'up'.\n      * failure: The test will fail if the Vxlan1 interface line protocol status or interface status are not 'up'.\n      * skipped: The test will be skipped if the Vxlan1 interface is not configured.\n    \"\"\"\n\n    name = \"VerifyVxlan1Interface\"\n    description = \"This test verifies if the Vxlan1 interface is configured and 'up/up'.\"\n    categories = [\"vxlan\"]\n    commands = [AntaCommand(command=\"show interfaces description\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        if \"Vxlan1\" not in command_output[\"interfaceDescriptions\"]:\n            self.result.is_skipped(\"Vxlan1 interface is not configured\")\n        elif (\n            command_output[\"interfaceDescriptions\"][\"Vxlan1\"][\"lineProtocolStatus\"] == \"up\"\n            and command_output[\"interfaceDescriptions\"][\"Vxlan1\"][\"interfaceStatus\"] == \"up\"\n        ):\n            self.result.is_success()\n        else:\n            self.result.is_failure(\n                f\"Vxlan1 interface is {command_output['interfaceDescriptions']['Vxlan1']['lineProtocolStatus']}\"\n                f\"/{command_output['interfaceDescriptions']['Vxlan1']['interfaceStatus']}\"\n            )\n</code></pre>"},{"location":"api/tests.vxlan/#anta.tests.vxlan.VerifyVxlanConfigSanity","title":"VerifyVxlanConfigSanity","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies that no issues are detected with the VXLAN configuration.</p> Expected Results <ul> <li>success: The test will pass if no issues are detected with the VXLAN configuration.</li> <li>failure: The test will fail if issues are detected with the VXLAN configuration.</li> <li>skipped: The test will be skipped if VXLAN is not configured on the device.</li> </ul> Source code in <code>anta/tests/vxlan.py</code> <pre><code>class VerifyVxlanConfigSanity(AntaTest):\n\"\"\"\n    This test verifies that no issues are detected with the VXLAN configuration.\n\n    Expected Results:\n      * success: The test will pass if no issues are detected with the VXLAN configuration.\n      * failure: The test will fail if issues are detected with the VXLAN configuration.\n      * skipped: The test will be skipped if VXLAN is not configured on the device.\n    \"\"\"\n\n    name = \"VerifyVxlanConfigSanity\"\n    description = \"This test verifies that no issues are detected with the VXLAN configuration.\"\n    categories = [\"vxlan\"]\n    commands = [AntaCommand(command=\"show vxlan config-sanity\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        command_output = self.instance_commands[0].json_output\n        if \"categories\" not in command_output or len(command_output[\"categories\"]) == 0:\n            self.result.is_skipped(\"VXLAN is not configured\")\n            return\n        failed_categories = {\n            category: content\n            for category, content in command_output[\"categories\"].items()\n            if category in [\"localVtep\", \"mlag\", \"pd\"] and content[\"allCheckPass\"] is not True\n        }\n        if len(failed_categories) &gt; 0:\n            self.result.is_failure(f\"VXLAN config sanity check is not passing: {failed_categories}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/types/","title":"Input Types","text":""},{"location":"api/types/#anta.custom_types","title":"anta.custom_types","text":"<p>Module that provides predefined types for AntaTest.Input instances</p>"},{"location":"api/types/#anta.custom_types.AAAAuthMethod","title":"AAAAuthMethod  <code>module-attribute</code>","text":"<pre><code>AAAAuthMethod = Annotated[str, AfterValidator(aaa_group_prefix)]\n</code></pre>"},{"location":"api/types/#anta.custom_types.Interface","title":"Interface  <code>module-attribute</code>","text":"<pre><code>Interface = Annotated[str, Field(pattern='^(Ethernet|Fabric|Loopback|Management|Port-Channel|Tunnel|Vlan|Vxlan)[0-9]+(\\\\/[0-9]+)*$')]\n</code></pre>"},{"location":"api/types/#anta.custom_types.TestStatus","title":"TestStatus  <code>module-attribute</code>","text":"<pre><code>TestStatus = Literal['unset', 'success', 'failure', 'error', 'skipped']\n</code></pre>"},{"location":"api/types/#anta.custom_types.Vlan","title":"Vlan  <code>module-attribute</code>","text":"<pre><code>Vlan = Annotated[int, Field(ge=0, le=4094)]\n</code></pre>"},{"location":"api/types/#anta.custom_types.aaa_group_prefix","title":"aaa_group_prefix","text":"<pre><code>aaa_group_prefix(v: str) -&gt; str\n</code></pre> <p>Prefix the AAA method with \u2018group\u2019 if it is known</p> Source code in <code>anta/custom_types.py</code> <pre><code>def aaa_group_prefix(v: str) -&gt; str:\n\"\"\"Prefix the AAA method with 'group' if it is known\"\"\"\n    built_in_methods = [\"local\", \"none\", \"logging\"]\n    return f\"group {v}\" if v not in built_in_methods and not v.startswith(\"group \") else v\n</code></pre>"},{"location":"cli/debug/","title":"Helpers","text":""},{"location":"cli/debug/#anta-debug-commands","title":"ANTA debug commands","text":"<p>The ANTA CLI includes a set of debugging tools, making it easier to build and test ANTA content. This functionality is accessed via the <code>debug</code> subcommand and offers the following options:</p> <ul> <li>Executing a command on a device from your inventory and retrieving the result.</li> <li>Running a templated command on a device from your inventory and retrieving the result.</li> </ul> <p>These tools are especially helpful in building the tests, as they give a visual access to the output received from the eAPI. They also facilitate the extraction of output content for use in unit tests, as described in our contribution guide.</p> <p>Warning</p> <p>The <code>debug</code> tools require a device from your inventory. Thus, you MUST use a valid ANTA Inventory.</p>"},{"location":"cli/debug/#executing-an-eos-command","title":"Executing an EOS command","text":"<p>You can use the <code>run-cmd</code> entrypoint to run a command, which includes the following options:</p>"},{"location":"cli/debug/#command-overview","title":"Command overview","text":"<pre><code>$ anta debug run-cmd --help\nUsage: anta debug run-cmd [OPTIONS]\n\nRun arbitrary command to an ANTA device\n\nOptions:\n  -c, --command TEXT        Command to run  [required]\n--ofmt [json|text]        EOS eAPI format to use. can be text or json\n  -v, --version [1|latest]  EOS eAPI version\n  -r, --revision INTEGER    eAPI command revision\n  -d, --device TEXT         Device from inventory to use  [required]\n--help                    Show this message and exit.\n</code></pre>"},{"location":"cli/debug/#example","title":"Example","text":"<p>This example illustrates how to run the <code>show interfaces description</code> command with a <code>JSON</code> format (default):</p> <pre><code>anta debug run-cmd --command \"show interfaces description\" --device DC1-SPINE1\nRun command show interfaces description on DC1-SPINE1\n{\n'interfaceDescriptions': {\n'Ethernet1': {'lineProtocolStatus': 'up', 'description': 'P2P_LINK_TO_DC1-LEAF1A_Ethernet1', 'interfaceStatus': 'up'},\n        'Ethernet2': {'lineProtocolStatus': 'up', 'description': 'P2P_LINK_TO_DC1-LEAF1B_Ethernet1', 'interfaceStatus': 'up'},\n        'Ethernet3': {'lineProtocolStatus': 'up', 'description': 'P2P_LINK_TO_DC1-BL1_Ethernet1', 'interfaceStatus': 'up'},\n        'Ethernet4': {'lineProtocolStatus': 'up', 'description': 'P2P_LINK_TO_DC1-BL2_Ethernet1', 'interfaceStatus': 'up'},\n        'Loopback0': {'lineProtocolStatus': 'up', 'description': 'EVPN_Overlay_Peering', 'interfaceStatus': 'up'},\n        'Management0': {'lineProtocolStatus': 'up', 'description': 'oob_management', 'interfaceStatus': 'up'}\n}\n}\n</code></pre>"},{"location":"cli/debug/#executing-an-eos-command-using-templates","title":"Executing an EOS command using templates","text":"<p>The <code>run-template</code> entrypoint allows the user to provide an <code>f-string</code> templated command. It is followed by a list of arguments (key-value pairs) that build a dictionary used as template parameters.</p>"},{"location":"cli/debug/#command-overview_1","title":"Command overview","text":"<pre><code>$ anta debug run-template --help\nUsage: anta debug run-template [OPTIONS] PARAMS...\n\n  Run arbitrary templated command to an ANTA device.\n\n  Takes a list of arguments (keys followed by a value) to build a dictionary\n  used as template parameters. Example:\n\n  anta debug run-template -d leaf1a -t 'show vlan {vlan_id}' vlan_id 1\n\nOptions:\n  -t, --template TEXT       Command template to run. E.g. 'show vlan\n                            {vlan_id}'  [required]\n--ofmt [json|text]        EOS eAPI format to use. can be text or json\n  -v, --version [1|latest]  EOS eAPI version\n  -r, --revision INTEGER    eAPI command revision\n  -d, --device TEXT         Device from inventory to use  [required]\n--help                    Show this message and exit.\n</code></pre>"},{"location":"cli/debug/#example_1","title":"Example","text":"<p>This example uses the <code>show vlan {vlan_id}</code> command in a <code>JSON</code> format:</p> <pre><code>anta debug run-template --template \"show vlan {vlan_id}\" vlan_id 10 --device DC1-LEAF1A\nRun templated command 'show vlan {vlan_id}' with {'vlan_id': '10'} on DC1-LEAF1A\n{\n'vlans': {\n'10': {\n'name': 'VRFPROD_VLAN10',\n            'dynamic': False,\n            'status': 'active',\n            'interfaces': {\n'Cpu': {'privatePromoted': False, 'blocked': None},\n                'Port-Channel11': {'privatePromoted': False, 'blocked': None},\n                'Vxlan1': {'privatePromoted': False, 'blocked': None}\n}\n}\n},\n    'sourceDetail': ''\n}\n</code></pre> <p>Warning</p> <p>If multiple arguments of the same key are provided, only the last argument value will be kept in the template parameters.</p>"},{"location":"cli/debug/#example-of-multiple-arguments","title":"Example of multiple arguments","text":"<pre><code>anta --log DEBUG debug run-template --template \"ping {dst} source {src}\" dst \"8.8.8.8\" src Loopback0 --device DC1-SPINE1 \u00a0 \u00a0\n&gt; {'dst': '8.8.8.8', 'src': 'Loopback0'}\n\nanta --log DEBUG debug run-template --template \"ping {dst} source {src}\" dst \"8.8.8.8\" src Loopback0 dst \"1.1.1.1\" src Loopback1 --device DC1-SPINE1 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\n&gt; {'dst': '1.1.1.1', 'src': 'Loopback1'}\n# Notice how `src` and `dst` keep only the latest value\n</code></pre>"},{"location":"cli/exec/","title":"Execute commands","text":""},{"location":"cli/exec/#executing-commands-on-devices","title":"Executing Commands on Devices","text":"<p>ANTA CLI provides a set of entrypoints to facilitate remote command execution on EOS devices.</p>"},{"location":"cli/exec/#exec-command-overview","title":"EXEC Command overview","text":"<pre><code>anta exec --help\nUsage: anta exec [OPTIONS] COMMAND [ARGS]...\n\n  Execute commands to inventory devices\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  clear-counters        Clear counter statistics on EOS devices\n  collect-tech-support  Collect scheduled tech-support from EOS devices\n  snapshot              Collect commands output from devices in inventory\n</code></pre>"},{"location":"cli/exec/#clear-interfaces-counters","title":"Clear interfaces counters","text":"<p>This command clears interface counters on EOS devices specified in your inventory.</p>"},{"location":"cli/exec/#command-overview","title":"Command overview","text":"<pre><code>anta exec clear-counters --help\nUsage: anta exec clear-counters [OPTIONS]\n\nClear counter statistics on EOS devices\n\nOptions:\n  -t, --tags TEXT  List of tags using comma as separator: tag1,tag2,tag3\n  --help           Show this message and exit.\n</code></pre>"},{"location":"cli/exec/#example","title":"Example","text":"<pre><code>anta exec clear-counters --tags SPINE\n[20:19:13] INFO     Connecting to devices...                                                                                                                         utils.py:43\n           INFO     Clearing counters on remote devices...                                                                                                           utils.py:46\n           INFO     Cleared counters on DC1-SPINE2 (cEOSLab)                                                                                                         utils.py:41\n           INFO     Cleared counters on DC2-SPINE1 (cEOSLab)                                                                                                         utils.py:41\n           INFO     Cleared counters on DC1-SPINE1 (cEOSLab)                                                                                                         utils.py:41\n           INFO     Cleared counters on DC2-SPINE2 (cEOSLab)\n</code></pre>"},{"location":"cli/exec/#collect-a-set-of-commands","title":"Collect a set of commands","text":"<p>This command collects all the commands specified in a commands-list file, which can be in either <code>json</code> or <code>text</code> format.</p>"},{"location":"cli/exec/#command-overview_1","title":"Command overview","text":"<pre><code>anta exec snapshot --help\nUsage: anta exec snapshot [OPTIONS]\n\nCollect commands output from devices in inventory\n\nOptions:\n  -t, --tags TEXT           List of tags using comma as separator:\n                            tag1,tag2,tag3\n  -c, --commands-list FILE  File with list of commands to collect  [env var:\n                            ANTA_EXEC_SNAPSHOT_COMMANDS_LIST; required]\n-o, --output DIRECTORY    Directory to save commands output. Will have a\n                            suffix with the format _YEAR-MONTH-DAY_HOUR-\n                            MINUTES-SECONDS'  [env var:\n                            ANTA_EXEC_SNAPSHOT_OUTPUT; default: anta_snapshot]\n--help                    Show this message and exit.\n</code></pre> <p>The commands-list file should follow this structure:</p> <pre><code>---\njson_format:\n- show version\ntext_format:\n- show bfd peers\n</code></pre>"},{"location":"cli/exec/#example_1","title":"Example","text":"<pre><code>anta exec snapshot --tags SPINE --commands-list ./commands.yaml --output ./\n[20:25:15] INFO     Connecting to devices...                                                                                                                         utils.py:78\n           INFO     Collecting commands from remote devices                                                                                                          utils.py:81\n           INFO     Collected command 'show version' from device DC2-SPINE1 (cEOSLab)                                                                                utils.py:76\n           INFO     Collected command 'show version' from device DC2-SPINE2 (cEOSLab)                                                                                utils.py:76\n           INFO     Collected command 'show version' from device DC1-SPINE1 (cEOSLab)                                                                                utils.py:76\n           INFO     Collected command 'show version' from device DC1-SPINE2 (cEOSLab)                                                                                utils.py:76\n[20:25:16] INFO     Collected command 'show bfd peers' from device DC2-SPINE2 (cEOSLab)                                                                              utils.py:76\n           INFO     Collected command 'show bfd peers' from device DC2-SPINE1 (cEOSLab)                                                                              utils.py:76\n           INFO     Collected command 'show bfd peers' from device DC1-SPINE1 (cEOSLab)                                                                              utils.py:76\n           INFO     Collected command 'show bfd peers' from device DC1-SPINE2 (cEOSLab)\n</code></pre> <p>The results of the executed commands will be stored in the output directory specified during command execution:</p> <pre><code>tree _2023-07-14_20_25_15\n_2023-07-14_20_25_15\n\u251c\u2500\u2500 DC1-SPINE1\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 show version.json\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 text\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 show bfd peers.log\n\u251c\u2500\u2500 DC1-SPINE2\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 show version.json\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 text\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 show bfd peers.log\n\u251c\u2500\u2500 DC2-SPINE1\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 show version.json\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 text\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 show bfd peers.log\n\u2514\u2500\u2500 DC2-SPINE2\n    \u251c\u2500\u2500 json\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 show version.json\n    \u2514\u2500\u2500 text\n        \u2514\u2500\u2500 show bfd peers.log\n\n12 directories, 8 files\n</code></pre>"},{"location":"cli/exec/#get-scheduled-tech-support","title":"Get Scheduled tech-support","text":"<p>EOS offers a feature that automatically creates a tech-support archive every hour by default. These archives are stored under <code>/mnt/flash/schedule/tech-support</code>.</p> <pre><code>leaf1#show schedule summary\nMaximum concurrent jobs  1\nPrepend host name to logfile: Yes\nName                 At Time       Last        Interval       Timeout        Max        Max     Logfile Location                  Status\n                                   Time         (mins)        (mins)         Log        Logs\n                                                                            Files       Size\n----------------- ------------- ----------- -------------- ------------- ----------- ---------- --------------------------------- ------\ntech-support           now         08:37          60            30           100         -      flash:schedule/tech-support/      Success\n\n\nleaf1#bash ls /mnt/flash/schedule/tech-support\nleaf1_tech-support_2023-03-09.1337.log.gz  leaf1_tech-support_2023-03-10.0837.log.gz  leaf1_tech-support_2023-03-11.0337.log.gz\n</code></pre> <p>For Network Readiness for Use (NRFU) tests and to keep a comprehensive report of the system state before going live, ANTA provides a command-line interface that efficiently retrieves these files.</p>"},{"location":"cli/exec/#command-overview_2","title":"Command overview","text":"<pre><code>anta exec collect-tech-support --help\nUsage: anta exec collect-tech-support [OPTIONS]\n\nCollect scheduled tech-support from EOS devices\n\nOptions:\n  -o, --output PATH              Path for tests catalog  [default: ./tech-\n                                 support]\n--latest INTEGER               Number of scheduled show-tech to retrieve\n  --configure        Ensure devices have 'aaa authorization exec default\n                     local' configured (required for SCP on EOS). THIS WILL\n                     CHANGE THE CONFIGURATION OF YOUR NETWORK.\n  -t, --tags TEXT                List of tags using comma as separator:\n                                 tag1,tag2,tag3\n  --help                         Show this message and exit.\n</code></pre> <p>When executed, this command fetches tech-support files and downloads them locally into a device-specific subfolder within the designated folder. You can specify the output folder with the <code>--output</code> option.</p> <p>ANTA uses SCP to download files from devices and will not trust unknown SSH hosts by default. Add the SSH public keys of your devices to your <code>known_hosts</code> file or use the <code>anta --insecure</code> option to ignore SSH host keys validation.</p> <p>The configuration <code>aaa authorization exec default</code> must be present on devices to be able to use SCP. ANTA can automatically configure <code>aaa authorization exec default local</code> using the <code>anta exec collect-tech-support --configure</code> option. If you require specific AAA configuration for <code>aaa authorization exec default</code>, like <code>aaa authorization exec default none</code> or <code>aaa authorization exec default group tacacs+</code>, you will need to configure it manually.</p> <p>The <code>--latest</code> option allows retrieval of a specific number of the most recent tech-support files.</p> <p>Warning</p> <p>By default all the tech-support files present on the devices are retrieved.</p>"},{"location":"cli/exec/#example_2","title":"Example","text":"<pre><code>anta --insecure exec collect-tech-support\n[15:27:19] INFO     Connecting to devices...\nINFO     Copying '/mnt/flash/schedule/tech-support/spine1_tech-support_2023-06-09.1315.log.gz' from device spine1 to 'tech-support/spine1' locally\nINFO     Copying '/mnt/flash/schedule/tech-support/leaf3_tech-support_2023-06-09.1315.log.gz' from device leaf3 to 'tech-support/leaf3' locally\nINFO     Copying '/mnt/flash/schedule/tech-support/leaf1_tech-support_2023-06-09.1315.log.gz' from device leaf1 to 'tech-support/leaf1' locally\nINFO     Copying '/mnt/flash/schedule/tech-support/leaf2_tech-support_2023-06-09.1315.log.gz' from device leaf2 to 'tech-support/leaf2' locally\nINFO     Copying '/mnt/flash/schedule/tech-support/spine2_tech-support_2023-06-09.1315.log.gz' from device spine2 to 'tech-support/spine2' locally\nINFO     Copying '/mnt/flash/schedule/tech-support/leaf4_tech-support_2023-06-09.1315.log.gz' from device leaf4 to 'tech-support/leaf4' locally\nINFO     Collected 1 scheduled tech-support from leaf2\nINFO     Collected 1 scheduled tech-support from spine2\nINFO     Collected 1 scheduled tech-support from leaf3\nINFO     Collected 1 scheduled tech-support from spine1\nINFO     Collected 1 scheduled tech-support from leaf1\nINFO     Collected 1 scheduled tech-support from leaf4\n</code></pre> <p>The output folder structure is as follows:</p> <pre><code>tree tech-support/\ntech-support/\n\u251c\u2500\u2500 leaf1\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 leaf1_tech-support_2023-06-09.1315.log.gz\n\u251c\u2500\u2500 leaf2\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 leaf2_tech-support_2023-06-09.1315.log.gz\n\u251c\u2500\u2500 leaf3\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 leaf3_tech-support_2023-06-09.1315.log.gz\n\u251c\u2500\u2500 leaf4\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 leaf4_tech-support_2023-06-09.1315.log.gz\n\u251c\u2500\u2500 spine1\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 spine1_tech-support_2023-06-09.1315.log.gz\n\u2514\u2500\u2500 spine2\n    \u2514\u2500\u2500 spine2_tech-support_2023-06-09.1315.log.gz\n\n6 directories, 6 files\n</code></pre> <p>Each device has its own subdirectory containing the collected tech-support files.</p>"},{"location":"cli/get-inventory-information/","title":"Get Inventory Information","text":""},{"location":"cli/get-inventory-information/#retrieving-inventory-information","title":"Retrieving Inventory Information","text":"<p>The ANTA CLI offers multiple entrypoints to access data from your local inventory.</p>"},{"location":"cli/get-inventory-information/#inventory-used-of-examples","title":"Inventory used of examples","text":"<p>Let\u2019s consider the following inventory:</p> <pre><code>---\nanta_inventory:\nhosts:\n- host: 172.20.20.101\nname: DC1-SPINE1\ntags: [\"SPINE\", \"DC1\"]\n\n- host: 172.20.20.102\nname: DC1-SPINE2\ntags: [\"SPINE\", \"DC1\"]\n\n- host: 172.20.20.111\nname: DC1-LEAF1A\ntags: [\"LEAF\", \"DC1\"]\n\n- host: 172.20.20.112\nname: DC1-LEAF1B\ntags: [\"LEAF\", \"DC1\"]\n\n- host: 172.20.20.121\nname: DC1-BL1\ntags: [\"BL\", \"DC1\"]\n\n- host: 172.20.20.122\nname: DC1-BL2\ntags: [\"BL\", \"DC1\"]\n\n- host: 172.20.20.201\nname: DC2-SPINE1\ntags: [\"SPINE\", \"DC2\"]\n\n- host: 172.20.20.202\nname: DC2-SPINE2\ntags: [\"SPINE\", \"DC2\"]\n\n- host: 172.20.20.211\nname: DC2-LEAF1A\ntags: [\"LEAF\", \"DC2\"]\n\n- host: 172.20.20.212\nname: DC2-LEAF1B\ntags: [\"LEAF\", \"DC2\"]\n\n- host: 172.20.20.221\nname: DC2-BL1\ntags: [\"BL\", \"DC2\"]\n\n- host: 172.20.20.222\nname: DC2-BL2\ntags: [\"BL\", \"DC2\"]\n</code></pre>"},{"location":"cli/get-inventory-information/#obtaining-all-configured-tags","title":"Obtaining all configured tags","text":"<p>As most of ANTA\u2019s commands accommodate tag filtering, this particular command is useful for enumerating all tags configured in the inventory. Running the <code>anta get tags</code> command will return a list of all tags that have been configured in the inventory.</p>"},{"location":"cli/get-inventory-information/#command-overview","title":"Command overview","text":"<pre><code>anta get tags --help\nUsage: anta get tags [OPTIONS]\n\nGet list of configured tags in user inventory.\n\nOptions:\n  --help  Show this message and exit.\n</code></pre>"},{"location":"cli/get-inventory-information/#example","title":"Example","text":"<p>To get the list of all configured tags in the inventory, run the following command:</p> <pre><code>anta get tags\nTags found:\n[\n\"BL\",\n  \"DC1\",\n  \"DC2\",\n  \"LEAF\",\n  \"SPINE\",\n  \"all\"\n]\n\n* note that tag all has been added by anta\n</code></pre> <p>Note</p> <p>Even if you haven\u2019t explicitly configured the <code>all</code> tag in the inventory, it is automatically added. This default tag allows to execute commands on all devices in the inventory when no tag is specified.</p>"},{"location":"cli/get-inventory-information/#list-devices-in-inventory","title":"List devices in inventory","text":"<p>This command will list all devices available in the inventory. Using the <code>--tags</code> option, you can filter this list to only include devices with specific tags. The <code>--connected</code> option allows to display only the devices where a connection has been established.</p>"},{"location":"cli/get-inventory-information/#command-overview_1","title":"Command overview","text":"<pre><code>anta get inventory --help\nUsage: anta get inventory [OPTIONS]\n\nShow inventory loaded in ANTA.\n\nOptions:\n  -t, --tags TEXT                List of tags using comma as separator:\n                                 tag1,tag2,tag3\n  --connected / --not-connected  Display inventory after connection has been\n                                 created\n  --help                         Show this message and exit.\n</code></pre> <p>Tip</p> <p>In its default mode, <code>anta get inventory</code> provides only information that doesn\u2019t rely on a device connection. If you are interested in obtaining connection-dependent details, like the hardware model, please use the <code>--connected</code> option.</p>"},{"location":"cli/get-inventory-information/#example_1","title":"Example","text":"<p>To retrieve a comprehensive list of all devices along with their details, execute the following command. It will provide all the data loaded into the ANTA inventory from your inventory file.</p> <pre><code>anta get inventory --tags SPINE\nCurrent inventory content is:\n{\n'DC1-SPINE1': AsyncEOSDevice(\nname='DC1-SPINE1',\n        tags=['SPINE', 'DC1', 'all'],\n        hw_model=None,\n        is_online=False,\n        established=False,\n        host='172.20.20.101',\n        eapi_port=443,\n        username='arista',\n        password='arista',\n        enable=True,\n        enable_password='arista',\n        insecure=False\n    ),\n    'DC1-SPINE2': AsyncEOSDevice(\nname='DC1-SPINE2',\n        tags=['SPINE', 'DC1', 'all'],\n        hw_model=None,\n        is_online=False,\n        established=False,\n        host='172.20.20.102',\n        eapi_port=443,\n        username='arista',\n        password='arista',\n        enable=True,\n        enable_password='arista',\n        insecure=False\n    ),\n    'DC2-SPINE1': AsyncEOSDevice(\nname='DC2-SPINE1',\n        tags=['SPINE', 'DC2', 'all'],\n        hw_model=None,\n        is_online=False,\n        established=False,\n        host='172.20.20.201',\n        eapi_port=443,\n        username='arista',\n        password='arista',\n        enable=True,\n        enable_password='arista',\n        insecure=False\n    ),\n    'DC2-SPINE2': AsyncEOSDevice(\nname='DC2-SPINE2',\n        tags=['SPINE', 'DC2', 'all'],\n        hw_model=None,\n        is_online=False,\n        established=False,\n        host='172.20.20.202',\n        eapi_port=443,\n        username='arista',\n        password='arista',\n        enable=True,\n        enable_password='arista',\n        insecure=False\n    )\n}\n</code></pre>"},{"location":"cli/inv-from-ansible/","title":"Inventory from Ansible","text":""},{"location":"cli/inv-from-ansible/#create-an-inventory-from-ansible-inventory","title":"Create an Inventory from Ansible inventory","text":"<p>In large setups, it might be beneficial to construct your inventory based on your Ansible inventory. The <code>from-ansible</code> entrypoint of the <code>get</code> command enables the user to create an ANTA inventory from Ansible.</p>"},{"location":"cli/inv-from-ansible/#command-overview","title":"Command overview","text":"<pre><code>anta get from-ansible --help\nUsage: anta get from-ansible [OPTIONS]\n\nBuild ANTA inventory from an ansible inventory YAML file\n\nOptions:\n  -g, --ansible-group TEXT        Ansible group to filter\n  -i, --ansible-inventory FILENAME\n                                  Path to your ansible inventory file to read\n-o, --output FILENAME           Path to save inventory file\n  -d, --inventory-directory PATH  Directory to save inventory file\n  --help                          Show this message and exit.\n</code></pre> <p>The output is an inventory where the name of the container is added as a tag for each host:</p> <pre><code>anta_inventory:\nhosts:\n- host: 10.73.252.41\nname: srv-pod01\n- host: 10.73.252.42\nname: srv-pod02\n- host: 10.73.252.43\nname: srv-pod03\n</code></pre> <p>Warning</p> <p>The current implementation only considers devices directly attached to a specific Ansible group and does not support inheritence when using the <code>--ansible-group</code> option.</p> <p><code>host</code> value is coming from the <code>ansible_host</code> key in your inventory while <code>name</code> is the name you defined for your host. Below is an ansible inventory example used to generate previous inventory:</p> <pre><code>---\ntooling:\nchildren:\nendpoints:\nhosts:\nsrv-pod01:\nansible_httpapi_port: 9023\nansible_port: 9023\nansible_host: 10.73.252.41\ntype: endpoint\nsrv-pod02:\nansible_httpapi_port: 9024\nansible_port: 9024\nansible_host: 10.73.252.42\ntype: endpoint\nsrv-pod03:\nansible_httpapi_port: 9025\nansible_port: 9025\nansible_host: 10.73.252.43\ntype: endpoint\n</code></pre>"},{"location":"cli/inv-from-cvp/","title":"Inventory from CVP","text":""},{"location":"cli/inv-from-cvp/#create-an-inventory-from-cloudvision","title":"Create an Inventory from CloudVision","text":"<p>In large setups, it might be beneficial to construct your inventory based on CloudVision. The <code>from-cvp</code> entrypoint of the <code>get</code> command enables the user to create an ANTA inventory from CloudVision.</p>"},{"location":"cli/inv-from-cvp/#command-overview","title":"Command overview","text":"<pre><code>anta get from-cvp --help\nUsage: anta get from-cvp [OPTIONS]\n\nBuild ANTA inventory from Cloudvision\n\nOptions:\n  -ip, --cvp-ip TEXT              CVP IP Address  [required]\n-u, --cvp-username TEXT         CVP Username  [required]\n-p, --cvp-password TEXT         CVP Password / token  [required]\n-c, --cvp-container TEXT        Container where devices are configured\n  -d, --inventory-directory PATH  Path to save inventory file\n  --help                          Show this message and exit.\n</code></pre> <p>The output is an inventory where the name of the container is added as a tag for each host:</p> <pre><code>anta_inventory:\nhosts:\n- host: 192.168.0.13\nname: leaf2\ntags:\n- pod1\n- host: 192.168.0.15\nname: leaf4\ntags:\n- pod2\n</code></pre> <p>Warning</p> <p>The current implementation only considers devices directly attached to a specific container when using the <code>--cvp-container</code> option.</p>"},{"location":"cli/inv-from-cvp/#creating-an-inventory-from-multiple-containers","title":"Creating an inventory from multiple containers","text":"<p>If you need to create an inventory from multiple containers, you can use a bash command and then manually concatenate files to create a single inventory file:</p> <pre><code>$ for container in pod01 pod02 spines; do anta get from-cvp -ip &lt;cvp-ip&gt; -u cvpadmin -p cvpadmin -c $container -d test-inventory; done\n\n[12:25:35] INFO     Getting auth token from cvp.as73.inetsix.net for user tom\n[12:25:36] INFO     Creating inventory folder /home/tom/Projects/arista/network-test-automation/test-inventory\n           WARNING  Using the new api_token parameter. This will override usage of the cvaas_token parameter if both are provided. This is because api_token and cvaas_token parameters\n                    are for the same use case and api_token is more generic\n           INFO     Connected to CVP cvp.as73.inetsix.net\n\n\n[12:25:37] INFO     Getting auth token from cvp.as73.inetsix.net for user tom\n[12:25:38] WARNING  Using the new api_token parameter. This will override usage of the cvaas_token parameter if both are provided. This is because api_token and cvaas_token parameters\n                    are for the same use case and api_token is more generic\n           INFO     Connected to CVP cvp.as73.inetsix.net\n\n\n[12:25:38] INFO     Getting auth token from cvp.as73.inetsix.net for user tom\n[12:25:39] WARNING  Using the new api_token parameter. This will override usage of the cvaas_token parameter if both are provided. This is because api_token and cvaas_token parameters\n                    are for the same use case and api_token is more generic\n           INFO     Connected to CVP cvp.as73.inetsix.net\n\n           INFO     Inventory file has been created in /home/tom/Projects/arista/network-test-automation/test-inventory/inventory-spines.yml\n</code></pre>"},{"location":"cli/nrfu/","title":"NRFU","text":""},{"location":"cli/nrfu/#execute-network-readiness-for-use-nrfu-testing","title":"Execute Network Readiness For Use (NRFU) Testing","text":"<p>ANTA provides a set of commands for performing NRFU tests on devices. These commands are under the <code>anta nrfu</code> namespace and offer multiple output format options:</p> <ul> <li>Text view</li> <li>Table view</li> <li>JSON view</li> <li>Custom template view</li> </ul>"},{"location":"cli/nrfu/#nrfu-command-overview","title":"NRFU Command overview","text":"<pre><code>anta nrfu --help\nUsage: anta nrfu [OPTIONS] COMMAND [ARGS]...\n\n  Run NRFU against inventory devices\n\nOptions:\n  -c, --catalog FILE  Path to the tests catalog YAML file  [env var:\n                      ANTA_NRFU_CATALOG; required]\n--help              Show this message and exit.\n\nCommands:\n  json        ANTA command to check network state with JSON result\n  table       ANTA command to check network states with table result\n  text        ANTA command to check network states with text result\n  tpl-report  ANTA command to check network state with templated report\n</code></pre> <p>All commands under the <code>anta nrfu</code> namespace require a catalog yaml file specified with the <code>--catalog</code> option.</p>"},{"location":"cli/nrfu/#performing-nrfu-with-text-rendering","title":"Performing NRFU with text rendering","text":"<p>The <code>text</code> subcommand provides a straightforward text report for each test executed on all devices in your inventory.</p>"},{"location":"cli/nrfu/#command-overview","title":"Command overview","text":"<pre><code>anta nrfu text --help\nUsage: anta nrfu text [OPTIONS]\n\nANTA command to check network states with text result\n\nOptions:\n  -t, --tags TEXT    List of tags using comma as separator: tag1,tag2,tag3\n  -s, --search TEXT  Regular expression to search in both name and test\n--skip-error       Hide tests in errors due to connectivity issue\n  --help             Show this message and exit.\n</code></pre> <p>The <code>--tags</code> option allows to target specific devices in your inventory, while the <code>--search</code> option permits filtering based on a regular expression pattern in both the hostname and the test name.</p> <p>The <code>--skip-error</code> option can be used to exclude tests that failed due to connectivity issues or unsupported commands.</p>"},{"location":"cli/nrfu/#example","title":"Example","text":"<p><pre><code>anta nrfu text --tags LEAF --search DC1-LEAF1A\n</code></pre> </p>"},{"location":"cli/nrfu/#performing-nrfu-with-table-rendering","title":"Performing NRFU with table rendering","text":"<p>The <code>table</code> command under the <code>anta nrfu</code> namespace offers a clear and organized table view of the test results, suitable for filtering. It also has its own set of options for better control over the output.</p>"},{"location":"cli/nrfu/#command-overview_1","title":"Command overview","text":"<pre><code>anta nrfu table --help\nUsage: anta nrfu table [OPTIONS]\n\nANTA command to check network states with table result\n\nOptions:\n  --tags TEXT               List of tags using comma as separator:\n                            tag1,tag2,tag3\n  -d, --device TEXT         Show a summary for this device\n  -t, --test TEXT           Show a summary for this test\n--group-by [device|test]  Group result by test or host. default none\n  --help                    Show this message and exit.\n</code></pre> <p>The <code>--tags</code> option can be used to target specific devices in your inventory.</p> <p>The <code>--device</code> and <code>--test</code> options show a summarized view of the test results for a specific host or test case, respectively.</p> <p>The <code>--group-by</code> option show a summarized view of the test results per host or per test.</p>"},{"location":"cli/nrfu/#examples","title":"Examples","text":"<p><pre><code>anta nrfu table --tags LEAF\n</code></pre> </p> <p>For larger setups, you can also group the results by host or test to get a summarized view:</p> <p><pre><code>anta nrfu table --group-by device\n</code></pre> </p> <p><pre><code>anta nrfu table --group-by test\n</code></pre> </p> <p>To get more specific information, it is possible to filter on a single device or a single test:</p> <p><pre><code>anta nrfu table --device spine1\n</code></pre> </p> <p><pre><code>anta nrfu table --test VerifyZeroTouch\n</code></pre> </p>"},{"location":"cli/nrfu/#performing-nrfu-with-json-rendering","title":"Performing NRFU with JSON rendering","text":"<p>The JSON rendering command in NRFU testing is useful in generating a JSON output that can subsequently be passed on to another tool for reporting purposes.</p>"},{"location":"cli/nrfu/#command-overview_2","title":"Command overview","text":"<pre><code>anta nrfu json --help\nUsage: anta nrfu json [OPTIONS]\n\nANTA command to check network state with JSON result\n\nOptions:\n  -t, --tags TEXT    List of tags using comma as separator: tag1,tag2,tag3\n  -o, --output FILE  Path to save report as a file  [env var:\n                     ANTA_NRFU_JSON_OUTPUT]\n--help             Show this message and exit.\n</code></pre> <p>The <code>--tags</code> option can be used to target specific devices in your inventory.</p> <p>The <code>--output</code> option allows you to save the JSON report as a file.</p>"},{"location":"cli/nrfu/#example_1","title":"Example","text":"<p><pre><code>anta nrfu json --tags LEAF\n</code></pre> </p>"},{"location":"cli/nrfu/#performing-nrfu-with-custom-reports","title":"Performing NRFU with custom reports","text":"<p>ANTA offers a CLI option for creating custom reports. This leverages the Jinja2 template system, allowing you to tailor reports to your specific needs.</p>"},{"location":"cli/nrfu/#command-overview_3","title":"Command overview","text":"<p><pre><code>anta nrfu tpl-report --help\nUsage: anta nrfu tpl-report [OPTIONS]\n\nANTA command to check network state with templated report\n\nOptions:\n  -tpl, --template FILE  Path to the template to use for the report  [env var:\n                         ANTA_NRFU_TPL_REPORT_TEMPLATE; required]\n-o, --output FILE      Path to save report as a file  [env var:\n                         ANTA_NRFU_TPL_REPORT_OUTPUT]\n-t, --tags TEXT        List of tags using comma as separator: tag1,tag2,tag3\n  --help                 Show this message and exit.\n</code></pre> The <code>--template</code> option is used to specify the Jinja2 template file for generating the custom report.</p> <p>The <code>--output</code> option allows you to choose the path where the final report will be saved.</p> <p>The <code>--tags</code> option can be used to target specific devices in your inventory.</p>"},{"location":"cli/nrfu/#example_2","title":"Example","text":"<p><pre><code>anta nrfu tpl-report --tags LEAF --template ./custom_template.j2\n</code></pre> </p> <p>The template <code>./custom_template.j2</code> is a simple Jinja2 template:</p> <pre><code>{% for d in data %}\n* {{ d.test }} is [green]{{ d.result | upper}}[/green] for {{ d.name }}\n{% endfor %}\n</code></pre> <p>The Jinja2 template has access to all <code>TestResult</code> elements and their values, as described in this documentation.</p> <p>You can also save the report result to a file using the <code>--output</code> option:</p> <pre><code>anta nrfu tpl-report --tags LEAF --template ./custom_template.j2 --output nrfu-tpl-report.txt\n</code></pre> <p>The resulting output might look like this:</p> <pre><code>cat nrfu-tpl-report.txt\n* VerifyMlagStatus is [green]SUCCESS[/green] for DC1-LEAF1A\n* VerifyMlagInterfaces is [green]SUCCESS[/green] for DC1-LEAF1A\n* VerifyMlagConfigSanity is [green]SUCCESS[/green] for DC1-LEAF1A\n* VerifyMlagReloadDelay is [green]SUCCESS[/green] for DC1-LEAF1A\n</code></pre>"},{"location":"cli/overview/","title":"Overview","text":""},{"location":"cli/overview/#overview-of-antas-command-line-interface-cli","title":"Overview of ANTA\u2019s Command-Line Interface (CLI)","text":"<p>ANTA provides a powerful Command-Line Interface (CLI) to perform a wide range of operations. This document provides a comprehensive overview of ANTA CLI usage and its commands.</p> <p>ANTA can also be used as a Python library, allowing you to build your own tools based on it. Visit this page for more details.</p> <p>To start using the ANTA CLI, open your terminal and type <code>anta</code>.</p>"},{"location":"cli/overview/#invoking-anta-cli","title":"Invoking ANTA CLI","text":"<pre><code>$ anta --help\nUsage: anta [OPTIONS] COMMAND [ARGS]...\n\n  Arista Network Test Automation (ANTA) CLI\n\nOptions:\n  --version                       Show the version and exit.\n  --username TEXT                 Username to connect to EOS  [env var:\n                                  ANTA_USERNAME; required]\n--password TEXT                 Password to connect to EOS that must be\n                                  provided. It can be prompted using '--\n                                  prompt' option.  [env var: ANTA_PASSWORD]\n--enable-password TEXT          Password to access EOS Privileged EXEC mode.\n                                  It can be prompted using '--prompt' option.\n                                  Requires '--enable' option.  [env var:\n                                  ANTA_ENABLE_PASSWORD]\n--enable                        Some commands may require EOS Privileged\n                                  EXEC mode. This option tries to access this\n                                  mode before sending a command to the device.\n                                  [env var: ANTA_ENABLE]\n-P, --prompt                    Prompt for passwords if they are not\n                                  provided.\n  --timeout INTEGER               Global connection timeout  [env var:\n                                  ANTA_TIMEOUT; default: 30]\n--insecure                      Disable SSH Host Key validation  [env var:\n                                  ANTA_INSECURE]\n-i, --inventory FILE            Path to the inventory YAML file  [env var:\n                                  ANTA_INVENTORY; required]\n--log-file FILE                 Send the logs to a file. If logging level is\n                                  DEBUG, only INFO or higher will be sent to\n                                  stdout.  [env var: ANTA_LOG_FILE]\n--log-level, --log [CRITICAL|ERROR|WARNING|INFO|DEBUG]\nANTA logging level  [env var:\n                                  ANTA_LOG_LEVEL; default: INFO]\n--ignore-status                 Always exit with success  [env var:\n                                  ANTA_IGNORE_STATUS]\n--ignore-error                  Only report failures and not errors  [env\n                                  var: ANTA_IGNORE_ERROR]\n--help                          Show this message and exit.\n\nCommands:\n  debug  Debug commands for building ANTA\n  exec   Execute commands to inventory devices\n  get    Get data from/to ANTA\n  nrfu   Run NRFU against inventory devices\n</code></pre>"},{"location":"cli/overview/#anta-global-parameters","title":"ANTA Global Parameters","text":"<p>Certain parameters are globally required and can be either passed to the ANTA CLI or set as an environment variable (ENV VAR).</p> <p>To pass the parameters via the CLI:</p> <pre><code>anta --username tom --password arista123 --inventory inventory.yml &lt;anta cli&gt;\n</code></pre> <p>To set them as ENV VAR:</p> <pre><code>export ANTA_USERNAME=tom\nexport ANTA_PASSWORD=arista123\nexport ANTA_INVENTORY=inventory.yml\n</code></pre> <p>Then, run the CLI:</p> <pre><code>anta &lt;anta cli&gt;\n</code></pre>"},{"location":"cli/overview/#anta-exit-codes","title":"ANTA Exit Codes","text":"<p>ANTA utilizes different exit codes to indicate the status of the test runs.</p> <p>For all subcommands, ANTA will return the exit code 0, indicating a successful operation, except for the nrfu command.</p> <p>For the nrfu command, ANTA uses the following exit codes:</p> <ul> <li><code>Exit code 0</code> - All tests passed successfully.</li> <li><code>Exit code 1</code> - Tests were run, but at least one test returned a failure.</li> <li><code>Exit code 2</code> - Tests were run, but at least one test returned an error.</li> <li><code>Exit code 3</code> - An internal error occurred while executing tests.</li> </ul> <p>To ignore the test status, use <code>anta --ignore-status nrfu</code>, and the exit code will always be 0.</p> <p>To ignore errors, use <code>anta --ignore-error nrfu</code>, and the exit code will be 0 if all tests succeeded or 1 if any test failed.</p>"},{"location":"cli/overview/#shell-completion","title":"Shell Completion","text":"<p>You can enable shell completion for the ANTA CLI:</p> ZSHBASH <p>If you use ZSH shell, add the following line in your <code>~/.zshrc</code>:</p> <pre><code>eval \"$(_ANTA_COMPLETE=zsh_source anta)\" &gt; /dev/null\n</code></pre> <p>With bash, add the following line in your <code>~/.bashrc</code>:</p> <pre><code>eval \"$(_ANTA_COMPLETE=bash_source anta)\" &gt; /dev/null\n</code></pre>"},{"location":"imgs/animated-svg/","title":"Animated svg","text":"<p>Repository: https://github.com/marionebl/svg-term-cli Command: <code>cat anta-nrfu.cast | svg-term --height 10 --window --out anta.svg</code></p>"}]}